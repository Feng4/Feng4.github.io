<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Web应用渗透测试流程]]></title>
    <url>%2F2018%2F11%2F02%2Fweb%E5%BA%94%E7%94%A8%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[Web应用渗透测试对于web应用的测试，一般分为三个阶段：信息收集、漏洞发现以及漏洞利用。 信息收集在信息收集阶段，我们需要尽量多的收集关于目标web应用的各种信息，比如：脚本语言的类型、服务器的类型、目录结构、使用的开源软件、数据库类型、所有链接页面，用到的框架等。 脚本语言的类型常见的脚本语言的类型包括：php、asp、aspx、jsp等。测试方法 爬取网站所有链接，查看后缀 直接访问一个不存在页面后面加不同后缀测试 查看robots.txt，查看后缀]]></content>
      <tags>
        <tag>渗透测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP协议]]></title>
    <url>%2F2018%2F10%2F27%2Fhttp%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[HTTP协议HTTP–Hyper Text Transfer Protocol(超文本传输协议)，是用于从互联网服务器传输超文本到本地浏览器的传输协议。 HTTP是一个基于TCP/IP通信协议来传递数据（HTML文件、图片、查询结果等）。 HTTP工作原理HTTP协议工作于客户端-服务端架构上。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。 Web服务器有：Apache服务器，iis服务器等。Web服务器根据接收到的请求后，向客户端发送响应信息。HTTP默认端口号为80，但是你可以改为8080或其他端口号。HTTP三点注意事项： HTTP是无连接：无连接的含义是限制每次连接只处理一个请求，服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式节省传输时间。 HTTP是媒体独立的：这意味着，只要客户端和服务器知道如何处理的数据内容，任何类型的数据都可以通过HTTP发送。客户端以及服务器指定使用适合的MIME-type内容类型。 HTTP是无状态：HTTP协议是无状态协议。无状态是指协议对事务处理没有记忆功能。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。 转载至菜鸟教程-HTTP简介]]></content>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sql时间盲注]]></title>
    <url>%2F2018%2F10%2F25%2Fsql%E6%97%B6%E9%97%B4%E7%9B%B2%E6%B3%A8%2F</url>
    <content type="text"><![CDATA[sql基于时间的盲注知识点1.时间检测盲注使用的函数 检测是否有时间盲注： and select sleep(5) --+ 2.检测数据库名and if(length(database())&gt;=8,sleep(5),1) --+ and (select if(ascii(substr(database(),1,1)),sleep(5),null)) --+ 3.检测表名检测表名长度 1and if(length((select table_name from information_schema.tables where table_schema=&apos;security&apos; limit 0,1)&gt;5),sleep(5),1)--+ 检测表名 1and if(substr((select table_name from information_schema.tables where table_schema=&apos;security&apos; limit 0,1),1,1)=&apos;a&apos;,sleep(5),1)--+]]></content>
      <categories>
        <category>sql注入</category>
      </categories>
      <tags>
        <tag>sql盲注</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php可变个数参数的函数]]></title>
    <url>%2F2018%2F10%2F25%2Fphp%E5%8F%AF%E5%8F%98%E4%B8%AA%E6%95%B0%E5%8F%82%E6%95%B0%E7%9A%84%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[php可变个数参数的函数php获取可变函数参数的函数php取得可变函数参数，方便后面的控制。 func_num_args()返回传递给该函数参数的个数 func_get_arg($arg_num)取得指定位置的参数值，$arg_num位置index从0开始到n-1。 fun_get_args()返回包含所有参数的数组]]></content>
      <tags>
        <tag>php学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php可变变量]]></title>
    <url>%2F2018%2F10%2F25%2Fphp%E5%8F%AF%E5%8F%98%E5%8F%98%E9%87%8F%2F</url>
    <content type="text"><![CDATA[php可变变量将变量名储存到另一个变量中 123456&lt;?phpheader("content-type:text/html;charset=utf-8"); $a="我是一个变量！"; $b='a'; $echo $$b;?&gt; $$b:$b里保存的是变量a，$a=&quot;我是一个变量！&quot;，所以$$b的值是&quot;我是一个变量！&quot; 多学一招：变量中不但可以保存变量名，还可以保存函数名。]]></content>
      <tags>
        <tag>php学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php静态变量]]></title>
    <url>%2F2018%2F10%2F25%2Fphp%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%2F</url>
    <content type="text"><![CDATA[php静态变量Static（静态）关键字 1.在函数中声明的静态变量，只在调用时声明。2.第二次以后，一看是静态变量，就先到静态区中，看一下有没有这个变量，如果有就使用，而不去再声明。3.静态变量 ，在同一个函数多次调用中，共享把局部变量改变为静态变量后是改变了它的存储方式，即改变了它的生存期。把全局变量改变为静态变量后是改变了它的作用域，限制了它的使用范围。static静态变量会被放在程序的全局存储区中（即在程序的全局数据区，而不是在堆栈中分配，所以不会导致堆栈溢出），这样可以在下一次调用的时候还可以保持原来的赋值。这一点是它与堆栈变量和堆变量的区别。 代码示例： 12345678910111213141516171819202122232425262728293031323334353637&lt;?php//--------------如何理解static静态变量----------- /** 普通局部变量 */function local() &#123; $loc = 0; //这样，如果直接不给初值0是错误的。 ++$loc; echo $loc . '&lt;br&gt;';&#125;local(); //1local(); //1local(); //1echo '===================================&lt;br/&gt;'; /** static静态局部变量 */function static_local() &#123; static $local = 0 ; //此处可以不赋0值 $local++; echo $local . '&lt;br&gt;';&#125;static_local(); //1static_local(); //2static_local(); //3//echo $local; 注意虽然静态变量，但是它仍然是局部的，在外不能直接访问的。echo '=======================================&lt;br&gt;'; /** static静态全局变量(实际上:全局变量本身就是静态存储方式,所有的全局变量都是静态变量) */function static_global() &#123; global $glo; //此处，可以不赋值0，当然赋值0，后每次调用时其值都为0，每次调用函数得到的值都会是1，但是不能想//当然的写上"static"加以修饰，那样是错误的. $glo++; echo $glo . '&lt;br&gt;';&#125;static_global(); //1static_global(); //2static_global(); //3?&gt; 静态局部变量： 1.static类型的内部变量同auto自动变量（即未加static声明的局部变量）一样，是某个特定函数的局部变量，即只能在定义该变量的函数内使用该变量，两者作用域相同；两者的不同在于：auto自动变量会随着函数被调用和退出而存在和消失，而static类局部变量不会，它不管其所在的函数是否被调用，都将一直存在；不过，尽管该变量还继续存在，但不能使用它。倘若再次调用定义它的函数时，它又可继续使用，而且保存了前次被调用后的值。换言之，static类型的局部变量是一种只能在某个特定函数中使用，但一直占据储存空间的变量。 2.函数体内如果在定义静态变量的同时进行了初始化，则以后程序不在进行初始化操作（出现在函数内部的基本类型的静态变量初始化语句只有在第一次调用才执行）。而对自动变量赋初值是在函数调用时进行，每调用一次函数重新给一次初值3，相当于执行一次赋值语句。 3.静态局部变量的初始化表达式必须是一个常量表达式。即使局部静态变量定义时没有赋初值，]]></content>
      <tags>
        <tag>php学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php进制]]></title>
    <url>%2F2018%2F10%2F25%2Fphp%E8%BF%9B%E5%88%B6%2F</url>
    <content type="text"><![CDATA[php进制关于进制的表格： 进制 缩写 单词 十进制 dec decimalist 八进制 oct otconary 二进制 bin binary 十六进制 hex hexadecimal php进制转换函数： decbin()--------十进制 转 二进制 decoct()--------十进制 转 八进制 bindec()--------二进制 转 十进制 我们发现缩写组合一下就是 什么进制 转 什么进制。 php变量中可以存十进制、八进制、十六进制。 php变量5.4之前版本不能储存 二进制。 php进制变量声明： $a = 123 //十进制 $a = 023 //八进制 $a = 0x1A //十六进制]]></content>
      <tags>
        <tag>php学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php回调函数]]></title>
    <url>%2F2018%2F10%2F25%2Fphp%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[php回调函数回调函数：Callback（即call then back 被主函数调用运算后会返回主函数），是指通过函数参数传递到其他代码的，某一块可执行代码的引用。通俗的解释就是把函数作为参数传入进；另一个函数中使用；php中有许多“需求参数为函数”的函数，像array_map,usort,call_user_func_array之类，它们执行传入函数，然后直接将结果返回主函数。好处是函数作为值使用起来方便，而且代码简洁，可读性强。 php中回调函数的实现 php提供了两个内置函数call_user_func()和call_user_func_array()提供对回调函数的支持。这两个函数的区别是call_user_func_array是以数组的形式接收回调函数的参数的，看它的原型就知道了：mixed call_user_func_array(callable $callback,array $param_arr),它只有两个参数。而call_user_func($callback,参数1,,参数2,…)的参数个数根据回调函数的参数来决定的。 如何实现对脚本中全局函数、类中未使用$this的非静态方法、类中使用$this的非静态方法（需要传入对象）、类中静态方法的回调呢？ 实例代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;?php //普通函数 function f1($arg1,$arg2)&#123; echo __FUNCTION__.'exec,the args is:'.$arg1.' '.$arg2; echo "&lt;br /&gt;"; &#125; //通过call_user_func调用函数f1 call_user_func('f1','han','wen'); //通过call_user_func_array调用函数 call_user_func_array('f1',array('han','wen')); class A &#123; public $name; function show($arg1) &#123; echo 'the arg is:'.$arg1."&lt;br /&gt;"; echo 'my name is:'.$this-&gt;name; echo "&lt;br /&gt;"; &#125; function show1($arg1,$arg2) &#123; echo __METHOD__.'exec,the args is:'.$arg1.' '.$arg2."&lt;br /&gt;"; &#125; public static function show2($arg1,$arg2) &#123; echo __METHOD__.'of class A exec,the args is:'.$arg1.' '.$arg2."&lt;br /&gt;"; &#125; &#125; //调用类中非静态成员函数，该成员函数中有$this调用了对象中的成员 $a = new A; $a-&gt;name = 'wen'; call_user_func_array(array($a,'show'),array('han!')); //调用类中非静态成员函数，没有对象被创建，该成员函数中不能有$this call_user_func_array(array('A','show1'),array('an!','wen')); //调用中静态成员函数 call_user_func_array(array('A','show2'),array('argument1','argument2')); ?&gt;]]></content>
      <tags>
        <tag>php学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php访问控制]]></title>
    <url>%2F2018%2F10%2F25%2Fphp%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%2F</url>
    <content type="text"><![CDATA[访问控制（可见性） 对属性或方法的访问控制，是通过在前面添加关键字public（公有），protected（受保护）或private（私有）来实现的。被定义为公有的类成员可以在任何地方被访问。被定义为受保护的类成员则可以被其自身以及其子类和父类访问。被定义为私有的类成员则只能被其定义所在的类访问。 属性的访问控制 类属性必须定义为公有，受保护，私有之一。如果用var定义，则被视为公有。 #####属性声明： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?php/** * 定义类 MyClass */class MyClass&#123; public $public = 'Public(公有)'; protected $protected = 'Protected(受保护)'; private $private = 'Private(私有)'; function printHello() &#123; echo $this-&gt;public; echo $this-&gt;protected; echo $this-&gt;private; &#125;&#125;$obj = new MyClass();echo $obj-&gt;public; //这行能被正常执行echo $obj-&gt;protected; //这行会产生一个致命错误echo $obj-&gt;private; //这行也会产生一个致命错误$obj-&gt;printHello(); //输出 Public(公有)、Protected(受保护) 和 Private(私有)/** * 定义类 MyClass2 */class MyClass2 extends MyClass&#123; //可以对 public 和 protected 进行重定义，但 private 不能 protected $protected = 'Protected2(受保护)'; function printHello() &#123; echo $this-&gt;public; echo $this-&gt;protected; echo $this-&gt;private; &#125;&#125;$obj2 = new MyClass2();echo $obj2-&gt;public; //这行能被执行echo $obj2-&gt;private; //未定义 privateecho $obj2-&gt;protected; //这行会产生一个致命错误$obj2-&gt;printHello(); //输出 Public、Protected2(受保护)、和 Undefined?&gt; 方法的访问控制 类中的方法可以被定义为公有，私有或受保护。如果没有设置这些关键字，则该方法默认为公有。 方法声明：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182&lt;?php/** *定义类 MyClass */class MyClass&#123; //声明一个公有的构造函数 public function __construct()&#123;&#125; //声明一个公有的方法 public function MyPublic()&#123;&#125; //声明一个受保护的方法 protected function MyProtected()&#123;&#125; //声明一个私有的方法 private function MyPrivate()&#123;&#125; //此方法为公有 function Foo() &#123; $this-&gt;MyPublic(); $this-&gt;MyProtected(); $this-&gt;MyPrivate(); &#125;&#125;$myclass = new MyClass;$myclass-&gt;MyPublic(); //这行能被正常执行$myclass-&gt;MyProtected(); //这行会产生一个致命错误$myclass-&gt;MyPrivate(); //这行会产生一个致命错误$myclass-&gt;Foo(); //公有，受保护，私有都可执行/** *定义类 MyClass2 */class MyClass2 extends MyClass&#123; //此方法为公有 function Foo2() &#123; $this-&gt;MyPublic(); $this-&gt;MyProtected(); $this-&gt;MyPrivate(); //这行会产生一个致命错误 &#125;&#125;$myclass2 = new MyClass2;$myclass2-&gt;MyPublic(); //这行能被正常执行$myclass2-&gt;Foo2(); //公有的和受保护的都可执行，但私有的不行class Bar&#123; public function test()&#123; $this-&gt;testPrivate(); $this-&gt;testPublic(); &#125; public function testPublic()&#123; echo "Bar::testPublic\n"; &#125; private function testPrivate()&#123; echo "Bar::testPrivate\n"; &#125;&#125;class Foo extends Bar&#123; public function testPublic()&#123; echo "Foo::testPublic\n"; &#125; private function testPrivate()&#123; echo "Foo::testPrivate\n"; &#125;$myFoo = new foo();$myFoo-&gt;test(); //Bar::testPrivate //Foo::testPublic?&gt;]]></content>
      <tags>
        <tag>php学习</tag>
        <tag>public（公有）</tag>
        <tag>protected（受保护）</tag>
        <tag>private（私有）</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php递归]]></title>
    <url>%2F2018%2F10%2F25%2Fphp%E9%80%92%E5%BD%92%2F</url>
    <content type="text"><![CDATA[什么是php递归函数？递归函数即自动调用函数，在函数体内部直接或者间接的自己调用自己，即函数的嵌套调用是函数本身。通常在此类型的函数题之中会附加一个条件判断叙述，以判断是否需要执行递归调用，并且在特定的条件下终止函数的递归调用动作，把目前流程的主控制权回到上一层函数来执行。从此，当某个执行递归调用的函数没有附加条件判断叙述时，可能会造成无限循环的错误情形。函数递归调用最大的好处在于可以精简程序中的复杂重复调用程序，并且能以这种特性来执行一些较为复杂的运算动作。例如，列表、动态树形菜单及遍历目录等操作。相应的非递归函数虽然效率高，但却比较难编程，而且相对来说可读性差。现代程序设计的目标主要是可读性好。随着计算机硬件性能的不断提高，程序在更多的场合优先考虑可读而不是高效，所以，鼓励用递归函数实现程序思想。一个简单的递归调用实例如下所示: 12345678910111213&lt;?php//声明一个函数，用于测试递归function test($n)&#123; echo $n." "; //在函数开始输出参数的值 if($n&gt;0)&#123; //判断参数是否大于0 test($n-1); //如果参数大于0则调用自己，并将参数减1后再次传入 &#125;else&#123; //判断参数是不大于0 echo "&lt;----------&gt; "; &#125; echo $n." ";&#125;test(10); //调用test函数将整数10传给参数?&gt; 输出结果： 10 9 8 7 6 5 4 3 2 1 0 &lt;---------&gt; 0 1 2 3 4 5 6 7 8 9 10 说明：在上面的实例中声明了一个test()函数，该函数需要一个整型的参数。在函数外面通过传递整数10作为参数调用test()函数。在test()函数体中，第一条代码输出参数的值和一个空格。然后判断条件是否成立，成立则调用自己并将参数减1，再次传入。开始调用时，它是外层调内层，内层调更内一层，直到最内层由于条件不允许必须结束。最内层结束了。输出作为分界符，执行调用之后的代码输出参数的值和空格，它就会回到稍外一层继续执行。稍外一层在结束时，退回到在稍外一层继续执行，层层推出，直到最外层结束。执行完成以后的结果就是我们上面看到的结果。]]></content>
      <tags>
        <tag>php学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php常量]]></title>
    <url>%2F2018%2F10%2F25%2Fphp%E5%B8%B8%E9%87%8F%2F</url>
    <content type="text"><![CDATA[php常量1.常量：一旦声明，这个常量的值就不会被改变 2.如果常量没有声明，则常量名在使用时，会自动转为字符串（效率很低） 3.常量名称，不要加$符号 4.常量名称，默认是区分大小写的（变量也区分大小写），习惯上常量名称要全部大写 5.可以使用define()第三个参数来决定是否让这个常量名称区分大小写 true false。例如：define(&quot;QA&quot;,123,true); 6.常量的值只支持标量数据类型（整型，浮点型，字符型...,数组不是标量数据类型）]]></content>
      <tags>
        <tag>php学习</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2018%2F10%2F25%2Fphp%E8%A1%A8%E5%8D%95%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[php变量函数]]></title>
    <url>%2F2018%2F10%2F25%2Fphp%E5%8F%98%E9%87%8F%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[php变量函数php支持变量函数的概念。这意味着如果一个变量名后有圆括号，php将寻找与变量的值同名的函数，并且将尝试执行它。除了别的事情以外，这个可以被用于实现回调函数，函数表等等。变量函数不能用于语言结构，例如echo(),print(),unset(),isset(),empty(),include(),require()以及类似的语句。需要使用自己的外壳函数来将这些结构用作变量函数。 变量函数示例： 1234567891011121314151617181920212223&lt;?phpfunction foo()&#123; echo "In foo()&lt;br /&gt;\n";&#125;function bar($arg = '')&#123; echo "In bar();argument was '$arg'.&lt;br /&gt;\n";&#125;//This is a wrapper function around echofunction echoit($string)&#123; echo $string;&#125;$func = 'foo';$func(); //这里调用foo()$func = 'bar';$func('test'); //这里调用bar()$func = 'echoit';$func('test'); //这里调用echoit() 还可利用变量函数的特性来调用一个对象的方法。 变量方法范例： 1234567891011121314151617181920&lt;?phpclass Foo&#123; function Variable() &#123; $name = 'Bar'; $this-&gt;$name();//这是Bar()方法 &#125; functoin Bar() &#123; echo "这是Bar"; &#125;&#125;$foo = new Foo();$funcname = "Variable";$foo-&gt;$funcname(); //这是$foo-&gt;Variable()?&gt;]]></content>
      <tags>
        <tag>php学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php string函数]]></title>
    <url>%2F2018%2F10%2F25%2Fphp%20string%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[string函数1.chr() chr()函数从指定的ascii值返回字符。 2.strlen() 计算字符串的长度，如果是中文的字符则代表两个长度。 3.trim() 去除字符串的两边空格。 4.strtolower() 把字符串转换为小写。 5.strtoupper() 把字符串转换为大写。 6.htmlspecialchars() 把特殊字符转换为HTML编码。 7.strrev() 反转字符。 8.strpos() 找出字符第一次出现的位置，下标从0开始，区分大小写strpos(&apos;字符串&apos;，要找的字符) mixed strpos ( string $haystack , mixed $needle [, int $offset = 0 ] ) 返回 needle 在 haystack 中首次出现的数字位置。 9.stristr() 不区分大小写，找到指定字符的位置，然后，进行截取，一直截取到末尾，包括字符本身 10.strrchr() 找到字符最后出现的位置，区分大小写，并截取到末尾 11.str_replace() 字符串替换函数。 12.substr() 截取字符串函数 substr(&apos;字符串&apos;,开始位置，结束位置) 如果结束位置没有填写，则默认截取的结尾 13.join() 把数组连接成为字符串]]></content>
      <tags>
        <tag>php学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sql盲注笔记]]></title>
    <url>%2F2018%2F10%2F25%2Fmysql%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[基于布尔sql盲注———构造逻辑判断截取字符串相关函数： left(database(),1)&gt;’s’ //left()函数Explain：database()显示数据库名称，left(a,b)从左侧截取a的前b位 ascii(substr((select table_name information_schema.tables where table_schema=database() limit 0,1),1,1))=101 –+ //substr()函数，ascii()函数Explain:substr(a,b,c)从 b 位置开始，截取字符串 a 的 c 长度。ascii()将某个字符转换为ascii值。 ascii(substr((select database()),1,1))=98 ord(mid((select ifnull(cast(username as char),0x20) from security.users order by id limit 0,1),1,1))&gt;98%23 //ord()函数，mid()函数Explain:mid(a,b,c)从位置b开始，截取a字符串的c位 ord()函数同ascii()，将字符转为ascii值。 regexp 正则注入用法介绍：select user() regexp ‘^[a-z]’;Explain:正则表达式的用法，user()结果为root，regexp为匹配root的正则表达式。第二位可以用select user() regexp ‘^ro’来进行。当正确的时候显示结果为1，不正确的时候显示结果为0.]]></content>
      <tags>
        <tag>sql注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux命令详解]]></title>
    <url>%2F2018%2F10%2F25%2Flinux%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[linux命令详解linux命令的通用格式命令 [选项] [参数] 选项及参数的含义：选项：用于调节命令的功能 &gt;以&quot;-&quot;引导短格式选项（单个字符），例如&quot;-l&quot; &gt;以&quot;--&quot;引导长格式选项（多个字符），例如&quot;--color&quot; &gt;多个短格式选项可以写在一起，只用一个&quot;-&quot;引导，例如&quot;-al&quot; 参数：命令操作的对象，如文件，目录名等。例如&quot;ls -l /home 命令行编辑的几个辅助操作:反斜杠&quot;\&quot;;强制换行 快捷键 ctrl+U 清空至行首 ctrl+K 清空至行尾 ctrl+L 清屏 ctrl+C 取消本次命令编辑 ctrl+alt+F2 切换图形界面或命令行界面 --help 查看帮助 uname命令：-a 显示主机名，内核版本，硬件平台等详细信息。 -r 显示内核版本 hostname命令：查看主机名 关机命令：halt 关机 shutdown -h now 现在关机 poweroff 关机 shutdown -r 重启 reboot 重启 目录切换命令：cd 切换目录 pwd 查看当前所在目录 ls命令：列表显示目录内容 格式： ls [选项] .....[目录或文件名] 选项： -l 以长格式显示 -a 显示所有字目录和文件信息，包括隐藏文件 -A 类似于&quot;-a&quot;，但不显示&quot;.&quot;和&quot;..&quot;目录信息。 -d 显示目录本身的属性 -h 以更易读的字节单位（K,M 等）显示信息 -R 递归显示内容 --color 以颜色区分不同类型文件 du命令：统计目录及文件的空间占用情况 格式： du [选项].....[目录或文件名] 选项： -a 统计时包括所有的文件，而不仅仅只统计目录 -h 以更易读的字节单位（K,M 等）显示信息 -s 只统计每个参数所占用空间总大小。 mkdir命令：创建新的目录 格式： mkdir [-p] [路径] 目录名 touch命令：创建文件，或更新文件的时间标记 格式： touch 文件名 ln命令：为文件或目录建立链接。Link 格式： ln [-s] 源文件或目录....链接文件或目标目录 选项： -s 建立符号链接文件（省略此项建立硬链接） cp命令：复制 文件或目录 格式： cp [选项] 源文件或目录....目标文件或目录 选项： -r 递归复制整个目录树 -p 保持源文件的属性不变 -f 强制覆盖目标同名文件或目录 -i 需要覆盖文件或目录时进行提醒 rm命令：删除 文件或目录 格式： rm [选项]... 文件或目录 选项： -f 强行删除文件或目录，不进行提醒 -i 删除文件或目录时提醒用户确认 -r 递归删除整个目录树 防火墙命令：1) Linux操作系统中永久性生效，重启后不会复原 开启： chkconfig iptables on 关闭： chkconfig iptables off 2) 即时生效，重启后复原 开启： service iptables start 关闭： service iptables stop 需要说明的是对于Linux操作系统中的其它服务都可以用以上命令执行开启和关闭操作。 在开启了防火墙时，做如下设置，开启相关端口， 修改/etc/sysconfig/iptables 文件，添加以下内容： -A RH-Firewall-1-INPUT -m state --state NEW -m tcp -p tcp --dport 80 -j ACCEPT -A RH-Firewall-1-INPUT -m state --state NEW -m tcp -p tcp --dport 22 -j ACCEPT]]></content>
      <categories>
        <category>命令学习</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式]]></title>
    <url>%2F2018%2F10%2F25%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[表示字符 字符 功能 . 匹配任意1个字符（除了\n） [] 匹配[]中列举的字符 \d 匹配数字，即0-9 \D 匹配非数字，既不是数字 \s 匹配空白，即空格，tab键 \S 匹配非空白 \w 匹配单词字符，即a-z,A-Z,0-9,_ \W 匹配非单词字符]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[命令行中执行php代码，传递参数]]></title>
    <url>%2F2018%2F10%2F25%2F%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%AD%E6%89%A7%E8%A1%8Cphp%E4%BB%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[命令行中执行php代码，传递参数 $_GET和$_POST用来获取http提交的参数，不能获取命令行提交的参数。通过命令行传递数 通过$argv获取参数的值，$argc用来获取传递参数的个数。]]></content>
      <tags>
        <tag>php学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows命令]]></title>
    <url>%2F2018%2F10%2F25%2Fwindows%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[windows命令windows常用快捷键：F1 显示当前程序或者windows的帮助内容 F2 当你选中一个文件的话，这意味着“重命名” F3 当你在桌面上的时候是打开“查找：所有文件”对话框 ctrl+F4 关闭当前应用程序中的当前文本 F5 刷新 ctrl+F5 强行刷新 ctrl+F6 切换到当前 ipconfig命令：ipconfig /release------释放IP ipconfig /renew--------重新获取IP 目录（文件）操作： md 目录名------------创建目录 rd 目录名------------删除文件夹 ren 原文件名 新文件名---------重命名 del 文件名或目录名------------删除文件或文件夹 copy ------------------------复制文件 move ------------------------移动文件 tree ------------------------树形列出文件夹结构 type ------------------------打开文件 start -----------------------打开文件或网站 conpy con c:\123.txt ----创建一个123.txt，ctrl+z退出写入 net start命令：net start---------查看开启了哪些服务 net start 服务名---开启特定服务 net stop 服务名 ---关闭特定服务 net user命令：net user 用户名 密码 /add-------------------建立用户 net user guest /active:yes-----------------激活guest用户 net user-----------------------------------查看有哪些用户 net user 账户名-----------------------------查看账户属性 net locaLGroup administrators 用户名 /add---把“用户名”添加到管理员中使其具有管理员权限 net user guest 12345-----------------------用guest用户登录后，将密码改为12345 net password 密码--------------------------更改系统登录密码 win键+R 【输入内容】cmd------------------命令窗口 mstsc----------------远程桌面连接窗口 gpedit.msc-----------打开本地组策略 services.msc---------打开服务窗口 notepad--------------打开记事本 regedit--------------打开注册表 control--------------打开控制面板]]></content>
      <categories>
        <category>命令学习</category>
      </categories>
      <tags>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sql注入]]></title>
    <url>%2F2018%2F10%2F25%2Fsql%E6%B3%A8%E5%85%A5%2F</url>
    <content type="text"><![CDATA[【一、SQL注入原理】1.锁定目标 在浏览器的搜索框中输入：公司 inurl asp?id=，然后点击搜索按钮，会列出所有asp相关的网站信息，从中选取一个 这里我们选取http://www.zhjzg.com/ship.asp?id=4 2.将上述目标地址粘贴到浏览器的地址栏中打开，然后在其后面加上一个单引号，如下： http://www.zhjzg.com/ship.asp?id=4‘ 回车之后，会发现页面显示错误如下： Microsoft OLE DB Provider for ODBC Drivers error &apos;80040e14&apos; [Microsoft][ODBC Microsoft Access Driver] Syntax error in string in query expression &apos;shipline.id=ship.shiplineid and shipline.groundid=ground.id and ground.id=4&apos; order by shiptime&apos;./ship.asp, line 107 从上面这段错误，我们可以看出以下几点内容： （1）网站使用的是Access数据库，通过ODBC连接数据库。 （2）程序没有判断客户端提交的数据是否符合程序要求。 （3）该SQL语句所查询的表中有一名为ID的字段。 从上面的例子我们可以知道，ＳＱＬ注入的原理，就是从客户端提交特殊的代码，从而收集程序及服务器的信息，从而获取你想到得到的资料。 【二、判断是否可以进行SQL注入】看完第一节，是否感觉SQL注入测试不是很简单吗？其实，这并不是最好的方法，为什么呢？ 首先，不一定每台服务器的IIS都返回具体错误提示给客户端，如果程序中加了cint(参数)之类语句的话，ＳＱＬ注入是不会成功的，但服务器同样 会报错，具体提示信息为处理 URL 时服务器上出错。请和系统管理员联络。 其次，部分对ＳＱＬ注入有一点了解的程序员，认为只要把单引号过滤掉就安全了，这种情况不为少数，如果你用单引号测试，是测不到注入点的 那么，什么样的测试方法才是比较准确呢？答案如下： ① http://www.wenkuxiazai.com/showdetail.asp?id=49 ② http://www.wenkuxiazai.com/showdetail.asp?id=49 and 1=1 ③ http://www.wenkuxiazai.com/showdetail.asp?id=49 and 1=2 这就是经典的1=1、1=2测试法了，怎么判断呢？看看上面三个网址返回的结果就知道了： 可以注入的表现： ① 正常显示（这是必然的，不然就是程序有错误了） ② 正常显示，内容基本与①相同 ③ 提示BOF或EOF（程序没做任何判断时）、或提示找不到记录（判断了rs.eof时）、或显示内容为空（程序加了on error resume next） 不可以注入就比较容易判断了 ①同样正常显示 ②和③一般都会有程序定义的错误提示，或提示类型转换时出错。 当然，这只是传入参数是数字型的时候用的判断方法，实际应用的时候会有字符型和搜索型参数，我将在中级篇的“ＳＱＬ注入一般步骤”再做分析。 【三、判断数据库类型及注入方法】不同的数据库的函数、注入方法都是有差异的，所以在注入之前，我们还要判断一下数据库的类型。一般ASP最常搭配的数据库是Access和 SQLServer，网上超过99%的网站都是其中之一。 怎么让程序告诉你它使用的什么数据库呢？来看看： &lt;途径一：直接从出错信息获取&gt; SQLServer有一些系统变量，如果服务器IIS提示没关闭，并且SQLServer返回错误提示的话，那可以直接从出错信息获取，方法如下： http://www.wenkuxiazai.com/showdetail.asp?id=49 and user&gt;0 它的含义： 首先，前面的语句是正常的，重点在and user&gt;0，user是SQLServer的一个内置变量，它的值是当前连接的用户名，类型为nvarchar。 然后，拿一个nvarchar的值跟int的数0比较，系统会先试图将nvarchar的值转成int型，当然，转的过程中肯定会出错，SQLServer的出错提示 是：将nvarchar值 ”abc” 转换数据类型为 int 的列时发生语法错误，abc正是变量user的值 这样，不废吹灰之力就拿到了数据库的用户名 顺便说几句，众所周知，SQLServer的用户sa是个等同Adminstrators权限的角色，拿到了sa权限，几乎肯定可以拿到主机的Administrator了。 上面的方法可以很方便的测试出是否是用sa登录，要注意的是：如果是sa登录，提示是将”dbo”转换成int的列发生错误，而不是”sa”。 &lt;途径二：从数据库系统表的判断入手&gt; 如果服务器IIS不允许返回错误提示，那怎么判断数据库类型呢？ 首先，我们可以从Access和SQLServer和区别入手，Access和SQLServer都有自己的系统表，比如存放数据库中所有对象的表，Access是在系统表 [msysobjects]中，但在Web环境下读该表会提示“没有权限”，SQLServer是在表[sysobjects]中，在Web环境下可正常读取。 然后在确认可以注入的情况下，使用下面的语句： http://www.wenkuxiazai.com/showdetail.asp?id=49 and (select count(*) from sysobjects)&gt;0 http://www.wenkuxiazai.com/showdetail.asp?id=49 and (select count(*) from msysobjects)&gt;0 结果分析： 如果数据库是SQLServer，那么第一个网址的页面与原页面http://www.wenkuxiazai.com/showdetail.asp?id=49是大致相同的； 而第二个网址，由于找不到表msysobjects，会提示出错，就算程序有容错处理，页面也与原页面完全不同。 如果数据库用的是Access，那么情况就有所不同，第一个网址的页面与原页面完全不同； 第二个网址，则视乎数据库设置是否允许读该系统表，一般来说是不允许的，所以与原网址也是完全不同。 大多数情况下，用第一个网址就可以得知系统所用的数据库类型，第二个网址只作为开启IIS错误提示时的验证。]]></content>
      <categories>
        <category>sql注入</category>
      </categories>
      <tags>
        <tag>sql注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php+mysql注入]]></title>
    <url>%2F2018%2F10%2F25%2Fphp%E6%B3%A8%E5%85%A5%2F</url>
    <content type="text"><![CDATA[php+mysql（5.0以上）注入 1.判断注入点 2.猜解字段数 3.猜数据库名 4.猜表名 5.猜列名 6.猜数据 注入语句: http://127.0.0.1/wl13/sql.php?x=1 union select 1,2,3 查询信息： http://127.0.0.1/wl13/sql.php?x=1%20union%20select%20database(),version(),user() 注入函数： 数据库名 database() 数据库版本 version() 数据库用户 user() 操作系统 @@version_compile_os Mysql5.0 注入（有根据） 数据库中“.”代表下一级 Information_schema： mysql5.0及以上版本自带数据库，存储有mysql所有数据库下的表名及列名信息 Information_schema.tables：存储所有表名信息的表 Table_name：表名 table_schema：数据库名 Column_name：列名 information_schema.columns：存储所有列名信息的表]]></content>
      <categories>
        <category>sql注入</category>
      </categories>
      <tags>
        <tag>mysql注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php位运算]]></title>
    <url>%2F2018%2F10%2F25%2Fphp%E4%BD%8D%E8%BF%90%E7%AE%97%2F</url>
    <content type="text"><![CDATA[php位运算&amp; 换位与 只有参与运算的两位都为1时，运算结果才为1，否则为0 $a &amp; $b | 换位或 只有参与运算的两位都为0时，运算结果才为0，否则为1. $a &amp; $b ^ 换位异或 只有参与运算的两位不同，运算结果才为1，否则为0 ^$b ~ 按位非 将用二进制表示的操作中的1变成0,0变成1 ~$a &lt;&lt; 左移 将左边的操作数在内存中的二进制数据右移右边操作数指定的位数，右边移空的部分补上0 $a&lt;&lt;$b &gt;&gt; 右移 将左移的操作数在内存中的二进制数据左移右边操作数指定的位数。左边移空的部分补上0 $a&gt;&gt;$b]]></content>
      <tags>
        <tag>php学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php匿名函数]]></title>
    <url>%2F2018%2F10%2F25%2Fphp%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[php匿名函数 匿名函数。也叫闭包函数，允许临时创建一个没有指定名称的函数。最经常用作回调函数参数的值。当然，也有其他应用的情况。 匿名函数目前是通过Closure类来实现的。 匿名函数示例： 123456&lt;?php echo preg_repllace_callback('~-([a-z])~', function($match)&#123; return strtoupper($match[1]);&#125;,'hello-world');//输出 helloworld?&gt; 闭包函数也可以作为变量的值来使用。php会自动把此种表达式转换成内置类Closure的对象实例。把一个Closure对象赋值给一个变量的方式与普通变量赋值的语法是一样的，最后也要加上分号： 匿名函数变量赋值示例： 123456789&lt;?php$gree = function($name);&#123; print("Hello %s\r\n", $name);&#125;;$greet('World');$greet('PHP');?&gt; 闭包可以从父作用域中继承变量。任何此类变量都应该用use语言结构传递进去。php7.1起，不能传入此类变量；superglobals、$this或者和参数重名。 从父作用域继承变量： 12345678910111213141516171819202122232425262728293031323334353637383940&lt;?php$message = 'hello';//没有"use"$example = function ()&#123; var_dump($message);&#125;;echo $example();//继承$message$example = function () use ($message)&#123; var_dump($message);&#125;;echo $example();// Inherited variable's value is from when the function// is defined, not when called$message = 'world';echo $example();// Reset message$message = 'hello';// Inherit by-reference$example = function () use (&amp;$message) &#123; var_dump($message);&#125;;echo $example();// The changed value in the parent scope// is reflected inside the function call$message = 'world';echo $example();// Closures can also accept regular arguments$example = function ($arg) use ($message) &#123; var_dump($arg . ' ' . $message);&#125;;$example("hello");?&gt; 以上例子的输出类似于： Notice: Undefined variable: message in /example.php on line 6 NULL string(5) &quot;hello&quot; string(5) &quot;hello&quot; string(5) &quot;hello&quot; string(5) &quot;world&quot; string(11) &quot;hello world&quot;]]></content>
      <tags>
        <tag>php学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php魔术常量]]></title>
    <url>%2F2018%2F10%2F25%2Fphp%E9%AD%94%E6%9C%AF%E5%B8%B8%E9%87%8F%2F</url>
    <content type="text"><![CDATA[php魔术变量 php向它运行的任何脚本提供了大量的预定义常量 不过很多常量都是由不同的扩展库定义的，只有在加载了这些扩展库时才会出现，或者动态加载后，或者在编译时已经包括进去了。 有八个魔术常量它们的值随着它们在代码中的位置改变而改变。 例如：LINE的值就依赖于它在脚本中所处的行来决定。这些特殊的常量不区分大小写，如下： LINE__LINE__文件中的当前行号。 实例 &lt;?php echo &apos;这是第 &quot;&apos; . __LINE__ . &apos; &quot;行&apos;; ?&gt; 以上实例输出结果为： 这是第 &quot;2&quot; 行 FILE __FILE__ 文件的完整路径和文件名。如果用在被包含文件中，则返回被包含的文件名。 自php 4.0.2起，FILE总是包含一个绝对路径（如果是符号连接，则是解析后的绝对路径），而在此之前的版本有时会包含一个相对路径。 实例 &lt;?php echo &apos;该文件位于 &quot;&apos; .__FILE__. &apos; &quot;&apos;; ?&gt; 以上实例输出结果为： 该文件位于 &quot;E:\wamp\www\test\index.php&quot; DIR__DIR__ 文件所在的目录。如果用在被包括文件中，则返回被包括的文件所在的目录。 它等价于dirname(FILE)。除非是根目录，否则目录中名不包括末尾斜杠。（php 5.3.0中新增） 实例 &lt;?php echo &apos;该文件位于 &quot;&apos; .__DIR__.&apos;&quot; &apos;; ?&gt; 以上实例输出结果为： 该文件位于 &quot;E:\wamp\www\test&quot; FUNCTION__FUNCTION__函数名称（php 4.3.0新加）。自php5 起本常量返回该函数被定义时的名字（区分大小写）。在php4 中该值总是小写字母的。 实例 &lt;?php function test(){ echo &apos;函数名为：&apos; .__FUNCTION__; } test(); ?&gt; 以上实例输出结果为： 函数名为：test]]></content>
      <tags>
        <tag>php学习</tag>
      </tags>
  </entry>
</search>
